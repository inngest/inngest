package fn

import (
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/fatih/structs"
	"github.com/inngest/inngest/pkg/enums"
	"github.com/xhit/go-str2duration/v2"
)

// ServableFunction defines a function which can be called by a handler's Serve method.
// This is created via CreateFunction in this package.
type ServableFunction interface {
	FullyQualifiedID() string

	ID() string

	// Name returns the function name.
	Name() string

	Config() FunctionOpts

	// Trigger returns the event names or schedules that triggers the function.
	Trigger() Triggerable

	// ZeroEvent returns the zero event type to marshal the event into, given an
	// event name.
	ZeroEvent() any

	// Func returns the SDK function to call.  This must alawys be of type SDKFunction,
	// but has an any type as we register many functions of different types into a
	// type-agnostic handler; this is a generic implementation detail, unfortunately.
	Func() any
}

// FunctionOpts represents the options available to configure functions.  This includes
// concurrency, retry, and flow control configuration.
//
// For more information on any of the configuration options, look at the documentation
// for each specific field's type.
type FunctionOpts struct {
	// ID is an optional function ID.  If not specified, the ID
	// will be auto-generated by lowercasing and slugging the name.
	ID string
	// Name represents a human-readable function name.
	Name string
	// Priority allows you to specify priority options for the function.
	Priority *Priority
	// Concurrency allows you to specify concurrency options.
	Concurrency []Concurrency
	// Idempotency allows you to specify a custom idempotency key - evaluated as a CEL expression
	// using the run's triggering event.
	Idempotency *string
	// Retries specifies how many times each step will retry on failure.
	Retries *int
	// Cancel allows yout o specify the events which automatically cancel this specific run, using
	// CEL expressions to conditionally evaluate new incoming events against event data.
	Cancel []Cancel
	// Debounce allows you ot configure debounce configuration for the function.
	Debounce *Debounce
	// Timeouts represents timeouts for a function.
	Timeouts *Timeouts
	// Throttle represents a soft rate limit for gating function starts.  Any function runs
	// over the throttle period will be enqueued in the backlog to run at the next available
	// time.
	Throttle *Throttle
	// RateLimit allows specifying custom rate limiting for the function.  A RateLimit is
	// hard rate limiting:  any function invocations over the rate limit will be ignored and
	// will never run.
	RateLimit *RateLimit
	// BatchEvents represents batching
	BatchEvents *EventBatchConfig

	// Singleton ensures only one active function run per key.
	Singleton *Singleton
}

func (f FunctionOpts) Validate() error {
	var err error
	if f.ID == "" {
		err = errors.Join(err, errors.New("id is required"))
	}
	return err
}

// This file copies and exports types from github.com/inngest/inngest/pkg/inngest,
// such that we don't have a bunch of unnecessary vendor imports from using this
// package.

// Triggerable represents a single or multiple triggers for a function.
type Triggerable interface {
	Triggers() []Trigger
}

type MultipleTriggers []Trigger

func (m MultipleTriggers) Triggers() []Trigger {
	return m
}

// Trigger represents either an event trigger or a cron trigger.  Only one is valid;  when
// defining a function within Cue we enforce that only an event or cron field can be specified.
type Trigger struct {
	*EventTrigger
	*CronTrigger
}

func (t Trigger) Triggers() []Trigger {
	return []Trigger{t}
}

// EventTrigger is a trigger which invokes the function each time a specific event is received.
type EventTrigger struct {
	// Event is the event name which triggers the function.
	Event string `json:"event"`

	// Expression is an optional expression which must evaluate to true for the function
	// to run.
	Expression *string `json:"expression,omitempty"`
}

// CronTrigger is a trigger which invokes the function on a CRON schedule.
type CronTrigger struct {
	Cron string `json:"cron"`
}

type Priority struct {
	Run *string `json:"run"`
}

// Concurrency represents a single concurrency limit for a function.  Concurrency limits
// the number of running steps for a given key at a time.  Other steps will be enqueued
// for the future and executed as soon as there's capacity.
//
// # Concurrency keys: virtual queues.
//
// The `Key` parameter is an optional CEL expression evaluated using the run's events.
// The output from the expression is used to create new virtual queues, which limits
// the number of runs for each virtual queue.
//
// For example, to limit the number of running steps for every account in your system,
// you can send the `account_id` in the triggering event and use the following key:
//
//	event.data.account_id
//
// Concurrency is then limited for each unique account_id field in parent events.
type Concurrency struct {
	Limit int                    `json:"limit"`
	Key   *string                `json:"key,omitempty"`
	Scope enums.ConcurrencyScope `json:"scope"`
	Hash  string                 `json:"hash"`
}

// Cancel represents a cancellation signal for a function.  When specified, this
// will set up pauses which automatically cancel the function based off of matching
// events and expressions.
type Cancel struct {
	Event   string  `json:"event"`
	Timeout *string `json:"timeout,omitempty"`
	If      *string `json:"if,omitempty"`
}

// EventBatchConfig allows you run functions with a batch of events, instead of executing
// a new run for every event received.
//
// The MaxSize option configures how many events will be collected into a batch before
// executing a new function run.
//
// The timeout option limits how long Inngest waits for a batch to fill to MaxSize before
// executing the function with a smaller batch.  This allows you to ensure functions run
// without waiting for a batch to fill indefinitely.
//
// Inngest will execute your function as soon as MaxSize is reached or the Timeout is
// reached.
type EventBatchConfig struct {
	Key *string `json:"key,omitempty"`

	// MaxSize is the maximum number of events that can be
	// included in a batch
	MaxSize int `json:"maxSize"`

	// Timeout is the maximum number of time the batch will
	// wait before being consumed.
	Timeout time.Duration `json:"timeout"`
}

func (t EventBatchConfig) MarshalJSON() ([]byte, error) {
	return encodeJSONWithDuration(t, "timeout")
}

// Debounce represents debounce configuration used when creating a new function within
// FunctionOpts
type Debounce struct {
	// Key is an optional expression to use for constraining the debounce to a given
	// value.
	Key string `json:"key,omitempty"`
	// Period is how long to listen for new events matching the optional key.  Any event
	// received during this period will reschedule the debounce to run after another period
	// interval.
	Period time.Duration `json:"period"`
	// Timeout specifies the optional max lifetime of a debounce, ensuring that functions
	// run after the given duration when a debounce is rescheduled indefinitely.
	Timeout *time.Duration `json:"timeout,omitempty"`
}

func (t Debounce) MarshalJSON() ([]byte, error) {
	return encodeJSONWithDuration(t, "timeout", "period")
}

// Throttle represents concurrency over time.  This limits the maximum number of new
// function runs over time.  Any runs over the limit are enqueued for the future.
//
// Note that this does not limit the number of steps executing at once and only limits
// how frequently runs can start.  To limit the number of steps executing at once, use
// concurrency limits.
type Throttle struct {
	// Limit is how often the function can be called within the specified period.  The
	// minimum limit is 1.
	Limit uint `json:"limit"`
	// Period represents the time period for throttling the function.  The minimum
	// granularity is 1 second.  Run starts are spaced evenly through the given period.
	Period time.Duration `json:"period"`
	// Burst is number of runs allowed to start in the given window, in a single burst,
	// before throttling applies.
	//
	// A burst > 1 bypasses smoothing for the burst and allows many runs to start
	// at once, if desired.  Defaults to 1, which disables bursting.
	Burst uint `json:"burst"`
	// Key is an optional string to constrain throttling using event data.  For
	// example, if you want to throttle incoming notifications based off of a user's
	// ID in an event you can use the following key: "event.user.id".  This ensures
	// that we throttle functions for each user independently.
	Key *string `json:"key,omitempty"`
}

// MarshalJSON marshals Throttle to the expected JSON format.  Note that time.Duration
// is marshalled as a string value.
func (t Throttle) MarshalJSON() ([]byte, error) {
	return encodeJSONWithDuration(t, "period")
}

// RateLimit rate limits a function to a maximum number of runs over a given period.
// Any runs over the limit are ignored and are NOT enqueued for the future.
type RateLimit struct {
	// Limit is how often the function can be called within the specified period
	Limit uint `json:"limit"`
	// Period represents the time period for throttling the function
	Period time.Duration `json:"period"`
	// Key is an optional string to constrain rate limiting using event data.  For
	// example, if you want to rate limit incoming notifications based off of a user's
	// ID in an event you can use the following key: "event.user.id".  This ensures
	// that we rate limit functions for each user independently.
	Key *string `json:"key,omitempty"`
}

// MarshalJSON marshals Throttle to the expected JSON format.  Note that time.Duration
// is marshalled as a string value.
func (r RateLimit) MarshalJSON() ([]byte, error) {
	return encodeJSONWithDuration(r, "period")
}

// Timeouts represents timeouts for the function. If any of the timeouts are hit, the function
// will be marked as cancelled with a cancellation reason.
type Timeouts struct {
	// Start represents the timeout for starting a function.  If the time between scheduling
	// and starting a function exceeds this value, the function will be cancelled.  Note that
	// this is inclusive of time between retries.
	//
	// A function may exceed this duration because of concurrency limits, throttling, etc.
	Start *time.Duration `json:"start,omitempty"`

	// Finish represents the time between a function starting and the function finishing.
	// If a function takes longer than this time to finish, the function is marked as cancelled.
	// The start time is taken from the time that the first successful function request begins,
	// and does not include the time spent in the queue before the function starts.
	//
	// Note that if the final request to a function begins before this timeout, and completes
	// after this timeout, the function will succeed.
	Finish *time.Duration `json:"finish,omitempty"`
}

func (t Timeouts) MarshalJSON() ([]byte, error) {
	return encodeJSONWithDuration(t, "start", "finish")
}

func encodeJSONWithDuration(input any, fields ...string) (out []byte, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("unable to encode config with duration: %v", r)
		}
	}()

	s := structs.New(input)
	s.TagName = "json"
	val := s.Map()

	for _, field := range fields {
		v, ok := val[field]
		if !ok {
			continue
		}

		switch t := v.(type) {
		case *time.Duration:
			if t != nil {
				val[field] = str2duration.String(*t)
			}
		case time.Duration:
			val[field] = str2duration.String(t)
		}
	}

	return json.Marshal(val)
}

// Singleton configures a function to run as a singleton, ensuring that only one
// instance of the function is active at a time for a given key. This is useful for
// deduplicating runs or enforcing exclusive execution.
//
// If a new run is triggered while another instance with the same key is active,
// it will either be skipped or replace the existing instance depending on the mode.
type Singleton struct {
	// Key is an optional string used to scope the singleton based on event data.
	// For example, to singleton incoming notifications per user, you could use
	// a key like "event.user.id". This ensures that only one instance of the
	// function runs at a time for each unique user.
	Key *string `json:"key,omitempty"`

	// Mode determines how to handle a new run when another singleton instance is already active.
	// Use `skip` to skip the new run, or `cancel` to stop the current instance and run the new one.
	Mode enums.SingletonMode `json:"mode"`
}

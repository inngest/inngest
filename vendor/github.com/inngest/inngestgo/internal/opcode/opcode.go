package opcode

import (
	"encoding/json"

	"github.com/inngest/inngest/pkg/enums"
	"github.com/inngest/inngestgo/internal/util"
	"github.com/inngest/inngestgo/pkg/interval"
)

// Step is a reexport of inngest/state.GeneratorOpcode
type Step struct {
	// Op represents the type of operation invoked in the function.
	Op enums.Opcode `json:"op"`
	// ID represents a hashed unique ID for the operation.  This acts
	// as the generated step ID for the state store.
	ID string `json:"id"`
	// Name represents the name of the step, or the sleep duration for
	// sleeps.
	Name string `json:"name"`
	// Opts indicate options for the operation, eg. matching expressions
	// when setting up async event listeners via `waitForEvent`, or retry
	// policies for steps.
	Opts any `json:"opts"`
	// Data is the resulting data from the operation, eg. the step
	// output. Note that for gateway requests, this is initially the
	// request input.
	Data json.RawMessage `json:"data"`
	// Error is the failing result from the operation, e.g. an error thrown
	// from a step.  This MUST be in the shape of OpcodeError.
	Error *UserError `json:"error"`
	// SDK versions < 3.?.? don't respond with the display name.
	DisplayName *string `json:"displayName"`
	// Timing represents the start and end time for the opcode, in terms of processing.
	Timing interval.Interval `json:"timing"`
	// Userland wraps user-defined ID and generated index fields.
	Userland *OpUserland `json:"userland,omitempty"`
}

type OpUserland struct {
	ID    string `json:"id"`              // User-defined ID
	Index int    `json:"index,omitempty"` // Autogenerated index for repeated IDs
}

func (g *Step) SetParallelMode(mode enums.ParallelMode) {
	if mode != enums.ParallelModeRace {
		// No need to do anything since "race" is opt-in.
		return
	}

	opts, ok := g.Opts.(map[string]any)
	if !ok {
		var err error
		opts, err = util.StructToMap(g.Opts)
		if err != nil {
			// Unreachable
			return
		}
	}
	if opts == nil {
		opts = make(map[string]any)
	}
	opts[enums.OptKeyParallelMode.String()] = mode.String()
	g.Opts = opts
}

// UserError is a reexport of inngest/state.UserError
type UserError struct {
	Name    string `json:"name"`
	Message string `json:"message"`
	Stack   string `json:"stack,omitempty"`

	// Data allows for multiple return values in eg. Golang.  If provided,
	// the SDK MAY choose to store additional data for its own purposes here.
	Data json.RawMessage `json:"data,omitempty"`

	// NoRetry is set when parsing the opcode via the retry header.
	// It is NOT set via the SDK.
	NoRetry bool `json:"noRetry,omitempty"`

	// Cause allows nested errors to be passed back to the SDK.
	Cause *UserError `json:"cause,omitempty"`
}

// HasAsyncOps is a utility that checks whether the slice of GeneratorOpcdodes
// has at least one async op.
//
// NOTE: Step errors are only async if the attempt is less than the max.
// For example, with zero retries, we can happily re-throw the step error
// to see if it's caught, then continue to the next step if so.
func HasAsyncOps(ops []Step, attempt, retries int) bool {
	for _, o := range ops {
		if enums.OpcodeIsAsync(o.Op) {
			return true
		}
	}
	return false
}

package sdkrequest

import (
	"context"
	"crypto/sha1"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log/slog"
	"slices"
	"sync"
	"time"

	"github.com/inngest/inngest/pkg/enums"
	"github.com/inngest/inngestgo/experimental"
	"github.com/inngest/inngestgo/internal/checkpoint"
	"github.com/inngest/inngestgo/internal/fn"
	"github.com/inngest/inngestgo/internal/middleware"
	"github.com/inngest/inngestgo/internal/opcode"
	"github.com/inngest/inngestgo/internal/util"
)

type ControlHijack struct{}

// GeneratorOpcode is an export of opcode.Step for backcompat.
type GeneratorOpcode = opcode.Step

// StepMode defines how steps should be executed
type StepMode int

const (
	// StepModeYield returns control to executor after each step (async functions)
	StepModeYield StepMode = iota
	// StepModeCheckpoint checkpoints each step via an API then continues execution after
	// acknowledgement of the step data.
	StepModeCheckpoint
	// StepModeManual indicates that the manager should neither return nor checkpoint the
	// ops as they happen, and that we should instead leave handling opcodes to the owner
	// of the manager.
	//
	// This is used for sync functions in REST API endpoints, as checkpointing is NOT an
	// SDKManager concern.
	StepModeManual
)

type requestCtxKeyType struct{}

var requestCtxKey = requestCtxKeyType{}

// InvocationManager is responsible for the lifecycle of a function invocation.
type InvocationManager interface {
	// Request returns the incoming executor request.
	Request() *Request
	// Err returns the error generated by step code, if a step errored.
	Err() error
	// SetErr sets the invocation's error.
	SetErr(err error)
	// AppendOp pushes a new generator op to the stack for future execution.
	AppendOp(ctx context.Context, op GeneratorOpcode)
	// Ops returns all pushed generator ops to the stack for future execution.
	// These represent new steps that have not been previously memoized.
	Ops() []GeneratorOpcode
	// Step returns step data for the given unhashed operation, if present in the
	// incoming request data.
	Step(ctx context.Context, op UnhashedOp) (json.RawMessage, bool)
	// ReplayedStep returns whether we've replayed the given hashed step ID yet.
	ReplayedStep(hashedID string) bool
	// NewOp generates a new unhashed op for creating a GeneratorOpcode.  This
	// is required for future execution of a step.
	NewOp(op enums.Opcode, id string) UnhashedOp
	// SigningKey returns the signing key used for this request.  This lets us
	// retrieve creds for eg. publishing or API alls.
	SigningKey() string
	// CallContext exposes the call context for middleware calls.
	CallContext() experimental.CallContext
	// StepMode returns how steps should be executed in this context
	StepMode() StepMode
	// SetStepMode overrides the step mode.
	SetStepMode(m StepMode)
	// SetSteps sets step data, eg. from the API call when loading state via an API call.
	SetSteps(steps map[string]json.RawMessage)
	// SetFn updates the servable function.  This is necessary because functions are discovered
	// before the first step execution in REST-based sync functions.
	SetFn(fn.ServableFunction)
}

type Opts struct {
	SigningKey         string
	SigningKeyFallback string
	// Mode represents the mode of execution, eg. sync steps, or async steps.
	Mode StepMode
	// Fn represents the function being executed, if this is an async
	// function.
	Fn fn.ServableFunction
	// Request represents the incoming SDK request.  Note that this may be
	// entirely empty for sync runs.
	Request *Request
	// Middleware represents any middleware for the execution.
	Middleware *middleware.MiddlewareManager
	// Cancel, when executed cancels the context that is passed to the
	// sync or async function.
	Cancel context.CancelFunc

	// APIBaseURL, if set, is the URL to use for the Inngest API.
	// Defaults to os.Getenv("INNGEST_DEV") if set as a URL (for development), and
	// "https://api.inngest.com" in production.
	APIBaseURL string
}

// NewManager returns an InvocationManager to manage the incoming executor request.  This
// is required for step tooling to process.
func NewManager(opts Opts) InvocationManager {
	if opts.Request == nil {
		opts.Request = &Request{}
	}
	if opts.Middleware == nil {
		opts.Middleware = middleware.New()
	}
	if opts.Cancel == nil {
		opts.Cancel = func() {}
	}

	// Normalize step
	if opts.Request.CallCtx.StepID == "step" {
		opts.Request.CallCtx.StepID = ""
	}

	unseen := util.Set[string]{}
	for k := range opts.Request.Steps {
		unseen.Add(k)
	}

	// If the step mode is StepModeYield but the function contains checkpoint config,
	// enable checkpointing.
	var checkpointConfig checkpoint.Config
	if opts.Mode == StepModeYield && opts.Fn != nil && opts.Fn.Config().Checkpoint != nil {
		opts.Mode = StepModeCheckpoint
		checkpointConfig = *opts.Fn.Config().Checkpoint
	}

	return &requestCtxManager{
		fn:         opts.Fn,
		cancel:     opts.Cancel,
		request:    opts.Request,
		indexes:    map[string]int{},
		l:          &sync.RWMutex{},
		signingKey: opts.SigningKey,
		seen:       map[string]struct{}{},
		seenLock:   &sync.RWMutex{},
		unseen:     &unseen,
		mw:         opts.Middleware,
		mode:       opts.Mode,
		t:          time.Now(),
		checkpointer: checkpoint.New(checkpoint.Opts{
			RunID:              opts.Request.CallCtx.RunID,
			FnID:               opts.Request.CallCtx.FunctionID,
			QueueItemRef:       opts.Request.CallCtx.QueueItemRef,
			SigningKey:         opts.SigningKey,
			SigningKeyFallback: opts.SigningKeyFallback,
			Config:             checkpointConfig,
			APIBaseURL:         opts.APIBaseURL,
		}),
	}
}

func SetManager(ctx context.Context, r InvocationManager) context.Context {
	return context.WithValue(ctx, requestCtxKey, r)
}

func Manager(ctx context.Context) (InvocationManager, bool) {
	mgr, ok := ctx.Value(requestCtxKey).(InvocationManager)
	return mgr, ok
}

type requestCtxManager struct {
	mode StepMode

	fn fn.ServableFunction
	// key is the signing key
	signingKey string
	// cancel ends the context and prevents any other tools from running.
	cancel func()
	// err stores the error from any step ran.
	err error
	// Ops holds a list of buffered generator opcodes to send to the executor
	// after this invocation.
	ops []GeneratorOpcode
	// request represents the incoming request.
	request *Request
	// Indexes represents a map of indexes for each unhashed op.
	indexes map[string]int
	l       *sync.RWMutex

	// seen represents all ops seen in this request, by calling Step(ctx)
	// to retrieve step data.
	seen     map[string]struct{}
	seenLock *sync.RWMutex

	unseen *util.Set[string]

	mw *middleware.MiddlewareManager

	// checkpointer stores the reference to the invocation's checkpointer,
	// allowing us to checkpoint step.runs and continue execution.,
	checkpointer checkpoint.Checkpointer

	// t returns the time since the epoch since the request started.
	t time.Time
}

func (r *requestCtxManager) SigningKey() string {
	return r.signingKey
}

func (r *requestCtxManager) SetRequest(req *Request) {
	if req.CallCtx.StepID == "step" {
		req.CallCtx.StepID = ""
	}
	r.request = req
}

func (r *requestCtxManager) Request() *Request {
	return r.request
}

func (r *requestCtxManager) SetErr(err error) {
	r.err = err
}

func (r *requestCtxManager) Err() error {
	return r.err
}

func (r *requestCtxManager) AppendOp(ctx context.Context, op GeneratorOpcode) {
	r.l.Lock()
	defer r.l.Unlock()

	if r.cancel == nil {
		r.cancel = func() {} // normalization.
	}

	// Always add the current parallelism mode to the opcode we're appending.
	op.SetParallelMode(ParallelMode(ctx))

	if r.ops == nil {
		r.ops = []GeneratorOpcode{op}
	} else {
		r.ops = append(r.ops, op)
	}

	// If we're planning multiple steps, append and continue on without any hijacking
	// in every case.  Without this, we won't continue to plan the next set of parallel
	// steps.
	if IsParallel(ctx) {
		return
	}

	// If this op is async, we need to panic and return control to the handler
	// (either the http handler or the async handler) as the executor must take
	// over from here.
	if r.isAsyncOp(op.Op) {
		r.cancel()
		panic(ControlHijack{})
	}

	// NOTE: We can never checkpoint if we have a target step to run, as we always
	// need to execute specifically - and only - that step.
	if r.request.CallCtx.StepID != "" {
		r.cancel()
		panic(ControlHijack{})
	}

	switch r.StepMode() {
	case StepModeYield:
		// Auto-cancel for async functions (StepModeYield) after appending an op,
		// then return control to the handler.
		r.cancel()
		panic(ControlHijack{})
	case StepModeCheckpoint:
		// When checkpointing, ensure that we only checkpoint step.run opcodes.
		if op.Op != enums.OpcodeStepRun {
			r.cancel()
			panic(ControlHijack{})
		}

		maxRuntime := r.fn.Config().Checkpoint.MaxRuntime
		if maxRuntime > 0 && time.Since(r.t) > maxRuntime {
			r.cancel()
			panic(ControlHijack{})
		}

		r.checkpointer.WithStep(ctx, op, func(done []opcode.Step, err error) {
			if err == nil {
				// Remove each step that's checkpointed from our buffer.  The manager's buffer
				// is used as the response data, and given these steps have already been checkpointed
				// we no longer need to send them in the SDK response.
				for _, op := range done {
					r.ops = slices.DeleteFunc(r.ops, func(f opcode.Step) bool {
						return op.ID == f.ID
					})
				}
				return
			}
			slog.Default().Error("error checkpointing state, falling back to async response", "error", err)
		})
	default:
		// Do nothing else.
	}
}

func (r *requestCtxManager) Ops() []GeneratorOpcode {
	return r.ops
}

func (r *requestCtxManager) CallContext() middleware.CallContext {
	opts := fn.FunctionOpts{}
	if r.fn != nil {
		opts = r.fn.Config()
	}

	return middleware.CallContext{
		FunctionOpts: opts,
		Env:          r.request.CallCtx.Env,
		RunID:        r.request.CallCtx.RunID,
		Attempt:      r.request.CallCtx.Attempt,
	}
}

func (r *requestCtxManager) StepMode() StepMode {
	return r.mode
}

func (r *requestCtxManager) SetStepMode(m StepMode) {
	r.mode = m
}

func (r *requestCtxManager) Step(ctx context.Context, op UnhashedOp) (json.RawMessage, bool) {
	hash := op.MustHash()
	r.l.RLock()
	defer r.l.RUnlock()

	r.unseen.Remove(hash)
	if r.unseen.Len() == 0 {
		// We exhausted all memoized steps, so we're about to run "new code"
		// after a memoized step.
		r.mw.BeforeExecution(ctx, r.CallContext())
	}

	val, ok := r.request.Steps[hash]
	if ok {
		r.seenLock.Lock()
		r.seen[hash] = struct{}{}
		r.seenLock.Unlock()
	}
	return val, ok
}

func (r *requestCtxManager) ReplayedStep(hashedID string) bool {
	r.seenLock.RLock()
	_, ok := r.seen[hashedID]
	r.seenLock.RUnlock()
	return ok
}

func (r *requestCtxManager) SetSteps(steps map[string]json.RawMessage) {
	r.l.Lock()
	defer r.l.Unlock()

	if r.request == nil {
		r.request = &Request{}
	}

	r.request.Steps = steps
}

// SetFn updates the servable function.  This is necessary because functions are discovered
// before the first step execution in REST-based sync functions.
func (r *requestCtxManager) SetFn(f fn.ServableFunction) {
	r.fn = f
}

func (r *requestCtxManager) NewOp(op enums.Opcode, id string) UnhashedOp {
	r.l.Lock()
	defer r.l.Unlock()

	n, ok := r.indexes[id]
	if ok {
		// We have an index already, so increase the counter as we're
		// adding to this key.
		n += 1
	}

	// Update indexes for each particualar key.
	r.indexes[id] = n

	return UnhashedOp{
		ID:  id,
		Op:  op,
		Pos: uint(n),
	}
}

func (r *requestCtxManager) isAsyncOp(op enums.Opcode) bool {
	if !enums.OpcodeIsAsync(op) {
		// sync opcodes are never async.
		return false
	}

	// This must be async.
	//
	// NOTE: The OpcodeStepError opcode is ONLY async if the attempt < total attempts;
	// if the step fails, we can happily continue without panicking.
	if op != enums.OpcodeStepError {
		// all other async ops are always async.
		return true
	}

	return r.request.CallCtx.Attempt < r.retries()
}

func (r *requestCtxManager) retries() int {
	if r.fn == nil {
		return 0
	}
	retries := r.fn.Config().Retries
	if retries == nil {
		return 0
	}
	return *retries
}

type UnhashedOp struct {
	Op   enums.Opcode `json:"op"`
	ID   string       `json:"id"`
	Name string       `json:"name"`
	Pos  uint         `json:"-"`
}

func (u UnhashedOp) Hash() (string, error) {
	input := u.ID
	if u.Pos > 0 {
		// We only suffix the counter if there's > 1 operation with the same ID.
		input = fmt.Sprintf("%s:%d", u.ID, u.Pos)
	}
	sum := sha1.Sum([]byte(input))
	return hex.EncodeToString(sum[:]), nil
}

func (u UnhashedOp) MustHash() string {
	h, err := u.Hash()
	if err != nil {
		panic(fmt.Errorf("error hashing op: %w", err))
	}
	return h
}

func (u UnhashedOp) Userland() *opcode.OpUserland {
	return &opcode.OpUserland{
		ID:    u.ID,
		Index: int(u.Pos),
	}
}

package sdkrequest

import (
	"context"
	"crypto/sha1"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"sync"

	"github.com/inngest/inngest/pkg/enums"
	"github.com/inngest/inngestgo/experimental"
	"github.com/inngest/inngestgo/internal/fn"
	"github.com/inngest/inngestgo/internal/middleware"
	"github.com/inngest/inngestgo/internal/types"
	"github.com/inngest/inngestgo/pkg/interval"
)

type ControlHijack struct{}

// StepMode defines how steps should be executed
type StepMode int

const (
	// StepModeYield returns control to executor after each step (async functions)
	StepModeYield StepMode = iota
	// StepModeCheckpoint checkpoints each step via an API then continues execution after
	// acknowledgement of the step data.
	StepModeCheckpoint
	// StepModeManual indicates that the manager should neither return nor checkpoint the
	// ops as they happen, and that we should instead leave handling opcodes to the owner
	// of the manager.
	StepModeManual
)

type requestCtxKeyType struct{}

var requestCtxKey = requestCtxKeyType{}

// InvocationManager is responsible for the lifecycle of a function invocation.
type InvocationManager interface {
	// Request returns the incoming executor request.
	Request() *Request
	// Err returns the error generated by step code, if a step errored.
	Err() error
	// SetErr sets the invocation's error.
	SetErr(err error)
	// AppendOp pushes a new generator op to the stack for future execution.
	AppendOp(ctx context.Context, op GeneratorOpcode)
	// Ops returns all pushed generator ops to the stack for future execution.
	// These represent new steps that have not been previously memoized.
	Ops() []GeneratorOpcode
	// Step returns step data for the given unhashed operation, if present in the
	// incoming request data.
	Step(ctx context.Context, op UnhashedOp) (json.RawMessage, bool)
	// ReplayedStep returns whether we've replayed the given hashed step ID yet.
	ReplayedStep(hashedID string) bool
	// NewOp generates a new unhashed op for creating a GeneratorOpcode.  This
	// is required for future execution of a step.
	NewOp(op enums.Opcode, id string) UnhashedOp
	// SigningKey returns the signing key used for this request.  This lets us
	// retrieve creds for eg. publishing or API alls.
	SigningKey() string
	// CallContext exposes the call context for middleware calls.
	CallContext() experimental.CallContext
	// StepMode returns how steps should be executed in this context
	StepMode() StepMode
	// SetStepMode overrides the step mode.
	SetStepMode(m StepMode)
	// SetSteps sets step data, eg. from the API call when loading state via an API call.
	SetSteps(steps map[string]json.RawMessage)
	// SetFn updates the servable function.  This is necessary because functions are discovered
	// before the first step execution in REST-based sync functions.
	SetFn(fn.ServableFunction)
}

type Opts struct {
	SigningKey string
	// Mode represents the mode of execution, eg. sync steps, or async steps.
	Mode StepMode
	// Fn represents the function being executed, if this is an async
	// function.
	Fn fn.ServableFunction
	// Request represents the incoming SDK request.  Note that this may be
	// entirely empty for sync runs.
	Request *Request
	// Middleware represents any middleware for the execution.
	Middleware *middleware.MiddlewareManager
	// Cancel, when executed cancels the context that is passed to the
	// sync or async function.
	Cancel context.CancelFunc
}

// NewManager returns an InvocationManager to manage the incoming executor request.  This
// is required for step tooling to process.
func NewManager(opts Opts) InvocationManager {
	if opts.Request == nil {
		opts.Request = &Request{}
	}
	if opts.Middleware == nil {
		opts.Middleware = middleware.New()
	}
	if opts.Cancel == nil {
		opts.Cancel = func() {}
	}

	unseen := types.Set[string]{}
	for k := range opts.Request.Steps {
		unseen.Add(k)
	}

	return &requestCtxManager{
		fn:         opts.Fn,
		cancel:     opts.Cancel,
		request:    opts.Request,
		indexes:    map[string]int{},
		l:          &sync.RWMutex{},
		signingKey: opts.SigningKey,
		seen:       map[string]struct{}{},
		seenLock:   &sync.RWMutex{},
		unseen:     &unseen,
		mw:         opts.Middleware,
		mode:       opts.Mode,
	}
}

func SetManager(ctx context.Context, r InvocationManager) context.Context {
	return context.WithValue(ctx, requestCtxKey, r)
}

func Manager(ctx context.Context) (InvocationManager, bool) {
	mgr, ok := ctx.Value(requestCtxKey).(InvocationManager)
	return mgr, ok
}

type requestCtxManager struct {
	mode StepMode

	fn fn.ServableFunction
	// key is the signing key
	signingKey string
	// cancel ends the context and prevents any other tools from running.
	cancel func()
	// err stores the error from any step ran.
	err error
	// Ops holds a list of buffered generator opcodes to send to the executor
	// after this invocation.
	ops []GeneratorOpcode
	// request represents the incoming request.
	request *Request
	// Indexes represents a map of indexes for each unhashed op.
	indexes map[string]int
	l       *sync.RWMutex

	// seen represents all ops seen in this request, by calling Step(ctx)
	// to retrieve step data.
	seen     map[string]struct{}
	seenLock *sync.RWMutex

	unseen *types.Set[string]

	mw *middleware.MiddlewareManager
}

func (r *requestCtxManager) SigningKey() string {
	return r.signingKey
}

func (r *requestCtxManager) SetRequest(req *Request) {
	r.request = req
}

func (r *requestCtxManager) Request() *Request {
	return r.request
}

func (r *requestCtxManager) SetErr(err error) {
	r.err = err
}

func (r *requestCtxManager) Err() error {
	return r.err
}

func (r *requestCtxManager) AppendOp(ctx context.Context, op GeneratorOpcode) {
	r.l.Lock()
	defer r.l.Unlock()

	// Always add the current parallelism mode to the opcode we're appending.
	op.SetParallelMode(ParallelMode(ctx))

	if r.ops == nil {
		r.ops = []GeneratorOpcode{op}
	} else {
		r.ops = append(r.ops, op)
	}

	// If we're planning multiple steps, append and continue on without any hijacking
	// in every case.  Without this, we won't continue to plan the next set of parallel
	// steps.
	if IsParallel(ctx) {
		return
	}

	// If this op is async, we need to panic and return control to the handler
	// (either the http handler or the async handler) as the executor must take
	// over from here.
	if r.isAsyncOp(op.Op) {
		if r.cancel != nil {
			r.cancel()
		}

		panic(ControlHijack{})
	}

	switch r.StepMode() {
	case StepModeYield:
		// Auto-cancel for async functions (StepModeYield) after appending an op,
		// then return control to the handler.
		r.cancel()
		panic(ControlHijack{})
	default:
		// Do nothing else.
	}
}

func (r *requestCtxManager) Ops() []GeneratorOpcode {
	return r.ops
}

func (r *requestCtxManager) CallContext() middleware.CallContext {
	opts := fn.FunctionOpts{}
	if r.fn != nil {
		opts = r.fn.Config()
	}

	return middleware.CallContext{
		FunctionOpts: opts,
		Env:          r.request.CallCtx.Env,
		RunID:        r.request.CallCtx.RunID,
		Attempt:      r.request.CallCtx.Attempt,
	}
}

func (r *requestCtxManager) StepMode() StepMode {
	return r.mode
}

func (r *requestCtxManager) SetStepMode(m StepMode) {
	r.mode = m
}

func (r *requestCtxManager) Step(ctx context.Context, op UnhashedOp) (json.RawMessage, bool) {
	hash := op.MustHash()
	r.l.RLock()
	defer r.l.RUnlock()

	r.unseen.Remove(hash)
	if r.unseen.Len() == 0 {
		// We exhausted all memoized steps, so we're about to run "new code"
		// after a memoized step.
		r.mw.BeforeExecution(ctx, r.CallContext())
	}

	val, ok := r.request.Steps[hash]
	if ok {
		r.seenLock.Lock()
		r.seen[hash] = struct{}{}
		r.seenLock.Unlock()
	}
	return val, ok
}

func (r *requestCtxManager) ReplayedStep(hashedID string) bool {
	r.seenLock.RLock()
	_, ok := r.seen[hashedID]
	r.seenLock.RUnlock()
	return ok
}

func (r *requestCtxManager) SetSteps(steps map[string]json.RawMessage) {
	r.l.Lock()
	defer r.l.Unlock()

	if r.request == nil {
		r.request = &Request{}
	}

	r.request.Steps = steps
}

// SetFn updates the servable function.  This is necessary because functions are discovered
// before the first step execution in REST-based sync functions.
func (r *requestCtxManager) SetFn(f fn.ServableFunction) {
	r.fn = f
}

func (r *requestCtxManager) NewOp(op enums.Opcode, id string) UnhashedOp {
	r.l.Lock()
	defer r.l.Unlock()

	n, ok := r.indexes[id]
	if ok {
		// We have an index already, so increase the counter as we're
		// adding to this key.
		n += 1
	}

	// Update indexes for each particualar key.
	r.indexes[id] = n

	return UnhashedOp{
		ID:  id,
		Op:  op,
		Pos: uint(n),
	}
}

func (r *requestCtxManager) isAsyncOp(op enums.Opcode) bool {
	if !enums.OpcodeIsAsync(op) {
		// sync opcodes are never async.
		return false
	}

	// This must be async.
	//
	// NOTE: The OpcodeStepError opcode is ONLY async if the attempt < total attempts;
	// if the step fails, we can happily continue without panicking.
	if op != enums.OpcodeStepError {
		// all other async ops are always async.
		return true
	}

	return r.request.CallCtx.Attempt < r.retries()
}

func (r *requestCtxManager) retries() int {
	if r.fn == nil {
		return 0
	}
	retries := r.fn.Config().Retries
	if retries == nil {
		return 0
	}
	return *retries
}

type UnhashedOp struct {
	Op   enums.Opcode `json:"op"`
	ID   string       `json:"id"`
	Name string       `json:"name"`
	Pos  uint         `json:"-"`
}

func (u UnhashedOp) Hash() (string, error) {
	input := u.ID
	if u.Pos > 0 {
		// We only suffix the counter if there's > 1 operation with the same ID.
		input = fmt.Sprintf("%s:%d", u.ID, u.Pos)
	}
	sum := sha1.Sum([]byte(input))
	return hex.EncodeToString(sum[:]), nil
}

func (u UnhashedOp) MustHash() string {
	h, err := u.Hash()
	if err != nil {
		panic(fmt.Errorf("error hashing op: %w", err))
	}
	return h
}

// GeneratorOpcode is a reexport of inngest/state.GeneratorOpcode
type GeneratorOpcode struct {
	// Op represents the type of operation invoked in the function.
	Op enums.Opcode `json:"op"`
	// ID represents a hashed unique ID for the operation.  This acts
	// as the generated step ID for the state store.
	ID string `json:"id"`
	// Name represents the name of the step, or the sleep duration for
	// sleeps.
	Name string `json:"name"`
	// Opts indicate options for the operation, eg. matching expressions
	// when setting up async event listeners via `waitForEvent`, or retry
	// policies for steps.
	Opts any `json:"opts"`
	// Data is the resulting data from the operation, eg. the step
	// output. Note that for gateway requests, this is initially the
	// request input.
	Data json.RawMessage `json:"data"`
	// Error is the failing result from the operation, e.g. an error thrown
	// from a step.  This MUST be in the shape of OpcodeError.
	Error *UserError `json:"error"`
	// SDK versions < 3.?.? don't respond with the display name.
	DisplayName *string `json:"displayName"`
	// Timing represents the start and end time for the opcode, in terms of processing.
	Timing interval.Interval `json:"timing"`
}

func (g *GeneratorOpcode) SetParallelMode(mode enums.ParallelMode) {
	if mode != enums.ParallelModeRace {
		// No need to do anything since "race" is opt-in.
		return
	}

	opts, ok := g.Opts.(map[string]any)
	if !ok {
		var err error
		opts, err = types.StructToMap(g.Opts)
		if err != nil {
			// Unreachable
			return
		}
	}
	if opts == nil {
		opts = make(map[string]any)
	}
	opts[enums.OptKeyParallelMode.String()] = mode.String()
	g.Opts = opts
}

// UserError is a reexport of inngest/state.UserError
type UserError struct {
	Name    string `json:"name"`
	Message string `json:"message"`
	Stack   string `json:"stack,omitempty"`

	// Data allows for multiple return values in eg. Golang.  If provided,
	// the SDK MAY choose to store additional data for its own purposes here.
	Data json.RawMessage `json:"data,omitempty"`

	// NoRetry is set when parsing the opcode via the retry header.
	// It is NOT set via the SDK.
	NoRetry bool `json:"noRetry,omitempty"`

	// Cause allows nested errors to be passed back to the SDK.
	Cause *UserError `json:"cause,omitempty"`
}

// HasAsyncOps is a utility that checks whether the slice of GeneratorOpcdodes
// has at least one async op.
//
// NOTE: Step errors are only async if the attempt is less than the max.
// For example, with zero retries, we can happily re-throw the step error
// to see if it's caught, then continue to the next step if so.
func HasAsyncOps(ops []GeneratorOpcode, attempt, retries int) bool {
	for _, o := range ops {
		if o.Op == enums.OpcodeStepError && attempt == retries {
			// This is not async due to the attempt being the same as the retry
			// count;  we can return the error and continue on.
			continue
		}
		if enums.OpcodeIsAsync(o.Op) {
			return true
		}
	}
	return false
}

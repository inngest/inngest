package inngestgo

import (
	"context"
	"reflect"
	"time"

	"github.com/gosimple/slug"
	"github.com/inngest/inngest/pkg/inngest"
)

type FunctionOpts struct {
	Name string
	// ID is an optional function ID.  If not specified, the ID
	// will be auto-generated by lowercasing and slugging the name.
	ID          *string
	Concurrency int
	Idempotency *string
	Retries     int
	Cancel      []inngest.Cancel

	// RateLimit allows the function to be rate limited.
	RateLimit *RateLimit

	BatchEvents *inngest.EventBatchConfig
}

// GetRateLimit returns the inngest.RateLimit for function configuration.  The
// SDK's RateLimit type is incompatible with the inngest.RateLimit type signature
// for ease of definition.
func (f FunctionOpts) GetRateLimit() *inngest.RateLimit {
	if f.RateLimit == nil {
		return nil
	}
	return f.RateLimit.Convert()
}

type RateLimit struct {
	// Limit is how often the function can be called within the specified period
	Limit uint `json:"limit"`
	// Period represents the time period for throttling the function
	Period time.Duration `json:"period"`
	// Key is an optional string to constrain throttling using event data.  For
	// example, if you want to throttle incoming notifications based off of a user's
	// ID in an event you can use the following key: "{{ event.user.id }}".  This ensures
	// that we throttle functions for each user independently.
	Key *string `json:"key,omitempty"`
}

// Convert converts a RateLimit to an inngest.RateLimit
func (r RateLimit) Convert() *inngest.RateLimit {
	return &inngest.RateLimit{
		Limit:  r.Limit,
		Period: r.Period.String(),
		Key:    r.Key,
	}
}

// CreateFunction creates a new function which can be registered within a handler.
//
// This function uses generics, allowing you to supply the event that triggers the function.
// For example, if you have a signup event defined as a struct you can use this to strongly
// type your input:
//
// 	type SignupEvent struct {
// 		Name string
// 		Data struct {
// 			Email     string
// 			AccountID string
// 		}
// 	}
//
// 	f := CreateFunction(
// 		inngestgo.FunctionOptions{Name: "Post-signup flow"},
// 		inngestgo.EventTrigger("user/signed.up"),
// 		func(ctx context.Context, input gosdk.Input[SignupEvent]) (any, error) {
// 			// .. Your logic here.  input.Event will be strongly typed as a SignupEvent.
// 			// step.Run(ctx, "Do some logic", func(ctx context.Context) (string, error) { return "hi", nil })
// 		},
// 	)
func CreateFunction[T any](
	fc FunctionOpts,
	trigger inngest.Trigger,
	f SDKFunction[T],
) ServableFunction {
	// Validate that the input type is a concrete type, and not an interface.
	//
	// The only exception is `any`, when users don't care about the input event
	// eg. for cron based functions.

	sf := servableFunc{
		fc:      fc,
		trigger: trigger,
		f:       f,
	}

	zt := sf.ZeroType()
	if zt.Interface() == nil && zt.NumMethod() > 0 {
		panic("You cannot use an interface type as the input within an Inngest function.")
	}
	return sf
}

func EventTrigger(name string) inngest.Trigger {
	return inngest.Trigger{
		EventTrigger: &inngest.EventTrigger{
			Event: name,
		},
	}
}

func CronTrigger(cron string) inngest.Trigger {
	return inngest.Trigger{
		CronTrigger: &inngest.CronTrigger{
			Cron: cron,
		},
	}
}

// SDKFunction represents a user-defined function to be called based off of events or
// on a schedule.
//
// The function is registered with the SDK by calling `CreateFunction` with the function
// name, the trigger, the event type for marshalling, and any options.
//
// This uses generics to strongly type input events:
//
// 	func(ctx context.Context, input gosdk.Input[SignupEvent]) (any, error) {
// 		// .. Your logic here.  input.Event will be strongly typed as a SignupEvent.
// 	}
type SDKFunction[T any] func(ctx context.Context, input Input[T]) (any, error)

// ServableFunction defines a function which can be called by a handler's Serve method.
//
// This is created via CreateFunction in this package.
type ServableFunction interface {
	// Slug returns the function's human-readable ID, such as "sign-up-flow".
	Slug() string

	// Name returns the function name.
	Name() string

	Config() FunctionOpts

	// Trigger returns the event name or schedule that triggers the function.
	Trigger() inngest.Trigger

	// ZeroEvent returns the zero event type to marshal the event into, given an
	// event name.
	ZeroEvent() any

	// Func returns the SDK function to call.  This must alawys be of type SDKFunction,
	// but has an any type as we register many functions of different types into a
	// type-agnostic handler; this is a generic implementation detail, unfortunately.
	Func() any
}

// Input is the input data passed to your function.  It is comprised of the triggering event
// and call context.
type Input[T any] struct {
	Event    T        `json:"event"`
	Events   []T      `json:"events"`
	InputCtx InputCtx `json:"ctx"`
}

type InputCtx struct {
	FunctionID string `json:"fn_id"`
	RunID      string `json:"run_id"`
	StepID     string `json:"step_id"`
}

type servableFunc struct {
	fc      FunctionOpts
	trigger inngest.Trigger
	f       any
}

func (s servableFunc) Config() FunctionOpts {
	return s.fc
}

func (s servableFunc) Slug() string {
	if s.fc.ID == nil {
		return slug.Make(s.fc.Name)
	}
	return *s.fc.ID
}

func (s servableFunc) Name() string {
	return s.fc.Name
}

func (s servableFunc) Trigger() inngest.Trigger {
	return s.trigger
}

func (s servableFunc) ZeroType() reflect.Value {
	// Grab the concrete type from the generic Input[T] type.  This lets us easily
	// initialize new values of this type at runtime.
	fVal := reflect.ValueOf(s.f)
	inputVal := reflect.New(fVal.Type().In(1)).Elem()
	return reflect.New(inputVal.FieldByName("Event").Type()).Elem()
}

func (s servableFunc) ZeroEvent() any {
	return s.ZeroType().Interface()
}

func (s servableFunc) Func() any {
	return s.f
}

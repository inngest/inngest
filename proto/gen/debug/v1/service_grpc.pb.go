// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: debug/v1/service.proto

package debug

import (
	context "context"
	v1 "github.com/inngest/inngest/proto/gen/constraintapi/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Debug_GetPartition_FullMethodName        = "/debug.v1.Debug/GetPartition"
	Debug_GetPartitionStatus_FullMethodName  = "/debug.v1.Debug/GetPartitionStatus"
	Debug_GetQueueItem_FullMethodName        = "/debug.v1.Debug/GetQueueItem"
	Debug_GetPause_FullMethodName            = "/debug.v1.Debug/GetPause"
	Debug_GetIndex_FullMethodName            = "/debug.v1.Debug/GetIndex"
	Debug_BlockPeek_FullMethodName           = "/debug.v1.Debug/BlockPeek"
	Debug_BlockDeleted_FullMethodName        = "/debug.v1.Debug/BlockDeleted"
	Debug_CheckConstraints_FullMethodName    = "/debug.v1.Debug/CheckConstraints"
	Debug_GetBatchInfo_FullMethodName        = "/debug.v1.Debug/GetBatchInfo"
	Debug_DeleteBatch_FullMethodName         = "/debug.v1.Debug/DeleteBatch"
	Debug_RunBatch_FullMethodName            = "/debug.v1.Debug/RunBatch"
	Debug_GetSingletonInfo_FullMethodName    = "/debug.v1.Debug/GetSingletonInfo"
	Debug_DeleteSingletonLock_FullMethodName = "/debug.v1.Debug/DeleteSingletonLock"
	Debug_GetDebounceInfo_FullMethodName     = "/debug.v1.Debug/GetDebounceInfo"
	Debug_DeleteDebounce_FullMethodName      = "/debug.v1.Debug/DeleteDebounce"
	Debug_RunDebounce_FullMethodName         = "/debug.v1.Debug/RunDebounce"
	Debug_DeleteDebounceByID_FullMethodName  = "/debug.v1.Debug/DeleteDebounceByID"
	Debug_GetShadowPartition_FullMethodName  = "/debug.v1.Debug/GetShadowPartition"
	Debug_GetBacklogs_FullMethodName         = "/debug.v1.Debug/GetBacklogs"
	Debug_GetBacklogSize_FullMethodName      = "/debug.v1.Debug/GetBacklogSize"
)

// DebugClient is the client API for Debug service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DebugClient interface {
	// GetPartition retrieves the partition data from the database
	GetPartition(ctx context.Context, in *PartitionRequest, opts ...grpc.CallOption) (*PartitionResponse, error)
	// GetPartition retrieves additional status of the partition from the queue
	// directly
	GetPartitionStatus(ctx context.Context, in *PartitionRequest, opts ...grpc.CallOption) (*PartitionStatusResponse, error)
	// GetQueueItem retrieves the queue item object from the queue
	GetQueueItem(ctx context.Context, in *QueueItemRequest, opts ...grpc.CallOption) (*QueueItemResponse, error)
	// GetPause retrieves a single pause item.
	GetPause(ctx context.Context, in *PauseRequest, opts ...grpc.CallOption) (*PauseResponse, error)
	// GetIndex retrieves block information for a pause index.
	GetIndex(ctx context.Context, in *IndexRequest, opts ...grpc.CallOption) (*IndexResponse, error)
	// BlockPeek retrieves pause IDs from a specific block.
	BlockPeek(ctx context.Context, in *BlockPeekRequest, opts ...grpc.CallOption) (*BlockPeekResponse, error)
	// BlockDeleted retrieves deleted pause IDs from a specific block.
	BlockDeleted(ctx context.Context, in *BlockDeletedRequest, opts ...grpc.CallOption) (*BlockDeletedResponse, error)
	// CheckConstraints invokes Check() on the configured capacity manager
	CheckConstraints(ctx context.Context, in *v1.CapacityCheckRequest, opts ...grpc.CallOption) (*CheckConstraintsResponse, error)
	// GetBatchInfo retrieves information about the current batch for a function and batch key.
	GetBatchInfo(ctx context.Context, in *BatchInfoRequest, opts ...grpc.CallOption) (*BatchInfoResponse, error)
	// DeleteBatch deletes a batch for a function and batch key.
	DeleteBatch(ctx context.Context, in *DeleteBatchRequest, opts ...grpc.CallOption) (*DeleteBatchResponse, error)
	// RunBatch triggers immediate execution of a batch.
	RunBatch(ctx context.Context, in *RunBatchRequest, opts ...grpc.CallOption) (*RunBatchResponse, error)
	// GetSingletonInfo retrieves the current singleton lock status for a given key.
	GetSingletonInfo(ctx context.Context, in *SingletonInfoRequest, opts ...grpc.CallOption) (*SingletonInfoResponse, error)
	// DeleteSingletonLock removes an existing singleton lock.
	DeleteSingletonLock(ctx context.Context, in *DeleteSingletonLockRequest, opts ...grpc.CallOption) (*DeleteSingletonLockResponse, error)
	// GetDebounceInfo retrieves the currently debounced event for a function and debounce key.
	GetDebounceInfo(ctx context.Context, in *DebounceInfoRequest, opts ...grpc.CallOption) (*DebounceInfoResponse, error)
	// DeleteDebounce deletes a debounce for a function and debounce key.
	DeleteDebounce(ctx context.Context, in *DeleteDebounceRequest, opts ...grpc.CallOption) (*DeleteDebounceResponse, error)
	// RunDebounce triggers immediate execution of a debounce.
	RunDebounce(ctx context.Context, in *RunDebounceRequest, opts ...grpc.CallOption) (*RunDebounceResponse, error)
	// DeleteDebounceByID deletes debounces directly by their IDs, without requiring function_id or debounce_key.
	DeleteDebounceByID(ctx context.Context, in *DeleteDebounceByIDRequest, opts ...grpc.CallOption) (*DeleteDebounceByIDResponse, error)
	// GetShadowPartition retrieves shadow partition details for a given partition ID
	GetShadowPartition(ctx context.Context, in *ShadowPartitionRequest, opts ...grpc.CallOption) (*ShadowPartitionResponse, error)
	// GetBacklogs retrieves the list of backlogs for a partition
	GetBacklogs(ctx context.Context, in *BacklogsRequest, opts ...grpc.CallOption) (*BacklogsResponse, error)
	// GetBacklogSize retrieves the number of items in a specific backlog
	GetBacklogSize(ctx context.Context, in *BacklogSizeRequest, opts ...grpc.CallOption) (*BacklogSizeResponse, error)
}

type debugClient struct {
	cc grpc.ClientConnInterface
}

func NewDebugClient(cc grpc.ClientConnInterface) DebugClient {
	return &debugClient{cc}
}

func (c *debugClient) GetPartition(ctx context.Context, in *PartitionRequest, opts ...grpc.CallOption) (*PartitionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PartitionResponse)
	err := c.cc.Invoke(ctx, Debug_GetPartition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetPartitionStatus(ctx context.Context, in *PartitionRequest, opts ...grpc.CallOption) (*PartitionStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PartitionStatusResponse)
	err := c.cc.Invoke(ctx, Debug_GetPartitionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetQueueItem(ctx context.Context, in *QueueItemRequest, opts ...grpc.CallOption) (*QueueItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueueItemResponse)
	err := c.cc.Invoke(ctx, Debug_GetQueueItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetPause(ctx context.Context, in *PauseRequest, opts ...grpc.CallOption) (*PauseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PauseResponse)
	err := c.cc.Invoke(ctx, Debug_GetPause_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetIndex(ctx context.Context, in *IndexRequest, opts ...grpc.CallOption) (*IndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IndexResponse)
	err := c.cc.Invoke(ctx, Debug_GetIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) BlockPeek(ctx context.Context, in *BlockPeekRequest, opts ...grpc.CallOption) (*BlockPeekResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockPeekResponse)
	err := c.cc.Invoke(ctx, Debug_BlockPeek_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) BlockDeleted(ctx context.Context, in *BlockDeletedRequest, opts ...grpc.CallOption) (*BlockDeletedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockDeletedResponse)
	err := c.cc.Invoke(ctx, Debug_BlockDeleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) CheckConstraints(ctx context.Context, in *v1.CapacityCheckRequest, opts ...grpc.CallOption) (*CheckConstraintsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckConstraintsResponse)
	err := c.cc.Invoke(ctx, Debug_CheckConstraints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetBatchInfo(ctx context.Context, in *BatchInfoRequest, opts ...grpc.CallOption) (*BatchInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchInfoResponse)
	err := c.cc.Invoke(ctx, Debug_GetBatchInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) DeleteBatch(ctx context.Context, in *DeleteBatchRequest, opts ...grpc.CallOption) (*DeleteBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteBatchResponse)
	err := c.cc.Invoke(ctx, Debug_DeleteBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) RunBatch(ctx context.Context, in *RunBatchRequest, opts ...grpc.CallOption) (*RunBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunBatchResponse)
	err := c.cc.Invoke(ctx, Debug_RunBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetSingletonInfo(ctx context.Context, in *SingletonInfoRequest, opts ...grpc.CallOption) (*SingletonInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SingletonInfoResponse)
	err := c.cc.Invoke(ctx, Debug_GetSingletonInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) DeleteSingletonLock(ctx context.Context, in *DeleteSingletonLockRequest, opts ...grpc.CallOption) (*DeleteSingletonLockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSingletonLockResponse)
	err := c.cc.Invoke(ctx, Debug_DeleteSingletonLock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetDebounceInfo(ctx context.Context, in *DebounceInfoRequest, opts ...grpc.CallOption) (*DebounceInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DebounceInfoResponse)
	err := c.cc.Invoke(ctx, Debug_GetDebounceInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) DeleteDebounce(ctx context.Context, in *DeleteDebounceRequest, opts ...grpc.CallOption) (*DeleteDebounceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDebounceResponse)
	err := c.cc.Invoke(ctx, Debug_DeleteDebounce_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) RunDebounce(ctx context.Context, in *RunDebounceRequest, opts ...grpc.CallOption) (*RunDebounceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunDebounceResponse)
	err := c.cc.Invoke(ctx, Debug_RunDebounce_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) DeleteDebounceByID(ctx context.Context, in *DeleteDebounceByIDRequest, opts ...grpc.CallOption) (*DeleteDebounceByIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDebounceByIDResponse)
	err := c.cc.Invoke(ctx, Debug_DeleteDebounceByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetShadowPartition(ctx context.Context, in *ShadowPartitionRequest, opts ...grpc.CallOption) (*ShadowPartitionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShadowPartitionResponse)
	err := c.cc.Invoke(ctx, Debug_GetShadowPartition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetBacklogs(ctx context.Context, in *BacklogsRequest, opts ...grpc.CallOption) (*BacklogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BacklogsResponse)
	err := c.cc.Invoke(ctx, Debug_GetBacklogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetBacklogSize(ctx context.Context, in *BacklogSizeRequest, opts ...grpc.CallOption) (*BacklogSizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BacklogSizeResponse)
	err := c.cc.Invoke(ctx, Debug_GetBacklogSize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DebugServer is the server API for Debug service.
// All implementations must embed UnimplementedDebugServer
// for forward compatibility.
type DebugServer interface {
	// GetPartition retrieves the partition data from the database
	GetPartition(context.Context, *PartitionRequest) (*PartitionResponse, error)
	// GetPartition retrieves additional status of the partition from the queue
	// directly
	GetPartitionStatus(context.Context, *PartitionRequest) (*PartitionStatusResponse, error)
	// GetQueueItem retrieves the queue item object from the queue
	GetQueueItem(context.Context, *QueueItemRequest) (*QueueItemResponse, error)
	// GetPause retrieves a single pause item.
	GetPause(context.Context, *PauseRequest) (*PauseResponse, error)
	// GetIndex retrieves block information for a pause index.
	GetIndex(context.Context, *IndexRequest) (*IndexResponse, error)
	// BlockPeek retrieves pause IDs from a specific block.
	BlockPeek(context.Context, *BlockPeekRequest) (*BlockPeekResponse, error)
	// BlockDeleted retrieves deleted pause IDs from a specific block.
	BlockDeleted(context.Context, *BlockDeletedRequest) (*BlockDeletedResponse, error)
	// CheckConstraints invokes Check() on the configured capacity manager
	CheckConstraints(context.Context, *v1.CapacityCheckRequest) (*CheckConstraintsResponse, error)
	// GetBatchInfo retrieves information about the current batch for a function and batch key.
	GetBatchInfo(context.Context, *BatchInfoRequest) (*BatchInfoResponse, error)
	// DeleteBatch deletes a batch for a function and batch key.
	DeleteBatch(context.Context, *DeleteBatchRequest) (*DeleteBatchResponse, error)
	// RunBatch triggers immediate execution of a batch.
	RunBatch(context.Context, *RunBatchRequest) (*RunBatchResponse, error)
	// GetSingletonInfo retrieves the current singleton lock status for a given key.
	GetSingletonInfo(context.Context, *SingletonInfoRequest) (*SingletonInfoResponse, error)
	// DeleteSingletonLock removes an existing singleton lock.
	DeleteSingletonLock(context.Context, *DeleteSingletonLockRequest) (*DeleteSingletonLockResponse, error)
	// GetDebounceInfo retrieves the currently debounced event for a function and debounce key.
	GetDebounceInfo(context.Context, *DebounceInfoRequest) (*DebounceInfoResponse, error)
	// DeleteDebounce deletes a debounce for a function and debounce key.
	DeleteDebounce(context.Context, *DeleteDebounceRequest) (*DeleteDebounceResponse, error)
	// RunDebounce triggers immediate execution of a debounce.
	RunDebounce(context.Context, *RunDebounceRequest) (*RunDebounceResponse, error)
	// DeleteDebounceByID deletes debounces directly by their IDs, without requiring function_id or debounce_key.
	DeleteDebounceByID(context.Context, *DeleteDebounceByIDRequest) (*DeleteDebounceByIDResponse, error)
	// GetShadowPartition retrieves shadow partition details for a given partition ID
	GetShadowPartition(context.Context, *ShadowPartitionRequest) (*ShadowPartitionResponse, error)
	// GetBacklogs retrieves the list of backlogs for a partition
	GetBacklogs(context.Context, *BacklogsRequest) (*BacklogsResponse, error)
	// GetBacklogSize retrieves the number of items in a specific backlog
	GetBacklogSize(context.Context, *BacklogSizeRequest) (*BacklogSizeResponse, error)
	mustEmbedUnimplementedDebugServer()
}

// UnimplementedDebugServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDebugServer struct{}

func (UnimplementedDebugServer) GetPartition(context.Context, *PartitionRequest) (*PartitionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPartition not implemented")
}
func (UnimplementedDebugServer) GetPartitionStatus(context.Context, *PartitionRequest) (*PartitionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPartitionStatus not implemented")
}
func (UnimplementedDebugServer) GetQueueItem(context.Context, *QueueItemRequest) (*QueueItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueueItem not implemented")
}
func (UnimplementedDebugServer) GetPause(context.Context, *PauseRequest) (*PauseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPause not implemented")
}
func (UnimplementedDebugServer) GetIndex(context.Context, *IndexRequest) (*IndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndex not implemented")
}
func (UnimplementedDebugServer) BlockPeek(context.Context, *BlockPeekRequest) (*BlockPeekResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockPeek not implemented")
}
func (UnimplementedDebugServer) BlockDeleted(context.Context, *BlockDeletedRequest) (*BlockDeletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockDeleted not implemented")
}
func (UnimplementedDebugServer) CheckConstraints(context.Context, *v1.CapacityCheckRequest) (*CheckConstraintsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckConstraints not implemented")
}
func (UnimplementedDebugServer) GetBatchInfo(context.Context, *BatchInfoRequest) (*BatchInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBatchInfo not implemented")
}
func (UnimplementedDebugServer) DeleteBatch(context.Context, *DeleteBatchRequest) (*DeleteBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBatch not implemented")
}
func (UnimplementedDebugServer) RunBatch(context.Context, *RunBatchRequest) (*RunBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunBatch not implemented")
}
func (UnimplementedDebugServer) GetSingletonInfo(context.Context, *SingletonInfoRequest) (*SingletonInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSingletonInfo not implemented")
}
func (UnimplementedDebugServer) DeleteSingletonLock(context.Context, *DeleteSingletonLockRequest) (*DeleteSingletonLockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSingletonLock not implemented")
}
func (UnimplementedDebugServer) GetDebounceInfo(context.Context, *DebounceInfoRequest) (*DebounceInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDebounceInfo not implemented")
}
func (UnimplementedDebugServer) DeleteDebounce(context.Context, *DeleteDebounceRequest) (*DeleteDebounceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDebounce not implemented")
}
func (UnimplementedDebugServer) RunDebounce(context.Context, *RunDebounceRequest) (*RunDebounceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunDebounce not implemented")
}
func (UnimplementedDebugServer) DeleteDebounceByID(context.Context, *DeleteDebounceByIDRequest) (*DeleteDebounceByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDebounceByID not implemented")
}
func (UnimplementedDebugServer) GetShadowPartition(context.Context, *ShadowPartitionRequest) (*ShadowPartitionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShadowPartition not implemented")
}
func (UnimplementedDebugServer) GetBacklogs(context.Context, *BacklogsRequest) (*BacklogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBacklogs not implemented")
}
func (UnimplementedDebugServer) GetBacklogSize(context.Context, *BacklogSizeRequest) (*BacklogSizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBacklogSize not implemented")
}
func (UnimplementedDebugServer) mustEmbedUnimplementedDebugServer() {}
func (UnimplementedDebugServer) testEmbeddedByValue()               {}

// UnsafeDebugServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DebugServer will
// result in compilation errors.
type UnsafeDebugServer interface {
	mustEmbedUnimplementedDebugServer()
}

func RegisterDebugServer(s grpc.ServiceRegistrar, srv DebugServer) {
	// If the following call pancis, it indicates UnimplementedDebugServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Debug_ServiceDesc, srv)
}

func _Debug_GetPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetPartition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetPartition(ctx, req.(*PartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetPartitionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetPartitionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetPartitionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetPartitionStatus(ctx, req.(*PartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetQueueItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetQueueItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetQueueItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetQueueItem(ctx, req.(*QueueItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetPause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetPause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetPause_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetPause(ctx, req.(*PauseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetIndex(ctx, req.(*IndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_BlockPeek_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockPeekRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).BlockPeek(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_BlockPeek_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).BlockPeek(ctx, req.(*BlockPeekRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_BlockDeleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockDeletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).BlockDeleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_BlockDeleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).BlockDeleted(ctx, req.(*BlockDeletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_CheckConstraints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.CapacityCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).CheckConstraints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_CheckConstraints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).CheckConstraints(ctx, req.(*v1.CapacityCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetBatchInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetBatchInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetBatchInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetBatchInfo(ctx, req.(*BatchInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_DeleteBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).DeleteBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_DeleteBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).DeleteBatch(ctx, req.(*DeleteBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_RunBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).RunBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_RunBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).RunBatch(ctx, req.(*RunBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetSingletonInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SingletonInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetSingletonInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetSingletonInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetSingletonInfo(ctx, req.(*SingletonInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_DeleteSingletonLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSingletonLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).DeleteSingletonLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_DeleteSingletonLock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).DeleteSingletonLock(ctx, req.(*DeleteSingletonLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetDebounceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebounceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetDebounceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetDebounceInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetDebounceInfo(ctx, req.(*DebounceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_DeleteDebounce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDebounceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).DeleteDebounce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_DeleteDebounce_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).DeleteDebounce(ctx, req.(*DeleteDebounceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_RunDebounce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunDebounceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).RunDebounce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_RunDebounce_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).RunDebounce(ctx, req.(*RunDebounceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_DeleteDebounceByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDebounceByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).DeleteDebounceByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_DeleteDebounceByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).DeleteDebounceByID(ctx, req.(*DeleteDebounceByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetShadowPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShadowPartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetShadowPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetShadowPartition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetShadowPartition(ctx, req.(*ShadowPartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetBacklogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BacklogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetBacklogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetBacklogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetBacklogs(ctx, req.(*BacklogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetBacklogSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BacklogSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetBacklogSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetBacklogSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetBacklogSize(ctx, req.(*BacklogSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Debug_ServiceDesc is the grpc.ServiceDesc for Debug service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Debug_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "debug.v1.Debug",
	HandlerType: (*DebugServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPartition",
			Handler:    _Debug_GetPartition_Handler,
		},
		{
			MethodName: "GetPartitionStatus",
			Handler:    _Debug_GetPartitionStatus_Handler,
		},
		{
			MethodName: "GetQueueItem",
			Handler:    _Debug_GetQueueItem_Handler,
		},
		{
			MethodName: "GetPause",
			Handler:    _Debug_GetPause_Handler,
		},
		{
			MethodName: "GetIndex",
			Handler:    _Debug_GetIndex_Handler,
		},
		{
			MethodName: "BlockPeek",
			Handler:    _Debug_BlockPeek_Handler,
		},
		{
			MethodName: "BlockDeleted",
			Handler:    _Debug_BlockDeleted_Handler,
		},
		{
			MethodName: "CheckConstraints",
			Handler:    _Debug_CheckConstraints_Handler,
		},
		{
			MethodName: "GetBatchInfo",
			Handler:    _Debug_GetBatchInfo_Handler,
		},
		{
			MethodName: "DeleteBatch",
			Handler:    _Debug_DeleteBatch_Handler,
		},
		{
			MethodName: "RunBatch",
			Handler:    _Debug_RunBatch_Handler,
		},
		{
			MethodName: "GetSingletonInfo",
			Handler:    _Debug_GetSingletonInfo_Handler,
		},
		{
			MethodName: "DeleteSingletonLock",
			Handler:    _Debug_DeleteSingletonLock_Handler,
		},
		{
			MethodName: "GetDebounceInfo",
			Handler:    _Debug_GetDebounceInfo_Handler,
		},
		{
			MethodName: "DeleteDebounce",
			Handler:    _Debug_DeleteDebounce_Handler,
		},
		{
			MethodName: "RunDebounce",
			Handler:    _Debug_RunDebounce_Handler,
		},
		{
			MethodName: "DeleteDebounceByID",
			Handler:    _Debug_DeleteDebounceByID_Handler,
		},
		{
			MethodName: "GetShadowPartition",
			Handler:    _Debug_GetShadowPartition_Handler,
		},
		{
			MethodName: "GetBacklogs",
			Handler:    _Debug_GetBacklogs_Handler,
		},
		{
			MethodName: "GetBacklogSize",
			Handler:    _Debug_GetBacklogSize_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "debug/v1/service.proto",
}

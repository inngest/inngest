// Command tygo-collect scans Go packages for types annotated with //tygo:generate
// and collects them into a single barrel file for TypeScript generation via tygo.
//
// Usage:
//
//	tygo-collect -o output.go pkg1 pkg2 ...
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

const annotation = "//tygo:generate"

func main() {
	output := flag.String("o", "", "output file path (required)")
	flag.Parse()

	if *output == "" {
		fmt.Fprintln(os.Stderr, "error: -o output file is required")
		os.Exit(1)
	}

	packages := flag.Args()
	if len(packages) == 0 {
		fmt.Fprintln(os.Stderr, "error: at least one package path is required")
		os.Exit(1)
	}

	collected, err := collectAnnotatedTypes(packages)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}

	if err := writeBarrelFile(*output, collected); err != nil {
		fmt.Fprintf(os.Stderr, "error writing output: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d type(s)\n", *output, len(collected))
}

type collectedType struct {
	Name       string
	Source     string
	SourceFile string
	IsConst    bool
}

func collectAnnotatedTypes(packages []string) ([]collectedType, error) {
	var collected []collectedType

	for _, pkgPath := range packages {
		types, err := scanPackage(pkgPath)
		if err != nil {
			return nil, fmt.Errorf("scanning %s: %w", pkgPath, err)
		}
		collected = append(collected, types...)
	}

	return collected, nil
}

func scanPackage(pkgPath string) ([]collectedType, error) {
	fset := token.NewFileSet()

	// Parse all Go files in the package directory
	pkgs, err := parser.ParseDir(fset, pkgPath, func(fi os.FileInfo) bool {
		return !strings.HasSuffix(fi.Name(), "_test.go")
	}, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("parsing package: %w", err)
	}

	var collected []collectedType

	for _, pkg := range pkgs {
		for filename, file := range pkg.Files {
			types, err := scanFile(fset, filename, file)
			if err != nil {
				return nil, fmt.Errorf("scanning %s: %w", filename, err)
			}
			collected = append(collected, types...)
		}
	}

	return collected, nil
}

func scanFile(fset *token.FileSet, filename string, file *ast.File) ([]collectedType, error) {
	var collected []collectedType

	// Build a map of comment positions to their text
	commentMap := make(map[int]string)
	for _, cg := range file.Comments {
		for _, c := range cg.List {
			line := fset.Position(c.Pos()).Line
			commentMap[line] = c.Text
		}
	}

	for _, decl := range file.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			// Check if the declaration has our annotation
			declLine := fset.Position(d.Pos()).Line
			if !hasAnnotation(commentMap, declLine) {
				continue
			}

			for _, spec := range d.Specs {
				switch s := spec.(type) {
				case *ast.TypeSpec:
					source, err := nodeToString(fset, d, false)
					if err != nil {
						return nil, err
					}
					collected = append(collected, collectedType{
						Name:       s.Name.Name,
						Source:     source,
						SourceFile: filepath.Base(filename),
						IsConst:    false,
					})

				case *ast.ValueSpec:
					if d.Tok == token.CONST {
						source, err := nodeToString(fset, d, true)
						if err != nil {
							return nil, err
						}
						// Use first name for identification
						name := ""
						if len(s.Names) > 0 {
							name = s.Names[0].Name
						}
						collected = append(collected, collectedType{
							Name:       name,
							Source:     source,
							SourceFile: filepath.Base(filename),
							IsConst:    true,
						})
					}
				}
			}
		}
	}

	return collected, nil
}

func hasAnnotation(commentMap map[int]string, declLine int) bool {
	// Check the line immediately before the declaration
	if comment, ok := commentMap[declLine-1]; ok {
		if strings.HasPrefix(strings.TrimSpace(comment), annotation) {
			return true
		}
	}
	return false
}

func nodeToString(fset *token.FileSet, node ast.Node, isConst bool) (string, error) {
	// For const declarations, remove type annotations so the barrel file compiles
	// (the original types like metadata.Kind aren't imported)
	if isConst {
		if genDecl, ok := node.(*ast.GenDecl); ok {
			for _, spec := range genDecl.Specs {
				if vs, ok := spec.(*ast.ValueSpec); ok {
					vs.Type = nil // Remove type annotation
				}
			}
		}
	}

	var buf bytes.Buffer
	if err := printer.Fprint(&buf, fset, node); err != nil {
		return "", err
	}

	// Strip the //tygo:generate annotation from output
	source := buf.String()
	source = strings.ReplaceAll(source, annotation+"\n", "")
	source = strings.ReplaceAll(source, annotation, "")

	return source, nil
}

func writeBarrelFile(output string, collected []collectedType) error {
	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(output), 0755); err != nil {
		return err
	}

	var buf bytes.Buffer

	buf.WriteString("// Code generated by tygo-collect. DO NOT EDIT.\n")
	buf.WriteString("// This file collects types from multiple packages for TypeScript generation.\n\n")
	buf.WriteString("package types\n\n")

	for _, t := range collected {
		buf.WriteString(fmt.Sprintf("// From %s\n", t.SourceFile))
		buf.WriteString(t.Source)
		buf.WriteString("\n\n")
	}

	return os.WriteFile(output, buf.Bytes(), 0644)
}

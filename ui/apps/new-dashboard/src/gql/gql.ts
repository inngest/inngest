/* eslint-disable */
import * as types from './graphql';
import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
    "\n  mutation AchiveApp($appID: UUID!) {\n    archiveApp(id: $appID) {\n      id\n    }\n  }\n": typeof types.AchiveAppDocument,
    "\n  mutation UnachiveApp($appID: UUID!) {\n    unarchiveApp(id: $appID) {\n      id\n    }\n  }\n": typeof types.UnachiveAppDocument,
    "\n  mutation ResyncApp($appExternalID: String!, $appURL: String, $envID: UUID!) {\n    resyncApp(appExternalID: $appExternalID, appURL: $appURL, envID: $envID) {\n      app {\n        id\n      }\n      error {\n        code\n        data\n        message\n      }\n    }\n  }\n": typeof types.ResyncAppDocument,
    "\n  query CheckApp($envID: ID!, $url: String!) {\n    env: workspace(id: $envID) {\n      appCheck(url: $url) {\n        apiOrigin {\n          value\n        }\n        appID {\n          value\n        }\n        authenticationSucceeded {\n          value\n        }\n        env {\n          value\n        }\n        error\n        eventAPIOrigin {\n          value\n        }\n        eventKeyStatus\n        extra\n        framework {\n          value\n        }\n        isReachable\n        isSDK\n        mode\n        respHeaders\n        respStatusCode\n        sdkLanguage {\n          value\n        }\n        sdkVersion {\n          value\n        }\n        serveOrigin {\n          value\n        }\n        servePath {\n          value\n        }\n        signingKeyStatus\n        signingKeyFallbackStatus\n      }\n    }\n  }\n": typeof types.CheckAppDocument,
    "\n  query Apps($envID: ID!, $filter: AppsFilter!) {\n    environment: workspace(id: $envID) {\n      apps(filter: $filter) {\n        id\n        externalID\n        functionCount\n        isArchived\n        name\n        method\n        isParentArchived\n        latestSync {\n          error\n          framework\n          id\n          lastSyncedAt\n          platform\n          sdkLanguage\n          sdkVersion\n          status\n          url\n        }\n        functions {\n          id\n          name\n          slug\n          triggers {\n            type\n            value\n          }\n        }\n      }\n    }\n  }\n": typeof types.AppsDocument,
    "\n  query LatestUnattachedSync($envID: ID!) {\n    environment: workspace(id: $envID) {\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n      }\n    }\n  }\n": typeof types.LatestUnattachedSyncDocument,
    "\n  mutation DisableEnvironmentAutoArchiveDocument($id: ID!) {\n    disableEnvironmentAutoArchive(id: $id) {\n      id\n    }\n  }\n": typeof types.DisableEnvironmentAutoArchiveDocumentDocument,
    "\n  mutation EnableEnvironmentAutoArchive($id: ID!) {\n    enableEnvironmentAutoArchive(id: $id) {\n      id\n    }\n  }\n": typeof types.EnableEnvironmentAutoArchiveDocument,
    "\n  mutation ArchiveEnvironment($id: ID!) {\n    archiveEnvironment(id: $id) {\n      id\n    }\n  }\n": typeof types.ArchiveEnvironmentDocument,
    "\n  mutation UnarchiveEnvironment($id: ID!) {\n    unarchiveEnvironment(id: $id) {\n      id\n    }\n  }\n": typeof types.UnarchiveEnvironmentDocument,
    "\n  query GetEventTypesV2(\n    $envID: ID!\n    $cursor: String\n    $archived: Boolean\n    $nameSearch: String\n  ) {\n    environment: workspace(id: $envID) {\n      eventTypesV2(\n        after: $cursor\n        first: 40\n        filter: { archived: $archived, nameSearch: $nameSearch }\n      ) {\n        edges {\n          node {\n            name\n            functions {\n              edges {\n                node {\n                  id\n                  slug\n                  name\n                }\n              }\n            }\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n          hasPreviousPage\n          startCursor\n        }\n      }\n    }\n  }\n": typeof types.GetEventTypesV2Document,
    "\n  query GetEventTypeVolumeV2(\n    $envID: ID!\n    $eventName: String!\n    $startTime: Time!\n    $endTime: Time!\n  ) {\n    environment: workspace(id: $envID) {\n      eventType(name: $eventName) {\n        name\n        usage(opts: { period: hour, from: $startTime, to: $endTime }) {\n          total\n          data {\n            count\n            slot\n          }\n        }\n      }\n    }\n  }\n": typeof types.GetEventTypeVolumeV2Document,
    "\n  query GetEventType($envID: ID!, $eventName: String!) {\n    environment: workspace(id: $envID) {\n      eventType(name: $eventName) {\n        name\n        functions {\n          edges {\n            node {\n              id\n              slug\n              name\n            }\n          }\n        }\n      }\n    }\n  }\n": typeof types.GetEventTypeDocument,
    "\n  query GetAllEventNames($envID: ID!) {\n    environment: workspace(id: $envID) {\n      eventTypesV2(first: 40, filter: {}) {\n        edges {\n          node {\n            name\n          }\n        }\n      }\n    }\n  }\n": typeof types.GetAllEventNamesDocument,
    "\n  mutation ArchiveEvent($environmentId: ID!, $name: String!) {\n    archiveEvent(workspaceID: $environmentId, name: $name) {\n      name\n    }\n  }\n": typeof types.ArchiveEventDocument,
    "\n  query GetLatestEventLogs($name: String, $environmentID: ID!) {\n    events(query: { name: $name, workspaceID: $environmentID }) {\n      data {\n        recent(count: 5) {\n          id\n          receivedAt\n          event\n          source {\n            name\n          }\n        }\n      }\n    }\n  }\n": typeof types.GetLatestEventLogsDocument,
    "\n  query GetEventKeys($environmentID: ID!) {\n    environment: workspace(id: $environmentID) {\n      eventKeys: ingestKeys {\n        name\n        value: presharedKey\n      }\n    }\n  }\n": typeof types.GetEventKeysDocument,
    "\n  query GetEventsV2(\n    $envID: ID!\n    $cursor: String\n    $startTime: Time!\n    $endTime: Time\n    $celQuery: String = null\n    $eventNames: [String!] = null\n    $includeInternalEvents: Boolean = false\n  ) {\n    environment: workspace(id: $envID) {\n      eventsV2(\n        first: 50\n        after: $cursor\n        filter: {\n          from: $startTime\n          until: $endTime\n          query: $celQuery\n          eventNames: $eventNames\n          includeInternalEvents: $includeInternalEvents\n        }\n      ) {\n        edges {\n          node {\n            name\n            id\n            receivedAt\n            runs {\n              status\n              id\n              startedAt\n              endedAt\n              function {\n                name\n                slug\n              }\n            }\n          }\n        }\n        totalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n          hasPreviousPage\n          startCursor\n        }\n      }\n    }\n  }\n": typeof types.GetEventsV2Document,
    "\n  query GetEventV2($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        name\n        id\n        receivedAt\n        idempotencyKey\n        occurredAt\n        version\n        source {\n          name\n        }\n      }\n    }\n  }\n": typeof types.GetEventV2Document,
    "\n  query GetEventPayload($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        raw\n      }\n    }\n  }\n": typeof types.GetEventPayloadDocument,
    "\n  query GetEventV2Runs($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        name\n        runs {\n          status\n          id\n          startedAt\n          endedAt\n          function {\n            name\n            slug\n          }\n        }\n      }\n    }\n  }\n": typeof types.GetEventV2RunsDocument,
    "\n  mutation CreateCancellation($input: CreateCancellationInput!) {\n    createCancellation(input: $input) {\n      id\n    }\n  }\n": typeof types.CreateCancellationDocument,
    "\n  query GetCancellationRunCount(\n    $envID: ID!\n    $functionSlug: String!\n    $queuedAtMin: Time\n    $queuedAtMax: Time!\n  ) {\n    environment: workspace(id: $envID) {\n      function: workflowBySlug(slug: $functionSlug) {\n        cancellationRunCount(\n          input: { queuedAtMin: $queuedAtMin, queuedAtMax: $queuedAtMax }\n        )\n      }\n    }\n  }\n": typeof types.GetCancellationRunCountDocument,
    "\n  mutation PauseFunction($fnID: ID!, $cancelRunning: Boolean) {\n    pauseFunction(fnID: $fnID, cancelRunning: $cancelRunning) {\n      id\n    }\n  }\n": typeof types.PauseFunctionDocument,
    "\n  mutation UnpauseFunction($fnID: ID!) {\n    unpauseFunction(fnID: $fnID) {\n      id\n    }\n  }\n": typeof types.UnpauseFunctionDocument,
    "\n  query MetricsLookups($envSlug: String!, $page: Int, $pageSize: Int) {\n    envBySlug(slug: $envSlug) {\n      apps {\n        externalID\n        id\n        name\n        isArchived\n      }\n      workflows @paginated(perPage: $pageSize, page: $page) {\n        data {\n          name\n          id\n          slug\n        }\n        page {\n          page\n          totalPages\n          perPage\n        }\n      }\n    }\n  }\n": typeof types.MetricsLookupsDocument,
    "\n  query AccountConcurrencyLookup {\n    account {\n      marketplace\n      entitlements {\n        concurrency {\n          limit\n        }\n      }\n    }\n  }\n": typeof types.AccountConcurrencyLookupDocument,
    "\n  query FunctionStatusMetrics(\n    $workspaceId: ID!\n    $from: Time!\n    $functionIDs: [UUID!]\n    $appIDs: [UUID!]\n    $until: Time\n    $scope: MetricsScope!\n  ) {\n    workspace(id: $workspaceId) {\n      scheduled: scopedMetrics(\n        filter: {\n          name: \"function_run_scheduled_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      started: scopedMetrics(\n        filter: {\n          name: \"function_run_started_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      completed: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: $scope\n          groupBy: \"status\"\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      completedByFunction: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: FN\n          groupBy: \"status\"\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      totals: scopedFunctionStatus(\n        filter: {\n          name: \"function_run_scheduled_total\"\n          scope: FN\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        queued\n        running\n        completed\n        failed\n        cancelled\n        cancelled\n        skipped\n      }\n    }\n  }\n": typeof types.FunctionStatusMetricsDocument,
    "\n  query VolumeMetrics(\n    $workspaceId: ID!\n    $from: Time!\n    $functionIDs: [UUID!]\n    $appIDs: [UUID!]\n    $until: Time\n    $scope: MetricsScope!\n  ) {\n    accountConcurrency: metrics(\n      opts: { name: \"steps_running\", from: $from, to: $until }\n    ) {\n      data {\n        bucket\n        value\n      }\n      from\n      to\n      granularity\n    }\n\n    workspace(id: $workspaceId) {\n      runsThroughput: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputEnded: scopedMetrics(\n        filter: {\n          name: \"sdk_req_ended_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputStarted: scopedMetrics(\n        filter: {\n          name: \"sdk_req_started_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputScheduled: scopedMetrics(\n        filter: {\n          name: \"sdk_req_scheduled_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      stepThroughput: scopedMetrics(\n        filter: {\n          name: \"steps_running\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      backlog: scopedMetrics(\n        filter: {\n          name: \"steps_scheduled\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      stepRunning: scopedMetrics(\n        filter: {\n          name: \"steps_running\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      concurrency: scopedMetrics(\n        filter: {\n          name: \"concurrency_limit_reached_total\"\n          scope: $scope\n          from: $from\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n  }\n": typeof types.VolumeMetricsDocument,
    "\n  query QuickSearch($term: String!, $envSlug: String!) {\n    account {\n      quickSearch(term: $term, envSlug: $envSlug) {\n        apps {\n          name\n        }\n        event {\n          envSlug\n          id\n          name\n        }\n        eventTypes {\n          name\n        }\n        functions {\n          name\n          slug\n        }\n        run {\n          envSlug\n          id\n        }\n      }\n    }\n  }\n": typeof types.QuickSearchDocument,
    "\n  mutation SyncOnboardingApp($appURL: String!, $envID: UUID!) {\n    syncNewApp(appURL: $appURL, envID: $envID) {\n      app {\n        externalID\n        id\n      }\n      error {\n        code\n        data\n        message\n      }\n    }\n  }\n": typeof types.SyncOnboardingAppDocument,
    "\n  mutation InvokeFunctionOnboarding(\n    $envID: UUID!\n    $data: Map\n    $functionSlug: String!\n    $user: Map\n  ) {\n    invokeFunction(\n      envID: $envID\n      data: $data\n      functionSlug: $functionSlug\n      user: $user\n    )\n  }\n": typeof types.InvokeFunctionOnboardingDocument,
    "\n  query InvokeFunctionLookup($envSlug: String!, $page: Int, $pageSize: Int) {\n    envBySlug(slug: $envSlug) {\n      workflows @paginated(perPage: $pageSize, page: $page) {\n        data {\n          name\n          id\n          slug\n          triggers {\n            type\n            value\n          }\n        }\n        page {\n          page\n          totalPages\n          perPage\n        }\n      }\n    }\n  }\n": typeof types.InvokeFunctionLookupDocument,
    "\n  query GetVercelApps($envID: ID!) {\n    environment: workspace(id: $envID) {\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n        error\n        url\n        vercelDeploymentURL\n      }\n      apps {\n        id\n        name\n        externalID\n        isArchived\n        latestSync {\n          error\n          id\n          platform\n          vercelDeploymentID\n          vercelProjectID\n          status\n        }\n      }\n    }\n  }\n": typeof types.GetVercelAppsDocument,
    "\n  query ProductionApps($envID: ID!) {\n    environment: workspace(id: $envID) {\n      apps {\n        id\n      }\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n      }\n    }\n  }\n": typeof types.ProductionAppsDocument,
    "\n  query GetRunTraceTrigger($envID: ID!, $runID: String!) {\n    workspace(id: $envID) {\n      runTrigger(runID: $runID) {\n        IDs\n        payloads\n        timestamp\n        eventName\n        isBatch\n        batchID\n        cron\n      }\n    }\n  }\n": typeof types.GetRunTraceTriggerDocument,
    "\n  query GetRuns(\n    $appIDs: [UUID!]\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time\n    $status: [FunctionRunStatus!]\n    $timeField: RunsOrderByField!\n    $functionSlug: String\n    $functionRunCursor: String = null\n    $celQuery: String = null\n    $preview: Boolean = false\n  ) {\n    environment: workspace(id: $environmentID) {\n      runs(\n        filter: {\n          appIDs: $appIDs\n          from: $startTime\n          until: $endTime\n          status: $status\n          timeField: $timeField\n          fnSlug: $functionSlug\n          query: $celQuery\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n        after: $functionRunCursor\n        preview: $preview\n      ) {\n        edges {\n          node {\n            app {\n              externalID\n              name\n            }\n            cronSchedule\n            eventName\n            function {\n              name\n              slug\n            }\n            id\n            isBatch\n            queuedAt\n            endedAt\n            startedAt\n            status\n            hasAI\n          }\n        }\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          startCursor\n          endCursor\n        }\n      }\n    }\n  }\n": typeof types.GetRunsDocument,
    "\n  query CountRuns(\n    $appIDs: [UUID!]\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time\n    $status: [FunctionRunStatus!]\n    $timeField: RunsOrderByField!\n    $functionSlug: String\n    $celQuery: String = null\n  ) {\n    environment: workspace(id: $environmentID) {\n      runs(\n        filter: {\n          appIDs: $appIDs\n          from: $startTime\n          until: $endTime\n          status: $status\n          timeField: $timeField\n          fnSlug: $functionSlug\n          query: $celQuery\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n      ) {\n        totalCount\n      }\n    }\n  }\n": typeof types.CountRunsDocument,
    "\n  query AppFilter($envSlug: String!) {\n    env: envBySlug(slug: $envSlug) {\n      apps {\n        externalID\n        id\n        name\n      }\n    }\n  }\n": typeof types.AppFilterDocument,
    "\n  query GetWorkerConnections(\n    $envID: ID!\n    $appID: UUID!\n    $startTime: Time\n    $status: [ConnectV1ConnectionStatus!]\n    $timeField: ConnectV1WorkerConnectionsOrderByField!\n    $cursor: String = null\n    $orderBy: [ConnectV1WorkerConnectionsOrderBy!] = []\n    $first: Int!\n  ) {\n    environment: workspace(id: $envID) {\n      workerConnections(\n        first: $first\n        filter: {\n          appIDs: [$appID]\n          from: $startTime\n          status: $status\n          timeField: $timeField\n        }\n        orderBy: $orderBy\n        after: $cursor\n      ) {\n        edges {\n          node {\n            id\n            gatewayId\n            instanceID: instanceId\n            workerIp\n            app {\n              id\n            }\n            connectedAt\n            lastHeartbeatAt\n            disconnectedAt\n            disconnectReason\n            status\n            sdkLang\n            sdkVersion\n            sdkPlatform\n            appVersion\n            functionCount\n            cpuCores\n            memBytes\n            os\n          }\n        }\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          startCursor\n          endCursor\n        }\n        totalCount\n      }\n    }\n  }\n": typeof types.GetWorkerConnectionsDocument,
    "\n  query GetWorkerCountConnections(\n    $envID: ID!\n    $appID: UUID!\n    $startTime: Time\n    $status: [ConnectV1ConnectionStatus!] = []\n    $timeField: ConnectV1WorkerConnectionsOrderByField!\n  ) {\n    environment: workspace(id: $envID) {\n      workerConnections(\n        filter: {\n          appIDs: [$appID]\n          from: $startTime\n          status: $status\n          timeField: $timeField\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n      ) {\n        totalCount\n      }\n    }\n  }\n": typeof types.GetWorkerCountConnectionsDocument,
    "\n  query GetDeployss($environmentID: ID!) {\n    deploys(workspaceID: $environmentID) {\n      id\n      appName\n      authorID\n      checksum\n      createdAt\n      error\n      framework\n      metadata\n      sdkLanguage\n      sdkVersion\n      status\n\n      deployedFunctions {\n        id\n        name\n      }\n\n      removedFunctions {\n        id\n        name\n      }\n    }\n  }\n": typeof types.GetDeployssDocument,
    "\n  query GetEnvironments {\n    workspaces {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      webhookSigningKey\n      createdAt\n      isArchived\n      isAutoArchiveEnabled\n      lastDeployedAt\n    }\n  }\n": typeof types.GetEnvironmentsDocument,
    "\n  query GetEnvironmentBySlug($slug: String!) {\n    envBySlug(slug: $slug) {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n      webhookSigningKey\n    }\n  }\n": typeof types.GetEnvironmentBySlugDocument,
    "\n  query GetDefaultEnvironment {\n    defaultEnv {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n    }\n  }\n": typeof types.GetDefaultEnvironmentDocument,
    "\n  query GetFunctionsUsage(\n    $environmentID: ID!\n    $page: Int\n    $archived: Boolean\n    $pageSize: Int\n  ) {\n    workspace(id: $environmentID) {\n      workflows(archived: $archived)\n        @paginated(perPage: $pageSize, page: $page) {\n        page {\n          page\n          perPage\n          totalItems\n          totalPages\n        }\n        data {\n          id\n          slug\n          dailyStarts: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"started\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyCompleted: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"completed\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyCancelled: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"cancelled\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyFailures: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"errored\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n        }\n      }\n    }\n  }\n": typeof types.GetFunctionsUsageDocument,
    "\n  query GetFunctions(\n    $environmentID: ID!\n    $page: Int\n    $archived: Boolean\n    $search: String\n    $pageSize: Int\n  ) {\n    workspace(id: $environmentID) {\n      workflows(archived: $archived, search: $search)\n        @paginated(perPage: $pageSize, page: $page) {\n        page {\n          page\n          perPage\n          totalItems\n          totalPages\n        }\n        data {\n          app {\n            name\n            externalID\n          }\n          id\n          slug\n          name\n          isPaused\n          isArchived\n          triggers {\n            type\n            value\n          }\n        }\n      }\n    }\n  }\n": typeof types.GetFunctionsDocument,
    "\n  query GetFunction($slug: String!, $environmentID: ID!) {\n    workspace(id: $environmentID) {\n      id\n      workflow: workflowBySlug(slug: $slug) {\n        id\n        name\n        slug\n        isPaused\n        isArchived\n        app {\n          externalID\n          name\n          latestSync {\n            lastSyncedAt\n          }\n        }\n        triggers {\n          type\n          value\n          condition\n        }\n        failureHandler {\n          slug\n          name\n        }\n        configuration {\n          cancellations {\n            event\n            timeout\n            condition\n          }\n          retries {\n            value\n            isDefault\n          }\n          priority\n          eventsBatch {\n            maxSize\n            timeout\n            key\n          }\n          concurrency {\n            scope\n            limit {\n              value\n              isPlanLimit\n            }\n            key\n          }\n          rateLimit {\n            limit\n            period\n            key\n          }\n          debounce {\n            period\n            key\n          }\n          throttle {\n            burst\n            key\n            limit\n            period\n          }\n          singleton {\n            key\n            mode\n          }\n        }\n      }\n    }\n  }\n": typeof types.GetFunctionDocument,
    "\n  query GetFunctionUsage(\n    $id: ID!\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time!\n  ) {\n    workspace(id: $environmentID) {\n      workflow(id: $id) {\n        dailyStarts: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"started\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyCancelled: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"cancelled\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyCompleted: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"completed\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyFailures: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"errored\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n      }\n    }\n  }\n": typeof types.GetFunctionUsageDocument,
    "\n  query GetProductionWorkspace {\n    defaultEnv {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n      webhookSigningKey\n    }\n  }\n": typeof types.GetProductionWorkspaceDocument,
    "\n  query Profile {\n    account {\n      name\n      marketplace\n    }\n  }\n": typeof types.ProfileDocument,
    "\n  mutation CancelRun($envID: UUID!, $runID: ULID!) {\n    cancelRun(envID: $envID, runID: $runID) {\n      id\n    }\n  }\n": typeof types.CancelRunDocument,
    "\n  query GetEventKeysForBlankSlate($environmentID: ID!) {\n    environment: workspace(id: $environmentID) {\n      ingestKeys(filter: { source: \"key\" }) {\n        name\n        presharedKey\n        createdAt\n      }\n    }\n  }\n": typeof types.GetEventKeysForBlankSlateDocument,
    "\n  fragment TraceDetails on RunTraceSpan {\n    name\n    status\n    attempts\n    queuedAt\n    startedAt\n    endedAt\n    isRoot\n    isUserland\n    userlandSpan {\n      spanName\n      spanKind\n      serviceName\n      scopeName\n      scopeVersion\n      spanAttrs\n      resourceAttrs\n    }\n    outputID\n    stepID\n    spanID\n    stepOp\n    stepType\n    stepInfo {\n      __typename\n      ... on InvokeStepInfo {\n        triggeringEventID\n        functionID\n        timeout\n        returnEventID\n        runID\n        timedOut\n      }\n      ... on SleepStepInfo {\n        sleepUntil\n      }\n      ... on WaitForEventStepInfo {\n        eventName\n        expression\n        timeout\n        foundEventID\n        timedOut\n      }\n    }\n  }\n": typeof types.TraceDetailsFragmentDoc,
    "\n  query GetRunTrace($envID: ID!, $runID: String!, $preview: Boolean) {\n    workspace(id: $envID) {\n      run(runID: $runID) {\n        function {\n          app {\n            name\n            externalID\n          }\n          id\n          name\n          slug\n        }\n        status\n        trace(preview: $preview) {\n          ...TraceDetails\n          childrenSpans {\n            ...TraceDetails\n            childrenSpans {\n              ...TraceDetails\n              childrenSpans {\n                ...TraceDetails\n                childrenSpans {\n                  ...TraceDetails\n                }\n              }\n            }\n          }\n        }\n        hasAI\n      }\n    }\n  }\n": typeof types.GetRunTraceDocument,
    "\n  query TraceResult($envID: ID!, $traceID: String!) {\n    workspace(id: $envID) {\n      runTraceSpanOutputByID(outputID: $traceID) {\n        data\n        input\n        error {\n          message\n          name\n          stack\n          cause\n        }\n      }\n    }\n  }\n": typeof types.TraceResultDocument,
    "\n  mutation RerunFunctionRun(\n    $environmentID: ID!\n    $functionID: ID!\n    $functionRunID: ULID!\n  ) {\n    retryWorkflowRun(\n      input: { workspaceID: $environmentID, workflowID: $functionID }\n      workflowRunID: $functionRunID\n    ) {\n      id\n    }\n  }\n": typeof types.RerunFunctionRunDocument,
    "\n  mutation Rerun($runID: ULID!, $fromStep: RerunFromStepInput) {\n    rerun(runID: $runID, fromStep: $fromStep)\n  }\n": typeof types.RerunDocument,
    "\n  query GetAccountEntitlements {\n    account {\n      entitlements {\n        history {\n          limit\n        }\n      }\n    }\n  }\n": typeof types.GetAccountEntitlementsDocument,
};
const documents: Documents = {
    "\n  mutation AchiveApp($appID: UUID!) {\n    archiveApp(id: $appID) {\n      id\n    }\n  }\n": types.AchiveAppDocument,
    "\n  mutation UnachiveApp($appID: UUID!) {\n    unarchiveApp(id: $appID) {\n      id\n    }\n  }\n": types.UnachiveAppDocument,
    "\n  mutation ResyncApp($appExternalID: String!, $appURL: String, $envID: UUID!) {\n    resyncApp(appExternalID: $appExternalID, appURL: $appURL, envID: $envID) {\n      app {\n        id\n      }\n      error {\n        code\n        data\n        message\n      }\n    }\n  }\n": types.ResyncAppDocument,
    "\n  query CheckApp($envID: ID!, $url: String!) {\n    env: workspace(id: $envID) {\n      appCheck(url: $url) {\n        apiOrigin {\n          value\n        }\n        appID {\n          value\n        }\n        authenticationSucceeded {\n          value\n        }\n        env {\n          value\n        }\n        error\n        eventAPIOrigin {\n          value\n        }\n        eventKeyStatus\n        extra\n        framework {\n          value\n        }\n        isReachable\n        isSDK\n        mode\n        respHeaders\n        respStatusCode\n        sdkLanguage {\n          value\n        }\n        sdkVersion {\n          value\n        }\n        serveOrigin {\n          value\n        }\n        servePath {\n          value\n        }\n        signingKeyStatus\n        signingKeyFallbackStatus\n      }\n    }\n  }\n": types.CheckAppDocument,
    "\n  query Apps($envID: ID!, $filter: AppsFilter!) {\n    environment: workspace(id: $envID) {\n      apps(filter: $filter) {\n        id\n        externalID\n        functionCount\n        isArchived\n        name\n        method\n        isParentArchived\n        latestSync {\n          error\n          framework\n          id\n          lastSyncedAt\n          platform\n          sdkLanguage\n          sdkVersion\n          status\n          url\n        }\n        functions {\n          id\n          name\n          slug\n          triggers {\n            type\n            value\n          }\n        }\n      }\n    }\n  }\n": types.AppsDocument,
    "\n  query LatestUnattachedSync($envID: ID!) {\n    environment: workspace(id: $envID) {\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n      }\n    }\n  }\n": types.LatestUnattachedSyncDocument,
    "\n  mutation DisableEnvironmentAutoArchiveDocument($id: ID!) {\n    disableEnvironmentAutoArchive(id: $id) {\n      id\n    }\n  }\n": types.DisableEnvironmentAutoArchiveDocumentDocument,
    "\n  mutation EnableEnvironmentAutoArchive($id: ID!) {\n    enableEnvironmentAutoArchive(id: $id) {\n      id\n    }\n  }\n": types.EnableEnvironmentAutoArchiveDocument,
    "\n  mutation ArchiveEnvironment($id: ID!) {\n    archiveEnvironment(id: $id) {\n      id\n    }\n  }\n": types.ArchiveEnvironmentDocument,
    "\n  mutation UnarchiveEnvironment($id: ID!) {\n    unarchiveEnvironment(id: $id) {\n      id\n    }\n  }\n": types.UnarchiveEnvironmentDocument,
    "\n  query GetEventTypesV2(\n    $envID: ID!\n    $cursor: String\n    $archived: Boolean\n    $nameSearch: String\n  ) {\n    environment: workspace(id: $envID) {\n      eventTypesV2(\n        after: $cursor\n        first: 40\n        filter: { archived: $archived, nameSearch: $nameSearch }\n      ) {\n        edges {\n          node {\n            name\n            functions {\n              edges {\n                node {\n                  id\n                  slug\n                  name\n                }\n              }\n            }\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n          hasPreviousPage\n          startCursor\n        }\n      }\n    }\n  }\n": types.GetEventTypesV2Document,
    "\n  query GetEventTypeVolumeV2(\n    $envID: ID!\n    $eventName: String!\n    $startTime: Time!\n    $endTime: Time!\n  ) {\n    environment: workspace(id: $envID) {\n      eventType(name: $eventName) {\n        name\n        usage(opts: { period: hour, from: $startTime, to: $endTime }) {\n          total\n          data {\n            count\n            slot\n          }\n        }\n      }\n    }\n  }\n": types.GetEventTypeVolumeV2Document,
    "\n  query GetEventType($envID: ID!, $eventName: String!) {\n    environment: workspace(id: $envID) {\n      eventType(name: $eventName) {\n        name\n        functions {\n          edges {\n            node {\n              id\n              slug\n              name\n            }\n          }\n        }\n      }\n    }\n  }\n": types.GetEventTypeDocument,
    "\n  query GetAllEventNames($envID: ID!) {\n    environment: workspace(id: $envID) {\n      eventTypesV2(first: 40, filter: {}) {\n        edges {\n          node {\n            name\n          }\n        }\n      }\n    }\n  }\n": types.GetAllEventNamesDocument,
    "\n  mutation ArchiveEvent($environmentId: ID!, $name: String!) {\n    archiveEvent(workspaceID: $environmentId, name: $name) {\n      name\n    }\n  }\n": types.ArchiveEventDocument,
    "\n  query GetLatestEventLogs($name: String, $environmentID: ID!) {\n    events(query: { name: $name, workspaceID: $environmentID }) {\n      data {\n        recent(count: 5) {\n          id\n          receivedAt\n          event\n          source {\n            name\n          }\n        }\n      }\n    }\n  }\n": types.GetLatestEventLogsDocument,
    "\n  query GetEventKeys($environmentID: ID!) {\n    environment: workspace(id: $environmentID) {\n      eventKeys: ingestKeys {\n        name\n        value: presharedKey\n      }\n    }\n  }\n": types.GetEventKeysDocument,
    "\n  query GetEventsV2(\n    $envID: ID!\n    $cursor: String\n    $startTime: Time!\n    $endTime: Time\n    $celQuery: String = null\n    $eventNames: [String!] = null\n    $includeInternalEvents: Boolean = false\n  ) {\n    environment: workspace(id: $envID) {\n      eventsV2(\n        first: 50\n        after: $cursor\n        filter: {\n          from: $startTime\n          until: $endTime\n          query: $celQuery\n          eventNames: $eventNames\n          includeInternalEvents: $includeInternalEvents\n        }\n      ) {\n        edges {\n          node {\n            name\n            id\n            receivedAt\n            runs {\n              status\n              id\n              startedAt\n              endedAt\n              function {\n                name\n                slug\n              }\n            }\n          }\n        }\n        totalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n          hasPreviousPage\n          startCursor\n        }\n      }\n    }\n  }\n": types.GetEventsV2Document,
    "\n  query GetEventV2($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        name\n        id\n        receivedAt\n        idempotencyKey\n        occurredAt\n        version\n        source {\n          name\n        }\n      }\n    }\n  }\n": types.GetEventV2Document,
    "\n  query GetEventPayload($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        raw\n      }\n    }\n  }\n": types.GetEventPayloadDocument,
    "\n  query GetEventV2Runs($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        name\n        runs {\n          status\n          id\n          startedAt\n          endedAt\n          function {\n            name\n            slug\n          }\n        }\n      }\n    }\n  }\n": types.GetEventV2RunsDocument,
    "\n  mutation CreateCancellation($input: CreateCancellationInput!) {\n    createCancellation(input: $input) {\n      id\n    }\n  }\n": types.CreateCancellationDocument,
    "\n  query GetCancellationRunCount(\n    $envID: ID!\n    $functionSlug: String!\n    $queuedAtMin: Time\n    $queuedAtMax: Time!\n  ) {\n    environment: workspace(id: $envID) {\n      function: workflowBySlug(slug: $functionSlug) {\n        cancellationRunCount(\n          input: { queuedAtMin: $queuedAtMin, queuedAtMax: $queuedAtMax }\n        )\n      }\n    }\n  }\n": types.GetCancellationRunCountDocument,
    "\n  mutation PauseFunction($fnID: ID!, $cancelRunning: Boolean) {\n    pauseFunction(fnID: $fnID, cancelRunning: $cancelRunning) {\n      id\n    }\n  }\n": types.PauseFunctionDocument,
    "\n  mutation UnpauseFunction($fnID: ID!) {\n    unpauseFunction(fnID: $fnID) {\n      id\n    }\n  }\n": types.UnpauseFunctionDocument,
    "\n  query MetricsLookups($envSlug: String!, $page: Int, $pageSize: Int) {\n    envBySlug(slug: $envSlug) {\n      apps {\n        externalID\n        id\n        name\n        isArchived\n      }\n      workflows @paginated(perPage: $pageSize, page: $page) {\n        data {\n          name\n          id\n          slug\n        }\n        page {\n          page\n          totalPages\n          perPage\n        }\n      }\n    }\n  }\n": types.MetricsLookupsDocument,
    "\n  query AccountConcurrencyLookup {\n    account {\n      marketplace\n      entitlements {\n        concurrency {\n          limit\n        }\n      }\n    }\n  }\n": types.AccountConcurrencyLookupDocument,
    "\n  query FunctionStatusMetrics(\n    $workspaceId: ID!\n    $from: Time!\n    $functionIDs: [UUID!]\n    $appIDs: [UUID!]\n    $until: Time\n    $scope: MetricsScope!\n  ) {\n    workspace(id: $workspaceId) {\n      scheduled: scopedMetrics(\n        filter: {\n          name: \"function_run_scheduled_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      started: scopedMetrics(\n        filter: {\n          name: \"function_run_started_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      completed: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: $scope\n          groupBy: \"status\"\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      completedByFunction: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: FN\n          groupBy: \"status\"\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      totals: scopedFunctionStatus(\n        filter: {\n          name: \"function_run_scheduled_total\"\n          scope: FN\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        queued\n        running\n        completed\n        failed\n        cancelled\n        cancelled\n        skipped\n      }\n    }\n  }\n": types.FunctionStatusMetricsDocument,
    "\n  query VolumeMetrics(\n    $workspaceId: ID!\n    $from: Time!\n    $functionIDs: [UUID!]\n    $appIDs: [UUID!]\n    $until: Time\n    $scope: MetricsScope!\n  ) {\n    accountConcurrency: metrics(\n      opts: { name: \"steps_running\", from: $from, to: $until }\n    ) {\n      data {\n        bucket\n        value\n      }\n      from\n      to\n      granularity\n    }\n\n    workspace(id: $workspaceId) {\n      runsThroughput: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputEnded: scopedMetrics(\n        filter: {\n          name: \"sdk_req_ended_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputStarted: scopedMetrics(\n        filter: {\n          name: \"sdk_req_started_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputScheduled: scopedMetrics(\n        filter: {\n          name: \"sdk_req_scheduled_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      stepThroughput: scopedMetrics(\n        filter: {\n          name: \"steps_running\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      backlog: scopedMetrics(\n        filter: {\n          name: \"steps_scheduled\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      stepRunning: scopedMetrics(\n        filter: {\n          name: \"steps_running\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      concurrency: scopedMetrics(\n        filter: {\n          name: \"concurrency_limit_reached_total\"\n          scope: $scope\n          from: $from\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n  }\n": types.VolumeMetricsDocument,
    "\n  query QuickSearch($term: String!, $envSlug: String!) {\n    account {\n      quickSearch(term: $term, envSlug: $envSlug) {\n        apps {\n          name\n        }\n        event {\n          envSlug\n          id\n          name\n        }\n        eventTypes {\n          name\n        }\n        functions {\n          name\n          slug\n        }\n        run {\n          envSlug\n          id\n        }\n      }\n    }\n  }\n": types.QuickSearchDocument,
    "\n  mutation SyncOnboardingApp($appURL: String!, $envID: UUID!) {\n    syncNewApp(appURL: $appURL, envID: $envID) {\n      app {\n        externalID\n        id\n      }\n      error {\n        code\n        data\n        message\n      }\n    }\n  }\n": types.SyncOnboardingAppDocument,
    "\n  mutation InvokeFunctionOnboarding(\n    $envID: UUID!\n    $data: Map\n    $functionSlug: String!\n    $user: Map\n  ) {\n    invokeFunction(\n      envID: $envID\n      data: $data\n      functionSlug: $functionSlug\n      user: $user\n    )\n  }\n": types.InvokeFunctionOnboardingDocument,
    "\n  query InvokeFunctionLookup($envSlug: String!, $page: Int, $pageSize: Int) {\n    envBySlug(slug: $envSlug) {\n      workflows @paginated(perPage: $pageSize, page: $page) {\n        data {\n          name\n          id\n          slug\n          triggers {\n            type\n            value\n          }\n        }\n        page {\n          page\n          totalPages\n          perPage\n        }\n      }\n    }\n  }\n": types.InvokeFunctionLookupDocument,
    "\n  query GetVercelApps($envID: ID!) {\n    environment: workspace(id: $envID) {\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n        error\n        url\n        vercelDeploymentURL\n      }\n      apps {\n        id\n        name\n        externalID\n        isArchived\n        latestSync {\n          error\n          id\n          platform\n          vercelDeploymentID\n          vercelProjectID\n          status\n        }\n      }\n    }\n  }\n": types.GetVercelAppsDocument,
    "\n  query ProductionApps($envID: ID!) {\n    environment: workspace(id: $envID) {\n      apps {\n        id\n      }\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n      }\n    }\n  }\n": types.ProductionAppsDocument,
    "\n  query GetRunTraceTrigger($envID: ID!, $runID: String!) {\n    workspace(id: $envID) {\n      runTrigger(runID: $runID) {\n        IDs\n        payloads\n        timestamp\n        eventName\n        isBatch\n        batchID\n        cron\n      }\n    }\n  }\n": types.GetRunTraceTriggerDocument,
    "\n  query GetRuns(\n    $appIDs: [UUID!]\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time\n    $status: [FunctionRunStatus!]\n    $timeField: RunsOrderByField!\n    $functionSlug: String\n    $functionRunCursor: String = null\n    $celQuery: String = null\n    $preview: Boolean = false\n  ) {\n    environment: workspace(id: $environmentID) {\n      runs(\n        filter: {\n          appIDs: $appIDs\n          from: $startTime\n          until: $endTime\n          status: $status\n          timeField: $timeField\n          fnSlug: $functionSlug\n          query: $celQuery\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n        after: $functionRunCursor\n        preview: $preview\n      ) {\n        edges {\n          node {\n            app {\n              externalID\n              name\n            }\n            cronSchedule\n            eventName\n            function {\n              name\n              slug\n            }\n            id\n            isBatch\n            queuedAt\n            endedAt\n            startedAt\n            status\n            hasAI\n          }\n        }\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          startCursor\n          endCursor\n        }\n      }\n    }\n  }\n": types.GetRunsDocument,
    "\n  query CountRuns(\n    $appIDs: [UUID!]\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time\n    $status: [FunctionRunStatus!]\n    $timeField: RunsOrderByField!\n    $functionSlug: String\n    $celQuery: String = null\n  ) {\n    environment: workspace(id: $environmentID) {\n      runs(\n        filter: {\n          appIDs: $appIDs\n          from: $startTime\n          until: $endTime\n          status: $status\n          timeField: $timeField\n          fnSlug: $functionSlug\n          query: $celQuery\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n      ) {\n        totalCount\n      }\n    }\n  }\n": types.CountRunsDocument,
    "\n  query AppFilter($envSlug: String!) {\n    env: envBySlug(slug: $envSlug) {\n      apps {\n        externalID\n        id\n        name\n      }\n    }\n  }\n": types.AppFilterDocument,
    "\n  query GetWorkerConnections(\n    $envID: ID!\n    $appID: UUID!\n    $startTime: Time\n    $status: [ConnectV1ConnectionStatus!]\n    $timeField: ConnectV1WorkerConnectionsOrderByField!\n    $cursor: String = null\n    $orderBy: [ConnectV1WorkerConnectionsOrderBy!] = []\n    $first: Int!\n  ) {\n    environment: workspace(id: $envID) {\n      workerConnections(\n        first: $first\n        filter: {\n          appIDs: [$appID]\n          from: $startTime\n          status: $status\n          timeField: $timeField\n        }\n        orderBy: $orderBy\n        after: $cursor\n      ) {\n        edges {\n          node {\n            id\n            gatewayId\n            instanceID: instanceId\n            workerIp\n            app {\n              id\n            }\n            connectedAt\n            lastHeartbeatAt\n            disconnectedAt\n            disconnectReason\n            status\n            sdkLang\n            sdkVersion\n            sdkPlatform\n            appVersion\n            functionCount\n            cpuCores\n            memBytes\n            os\n          }\n        }\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          startCursor\n          endCursor\n        }\n        totalCount\n      }\n    }\n  }\n": types.GetWorkerConnectionsDocument,
    "\n  query GetWorkerCountConnections(\n    $envID: ID!\n    $appID: UUID!\n    $startTime: Time\n    $status: [ConnectV1ConnectionStatus!] = []\n    $timeField: ConnectV1WorkerConnectionsOrderByField!\n  ) {\n    environment: workspace(id: $envID) {\n      workerConnections(\n        filter: {\n          appIDs: [$appID]\n          from: $startTime\n          status: $status\n          timeField: $timeField\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n      ) {\n        totalCount\n      }\n    }\n  }\n": types.GetWorkerCountConnectionsDocument,
    "\n  query GetDeployss($environmentID: ID!) {\n    deploys(workspaceID: $environmentID) {\n      id\n      appName\n      authorID\n      checksum\n      createdAt\n      error\n      framework\n      metadata\n      sdkLanguage\n      sdkVersion\n      status\n\n      deployedFunctions {\n        id\n        name\n      }\n\n      removedFunctions {\n        id\n        name\n      }\n    }\n  }\n": types.GetDeployssDocument,
    "\n  query GetEnvironments {\n    workspaces {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      webhookSigningKey\n      createdAt\n      isArchived\n      isAutoArchiveEnabled\n      lastDeployedAt\n    }\n  }\n": types.GetEnvironmentsDocument,
    "\n  query GetEnvironmentBySlug($slug: String!) {\n    envBySlug(slug: $slug) {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n      webhookSigningKey\n    }\n  }\n": types.GetEnvironmentBySlugDocument,
    "\n  query GetDefaultEnvironment {\n    defaultEnv {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n    }\n  }\n": types.GetDefaultEnvironmentDocument,
    "\n  query GetFunctionsUsage(\n    $environmentID: ID!\n    $page: Int\n    $archived: Boolean\n    $pageSize: Int\n  ) {\n    workspace(id: $environmentID) {\n      workflows(archived: $archived)\n        @paginated(perPage: $pageSize, page: $page) {\n        page {\n          page\n          perPage\n          totalItems\n          totalPages\n        }\n        data {\n          id\n          slug\n          dailyStarts: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"started\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyCompleted: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"completed\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyCancelled: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"cancelled\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyFailures: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"errored\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n        }\n      }\n    }\n  }\n": types.GetFunctionsUsageDocument,
    "\n  query GetFunctions(\n    $environmentID: ID!\n    $page: Int\n    $archived: Boolean\n    $search: String\n    $pageSize: Int\n  ) {\n    workspace(id: $environmentID) {\n      workflows(archived: $archived, search: $search)\n        @paginated(perPage: $pageSize, page: $page) {\n        page {\n          page\n          perPage\n          totalItems\n          totalPages\n        }\n        data {\n          app {\n            name\n            externalID\n          }\n          id\n          slug\n          name\n          isPaused\n          isArchived\n          triggers {\n            type\n            value\n          }\n        }\n      }\n    }\n  }\n": types.GetFunctionsDocument,
    "\n  query GetFunction($slug: String!, $environmentID: ID!) {\n    workspace(id: $environmentID) {\n      id\n      workflow: workflowBySlug(slug: $slug) {\n        id\n        name\n        slug\n        isPaused\n        isArchived\n        app {\n          externalID\n          name\n          latestSync {\n            lastSyncedAt\n          }\n        }\n        triggers {\n          type\n          value\n          condition\n        }\n        failureHandler {\n          slug\n          name\n        }\n        configuration {\n          cancellations {\n            event\n            timeout\n            condition\n          }\n          retries {\n            value\n            isDefault\n          }\n          priority\n          eventsBatch {\n            maxSize\n            timeout\n            key\n          }\n          concurrency {\n            scope\n            limit {\n              value\n              isPlanLimit\n            }\n            key\n          }\n          rateLimit {\n            limit\n            period\n            key\n          }\n          debounce {\n            period\n            key\n          }\n          throttle {\n            burst\n            key\n            limit\n            period\n          }\n          singleton {\n            key\n            mode\n          }\n        }\n      }\n    }\n  }\n": types.GetFunctionDocument,
    "\n  query GetFunctionUsage(\n    $id: ID!\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time!\n  ) {\n    workspace(id: $environmentID) {\n      workflow(id: $id) {\n        dailyStarts: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"started\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyCancelled: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"cancelled\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyCompleted: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"completed\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyFailures: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"errored\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n      }\n    }\n  }\n": types.GetFunctionUsageDocument,
    "\n  query GetProductionWorkspace {\n    defaultEnv {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n      webhookSigningKey\n    }\n  }\n": types.GetProductionWorkspaceDocument,
    "\n  query Profile {\n    account {\n      name\n      marketplace\n    }\n  }\n": types.ProfileDocument,
    "\n  mutation CancelRun($envID: UUID!, $runID: ULID!) {\n    cancelRun(envID: $envID, runID: $runID) {\n      id\n    }\n  }\n": types.CancelRunDocument,
    "\n  query GetEventKeysForBlankSlate($environmentID: ID!) {\n    environment: workspace(id: $environmentID) {\n      ingestKeys(filter: { source: \"key\" }) {\n        name\n        presharedKey\n        createdAt\n      }\n    }\n  }\n": types.GetEventKeysForBlankSlateDocument,
    "\n  fragment TraceDetails on RunTraceSpan {\n    name\n    status\n    attempts\n    queuedAt\n    startedAt\n    endedAt\n    isRoot\n    isUserland\n    userlandSpan {\n      spanName\n      spanKind\n      serviceName\n      scopeName\n      scopeVersion\n      spanAttrs\n      resourceAttrs\n    }\n    outputID\n    stepID\n    spanID\n    stepOp\n    stepType\n    stepInfo {\n      __typename\n      ... on InvokeStepInfo {\n        triggeringEventID\n        functionID\n        timeout\n        returnEventID\n        runID\n        timedOut\n      }\n      ... on SleepStepInfo {\n        sleepUntil\n      }\n      ... on WaitForEventStepInfo {\n        eventName\n        expression\n        timeout\n        foundEventID\n        timedOut\n      }\n    }\n  }\n": types.TraceDetailsFragmentDoc,
    "\n  query GetRunTrace($envID: ID!, $runID: String!, $preview: Boolean) {\n    workspace(id: $envID) {\n      run(runID: $runID) {\n        function {\n          app {\n            name\n            externalID\n          }\n          id\n          name\n          slug\n        }\n        status\n        trace(preview: $preview) {\n          ...TraceDetails\n          childrenSpans {\n            ...TraceDetails\n            childrenSpans {\n              ...TraceDetails\n              childrenSpans {\n                ...TraceDetails\n                childrenSpans {\n                  ...TraceDetails\n                }\n              }\n            }\n          }\n        }\n        hasAI\n      }\n    }\n  }\n": types.GetRunTraceDocument,
    "\n  query TraceResult($envID: ID!, $traceID: String!) {\n    workspace(id: $envID) {\n      runTraceSpanOutputByID(outputID: $traceID) {\n        data\n        input\n        error {\n          message\n          name\n          stack\n          cause\n        }\n      }\n    }\n  }\n": types.TraceResultDocument,
    "\n  mutation RerunFunctionRun(\n    $environmentID: ID!\n    $functionID: ID!\n    $functionRunID: ULID!\n  ) {\n    retryWorkflowRun(\n      input: { workspaceID: $environmentID, workflowID: $functionID }\n      workflowRunID: $functionRunID\n    ) {\n      id\n    }\n  }\n": types.RerunFunctionRunDocument,
    "\n  mutation Rerun($runID: ULID!, $fromStep: RerunFromStepInput) {\n    rerun(runID: $runID, fromStep: $fromStep)\n  }\n": types.RerunDocument,
    "\n  query GetAccountEntitlements {\n    account {\n      entitlements {\n        history {\n          limit\n        }\n      }\n    }\n  }\n": types.GetAccountEntitlementsDocument,
};

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = graphql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function graphql(source: string): unknown;

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation AchiveApp($appID: UUID!) {\n    archiveApp(id: $appID) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation AchiveApp($appID: UUID!) {\n    archiveApp(id: $appID) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation UnachiveApp($appID: UUID!) {\n    unarchiveApp(id: $appID) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation UnachiveApp($appID: UUID!) {\n    unarchiveApp(id: $appID) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation ResyncApp($appExternalID: String!, $appURL: String, $envID: UUID!) {\n    resyncApp(appExternalID: $appExternalID, appURL: $appURL, envID: $envID) {\n      app {\n        id\n      }\n      error {\n        code\n        data\n        message\n      }\n    }\n  }\n"): (typeof documents)["\n  mutation ResyncApp($appExternalID: String!, $appURL: String, $envID: UUID!) {\n    resyncApp(appExternalID: $appExternalID, appURL: $appURL, envID: $envID) {\n      app {\n        id\n      }\n      error {\n        code\n        data\n        message\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query CheckApp($envID: ID!, $url: String!) {\n    env: workspace(id: $envID) {\n      appCheck(url: $url) {\n        apiOrigin {\n          value\n        }\n        appID {\n          value\n        }\n        authenticationSucceeded {\n          value\n        }\n        env {\n          value\n        }\n        error\n        eventAPIOrigin {\n          value\n        }\n        eventKeyStatus\n        extra\n        framework {\n          value\n        }\n        isReachable\n        isSDK\n        mode\n        respHeaders\n        respStatusCode\n        sdkLanguage {\n          value\n        }\n        sdkVersion {\n          value\n        }\n        serveOrigin {\n          value\n        }\n        servePath {\n          value\n        }\n        signingKeyStatus\n        signingKeyFallbackStatus\n      }\n    }\n  }\n"): (typeof documents)["\n  query CheckApp($envID: ID!, $url: String!) {\n    env: workspace(id: $envID) {\n      appCheck(url: $url) {\n        apiOrigin {\n          value\n        }\n        appID {\n          value\n        }\n        authenticationSucceeded {\n          value\n        }\n        env {\n          value\n        }\n        error\n        eventAPIOrigin {\n          value\n        }\n        eventKeyStatus\n        extra\n        framework {\n          value\n        }\n        isReachable\n        isSDK\n        mode\n        respHeaders\n        respStatusCode\n        sdkLanguage {\n          value\n        }\n        sdkVersion {\n          value\n        }\n        serveOrigin {\n          value\n        }\n        servePath {\n          value\n        }\n        signingKeyStatus\n        signingKeyFallbackStatus\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query Apps($envID: ID!, $filter: AppsFilter!) {\n    environment: workspace(id: $envID) {\n      apps(filter: $filter) {\n        id\n        externalID\n        functionCount\n        isArchived\n        name\n        method\n        isParentArchived\n        latestSync {\n          error\n          framework\n          id\n          lastSyncedAt\n          platform\n          sdkLanguage\n          sdkVersion\n          status\n          url\n        }\n        functions {\n          id\n          name\n          slug\n          triggers {\n            type\n            value\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query Apps($envID: ID!, $filter: AppsFilter!) {\n    environment: workspace(id: $envID) {\n      apps(filter: $filter) {\n        id\n        externalID\n        functionCount\n        isArchived\n        name\n        method\n        isParentArchived\n        latestSync {\n          error\n          framework\n          id\n          lastSyncedAt\n          platform\n          sdkLanguage\n          sdkVersion\n          status\n          url\n        }\n        functions {\n          id\n          name\n          slug\n          triggers {\n            type\n            value\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query LatestUnattachedSync($envID: ID!) {\n    environment: workspace(id: $envID) {\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n      }\n    }\n  }\n"): (typeof documents)["\n  query LatestUnattachedSync($envID: ID!) {\n    environment: workspace(id: $envID) {\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation DisableEnvironmentAutoArchiveDocument($id: ID!) {\n    disableEnvironmentAutoArchive(id: $id) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation DisableEnvironmentAutoArchiveDocument($id: ID!) {\n    disableEnvironmentAutoArchive(id: $id) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation EnableEnvironmentAutoArchive($id: ID!) {\n    enableEnvironmentAutoArchive(id: $id) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation EnableEnvironmentAutoArchive($id: ID!) {\n    enableEnvironmentAutoArchive(id: $id) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation ArchiveEnvironment($id: ID!) {\n    archiveEnvironment(id: $id) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation ArchiveEnvironment($id: ID!) {\n    archiveEnvironment(id: $id) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation UnarchiveEnvironment($id: ID!) {\n    unarchiveEnvironment(id: $id) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation UnarchiveEnvironment($id: ID!) {\n    unarchiveEnvironment(id: $id) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEventTypesV2(\n    $envID: ID!\n    $cursor: String\n    $archived: Boolean\n    $nameSearch: String\n  ) {\n    environment: workspace(id: $envID) {\n      eventTypesV2(\n        after: $cursor\n        first: 40\n        filter: { archived: $archived, nameSearch: $nameSearch }\n      ) {\n        edges {\n          node {\n            name\n            functions {\n              edges {\n                node {\n                  id\n                  slug\n                  name\n                }\n              }\n            }\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n          hasPreviousPage\n          startCursor\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetEventTypesV2(\n    $envID: ID!\n    $cursor: String\n    $archived: Boolean\n    $nameSearch: String\n  ) {\n    environment: workspace(id: $envID) {\n      eventTypesV2(\n        after: $cursor\n        first: 40\n        filter: { archived: $archived, nameSearch: $nameSearch }\n      ) {\n        edges {\n          node {\n            name\n            functions {\n              edges {\n                node {\n                  id\n                  slug\n                  name\n                }\n              }\n            }\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n          hasPreviousPage\n          startCursor\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEventTypeVolumeV2(\n    $envID: ID!\n    $eventName: String!\n    $startTime: Time!\n    $endTime: Time!\n  ) {\n    environment: workspace(id: $envID) {\n      eventType(name: $eventName) {\n        name\n        usage(opts: { period: hour, from: $startTime, to: $endTime }) {\n          total\n          data {\n            count\n            slot\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetEventTypeVolumeV2(\n    $envID: ID!\n    $eventName: String!\n    $startTime: Time!\n    $endTime: Time!\n  ) {\n    environment: workspace(id: $envID) {\n      eventType(name: $eventName) {\n        name\n        usage(opts: { period: hour, from: $startTime, to: $endTime }) {\n          total\n          data {\n            count\n            slot\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEventType($envID: ID!, $eventName: String!) {\n    environment: workspace(id: $envID) {\n      eventType(name: $eventName) {\n        name\n        functions {\n          edges {\n            node {\n              id\n              slug\n              name\n            }\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetEventType($envID: ID!, $eventName: String!) {\n    environment: workspace(id: $envID) {\n      eventType(name: $eventName) {\n        name\n        functions {\n          edges {\n            node {\n              id\n              slug\n              name\n            }\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetAllEventNames($envID: ID!) {\n    environment: workspace(id: $envID) {\n      eventTypesV2(first: 40, filter: {}) {\n        edges {\n          node {\n            name\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetAllEventNames($envID: ID!) {\n    environment: workspace(id: $envID) {\n      eventTypesV2(first: 40, filter: {}) {\n        edges {\n          node {\n            name\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation ArchiveEvent($environmentId: ID!, $name: String!) {\n    archiveEvent(workspaceID: $environmentId, name: $name) {\n      name\n    }\n  }\n"): (typeof documents)["\n  mutation ArchiveEvent($environmentId: ID!, $name: String!) {\n    archiveEvent(workspaceID: $environmentId, name: $name) {\n      name\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetLatestEventLogs($name: String, $environmentID: ID!) {\n    events(query: { name: $name, workspaceID: $environmentID }) {\n      data {\n        recent(count: 5) {\n          id\n          receivedAt\n          event\n          source {\n            name\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetLatestEventLogs($name: String, $environmentID: ID!) {\n    events(query: { name: $name, workspaceID: $environmentID }) {\n      data {\n        recent(count: 5) {\n          id\n          receivedAt\n          event\n          source {\n            name\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEventKeys($environmentID: ID!) {\n    environment: workspace(id: $environmentID) {\n      eventKeys: ingestKeys {\n        name\n        value: presharedKey\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetEventKeys($environmentID: ID!) {\n    environment: workspace(id: $environmentID) {\n      eventKeys: ingestKeys {\n        name\n        value: presharedKey\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEventsV2(\n    $envID: ID!\n    $cursor: String\n    $startTime: Time!\n    $endTime: Time\n    $celQuery: String = null\n    $eventNames: [String!] = null\n    $includeInternalEvents: Boolean = false\n  ) {\n    environment: workspace(id: $envID) {\n      eventsV2(\n        first: 50\n        after: $cursor\n        filter: {\n          from: $startTime\n          until: $endTime\n          query: $celQuery\n          eventNames: $eventNames\n          includeInternalEvents: $includeInternalEvents\n        }\n      ) {\n        edges {\n          node {\n            name\n            id\n            receivedAt\n            runs {\n              status\n              id\n              startedAt\n              endedAt\n              function {\n                name\n                slug\n              }\n            }\n          }\n        }\n        totalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n          hasPreviousPage\n          startCursor\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetEventsV2(\n    $envID: ID!\n    $cursor: String\n    $startTime: Time!\n    $endTime: Time\n    $celQuery: String = null\n    $eventNames: [String!] = null\n    $includeInternalEvents: Boolean = false\n  ) {\n    environment: workspace(id: $envID) {\n      eventsV2(\n        first: 50\n        after: $cursor\n        filter: {\n          from: $startTime\n          until: $endTime\n          query: $celQuery\n          eventNames: $eventNames\n          includeInternalEvents: $includeInternalEvents\n        }\n      ) {\n        edges {\n          node {\n            name\n            id\n            receivedAt\n            runs {\n              status\n              id\n              startedAt\n              endedAt\n              function {\n                name\n                slug\n              }\n            }\n          }\n        }\n        totalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n          hasPreviousPage\n          startCursor\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEventV2($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        name\n        id\n        receivedAt\n        idempotencyKey\n        occurredAt\n        version\n        source {\n          name\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetEventV2($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        name\n        id\n        receivedAt\n        idempotencyKey\n        occurredAt\n        version\n        source {\n          name\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEventPayload($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        raw\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetEventPayload($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        raw\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEventV2Runs($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        name\n        runs {\n          status\n          id\n          startedAt\n          endedAt\n          function {\n            name\n            slug\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetEventV2Runs($envID: ID!, $eventID: ULID!) {\n    environment: workspace(id: $envID) {\n      eventV2(id: $eventID) {\n        name\n        runs {\n          status\n          id\n          startedAt\n          endedAt\n          function {\n            name\n            slug\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation CreateCancellation($input: CreateCancellationInput!) {\n    createCancellation(input: $input) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation CreateCancellation($input: CreateCancellationInput!) {\n    createCancellation(input: $input) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetCancellationRunCount(\n    $envID: ID!\n    $functionSlug: String!\n    $queuedAtMin: Time\n    $queuedAtMax: Time!\n  ) {\n    environment: workspace(id: $envID) {\n      function: workflowBySlug(slug: $functionSlug) {\n        cancellationRunCount(\n          input: { queuedAtMin: $queuedAtMin, queuedAtMax: $queuedAtMax }\n        )\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetCancellationRunCount(\n    $envID: ID!\n    $functionSlug: String!\n    $queuedAtMin: Time\n    $queuedAtMax: Time!\n  ) {\n    environment: workspace(id: $envID) {\n      function: workflowBySlug(slug: $functionSlug) {\n        cancellationRunCount(\n          input: { queuedAtMin: $queuedAtMin, queuedAtMax: $queuedAtMax }\n        )\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation PauseFunction($fnID: ID!, $cancelRunning: Boolean) {\n    pauseFunction(fnID: $fnID, cancelRunning: $cancelRunning) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation PauseFunction($fnID: ID!, $cancelRunning: Boolean) {\n    pauseFunction(fnID: $fnID, cancelRunning: $cancelRunning) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation UnpauseFunction($fnID: ID!) {\n    unpauseFunction(fnID: $fnID) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation UnpauseFunction($fnID: ID!) {\n    unpauseFunction(fnID: $fnID) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query MetricsLookups($envSlug: String!, $page: Int, $pageSize: Int) {\n    envBySlug(slug: $envSlug) {\n      apps {\n        externalID\n        id\n        name\n        isArchived\n      }\n      workflows @paginated(perPage: $pageSize, page: $page) {\n        data {\n          name\n          id\n          slug\n        }\n        page {\n          page\n          totalPages\n          perPage\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query MetricsLookups($envSlug: String!, $page: Int, $pageSize: Int) {\n    envBySlug(slug: $envSlug) {\n      apps {\n        externalID\n        id\n        name\n        isArchived\n      }\n      workflows @paginated(perPage: $pageSize, page: $page) {\n        data {\n          name\n          id\n          slug\n        }\n        page {\n          page\n          totalPages\n          perPage\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query AccountConcurrencyLookup {\n    account {\n      marketplace\n      entitlements {\n        concurrency {\n          limit\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query AccountConcurrencyLookup {\n    account {\n      marketplace\n      entitlements {\n        concurrency {\n          limit\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query FunctionStatusMetrics(\n    $workspaceId: ID!\n    $from: Time!\n    $functionIDs: [UUID!]\n    $appIDs: [UUID!]\n    $until: Time\n    $scope: MetricsScope!\n  ) {\n    workspace(id: $workspaceId) {\n      scheduled: scopedMetrics(\n        filter: {\n          name: \"function_run_scheduled_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      started: scopedMetrics(\n        filter: {\n          name: \"function_run_started_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      completed: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: $scope\n          groupBy: \"status\"\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      completedByFunction: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: FN\n          groupBy: \"status\"\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      totals: scopedFunctionStatus(\n        filter: {\n          name: \"function_run_scheduled_total\"\n          scope: FN\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        queued\n        running\n        completed\n        failed\n        cancelled\n        cancelled\n        skipped\n      }\n    }\n  }\n"): (typeof documents)["\n  query FunctionStatusMetrics(\n    $workspaceId: ID!\n    $from: Time!\n    $functionIDs: [UUID!]\n    $appIDs: [UUID!]\n    $until: Time\n    $scope: MetricsScope!\n  ) {\n    workspace(id: $workspaceId) {\n      scheduled: scopedMetrics(\n        filter: {\n          name: \"function_run_scheduled_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      started: scopedMetrics(\n        filter: {\n          name: \"function_run_started_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      completed: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: $scope\n          groupBy: \"status\"\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      completedByFunction: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: FN\n          groupBy: \"status\"\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      totals: scopedFunctionStatus(\n        filter: {\n          name: \"function_run_scheduled_total\"\n          scope: FN\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        queued\n        running\n        completed\n        failed\n        cancelled\n        cancelled\n        skipped\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query VolumeMetrics(\n    $workspaceId: ID!\n    $from: Time!\n    $functionIDs: [UUID!]\n    $appIDs: [UUID!]\n    $until: Time\n    $scope: MetricsScope!\n  ) {\n    accountConcurrency: metrics(\n      opts: { name: \"steps_running\", from: $from, to: $until }\n    ) {\n      data {\n        bucket\n        value\n      }\n      from\n      to\n      granularity\n    }\n\n    workspace(id: $workspaceId) {\n      runsThroughput: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputEnded: scopedMetrics(\n        filter: {\n          name: \"sdk_req_ended_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputStarted: scopedMetrics(\n        filter: {\n          name: \"sdk_req_started_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputScheduled: scopedMetrics(\n        filter: {\n          name: \"sdk_req_scheduled_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      stepThroughput: scopedMetrics(\n        filter: {\n          name: \"steps_running\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      backlog: scopedMetrics(\n        filter: {\n          name: \"steps_scheduled\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      stepRunning: scopedMetrics(\n        filter: {\n          name: \"steps_running\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      concurrency: scopedMetrics(\n        filter: {\n          name: \"concurrency_limit_reached_total\"\n          scope: $scope\n          from: $from\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query VolumeMetrics(\n    $workspaceId: ID!\n    $from: Time!\n    $functionIDs: [UUID!]\n    $appIDs: [UUID!]\n    $until: Time\n    $scope: MetricsScope!\n  ) {\n    accountConcurrency: metrics(\n      opts: { name: \"steps_running\", from: $from, to: $until }\n    ) {\n      data {\n        bucket\n        value\n      }\n      from\n      to\n      granularity\n    }\n\n    workspace(id: $workspaceId) {\n      runsThroughput: scopedMetrics(\n        filter: {\n          name: \"function_run_ended_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputEnded: scopedMetrics(\n        filter: {\n          name: \"sdk_req_ended_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputStarted: scopedMetrics(\n        filter: {\n          name: \"sdk_req_started_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      sdkThroughputScheduled: scopedMetrics(\n        filter: {\n          name: \"sdk_req_scheduled_total\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      stepThroughput: scopedMetrics(\n        filter: {\n          name: \"steps_running\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      backlog: scopedMetrics(\n        filter: {\n          name: \"steps_scheduled\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      stepRunning: scopedMetrics(\n        filter: {\n          name: \"steps_running\"\n          scope: $scope\n          from: $from\n          functionIDs: $functionIDs\n          appIDs: $appIDs\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n    workspace(id: $workspaceId) {\n      concurrency: scopedMetrics(\n        filter: {\n          name: \"concurrency_limit_reached_total\"\n          scope: $scope\n          from: $from\n          until: $until\n        }\n      ) {\n        metrics {\n          id\n          tagName\n          tagValue\n          data {\n            value\n            bucket\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query QuickSearch($term: String!, $envSlug: String!) {\n    account {\n      quickSearch(term: $term, envSlug: $envSlug) {\n        apps {\n          name\n        }\n        event {\n          envSlug\n          id\n          name\n        }\n        eventTypes {\n          name\n        }\n        functions {\n          name\n          slug\n        }\n        run {\n          envSlug\n          id\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query QuickSearch($term: String!, $envSlug: String!) {\n    account {\n      quickSearch(term: $term, envSlug: $envSlug) {\n        apps {\n          name\n        }\n        event {\n          envSlug\n          id\n          name\n        }\n        eventTypes {\n          name\n        }\n        functions {\n          name\n          slug\n        }\n        run {\n          envSlug\n          id\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation SyncOnboardingApp($appURL: String!, $envID: UUID!) {\n    syncNewApp(appURL: $appURL, envID: $envID) {\n      app {\n        externalID\n        id\n      }\n      error {\n        code\n        data\n        message\n      }\n    }\n  }\n"): (typeof documents)["\n  mutation SyncOnboardingApp($appURL: String!, $envID: UUID!) {\n    syncNewApp(appURL: $appURL, envID: $envID) {\n      app {\n        externalID\n        id\n      }\n      error {\n        code\n        data\n        message\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation InvokeFunctionOnboarding(\n    $envID: UUID!\n    $data: Map\n    $functionSlug: String!\n    $user: Map\n  ) {\n    invokeFunction(\n      envID: $envID\n      data: $data\n      functionSlug: $functionSlug\n      user: $user\n    )\n  }\n"): (typeof documents)["\n  mutation InvokeFunctionOnboarding(\n    $envID: UUID!\n    $data: Map\n    $functionSlug: String!\n    $user: Map\n  ) {\n    invokeFunction(\n      envID: $envID\n      data: $data\n      functionSlug: $functionSlug\n      user: $user\n    )\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query InvokeFunctionLookup($envSlug: String!, $page: Int, $pageSize: Int) {\n    envBySlug(slug: $envSlug) {\n      workflows @paginated(perPage: $pageSize, page: $page) {\n        data {\n          name\n          id\n          slug\n          triggers {\n            type\n            value\n          }\n        }\n        page {\n          page\n          totalPages\n          perPage\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query InvokeFunctionLookup($envSlug: String!, $page: Int, $pageSize: Int) {\n    envBySlug(slug: $envSlug) {\n      workflows @paginated(perPage: $pageSize, page: $page) {\n        data {\n          name\n          id\n          slug\n          triggers {\n            type\n            value\n          }\n        }\n        page {\n          page\n          totalPages\n          perPage\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetVercelApps($envID: ID!) {\n    environment: workspace(id: $envID) {\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n        error\n        url\n        vercelDeploymentURL\n      }\n      apps {\n        id\n        name\n        externalID\n        isArchived\n        latestSync {\n          error\n          id\n          platform\n          vercelDeploymentID\n          vercelProjectID\n          status\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetVercelApps($envID: ID!) {\n    environment: workspace(id: $envID) {\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n        error\n        url\n        vercelDeploymentURL\n      }\n      apps {\n        id\n        name\n        externalID\n        isArchived\n        latestSync {\n          error\n          id\n          platform\n          vercelDeploymentID\n          vercelProjectID\n          status\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query ProductionApps($envID: ID!) {\n    environment: workspace(id: $envID) {\n      apps {\n        id\n      }\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n      }\n    }\n  }\n"): (typeof documents)["\n  query ProductionApps($envID: ID!) {\n    environment: workspace(id: $envID) {\n      apps {\n        id\n      }\n      unattachedSyncs(first: 1) {\n        lastSyncedAt\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetRunTraceTrigger($envID: ID!, $runID: String!) {\n    workspace(id: $envID) {\n      runTrigger(runID: $runID) {\n        IDs\n        payloads\n        timestamp\n        eventName\n        isBatch\n        batchID\n        cron\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetRunTraceTrigger($envID: ID!, $runID: String!) {\n    workspace(id: $envID) {\n      runTrigger(runID: $runID) {\n        IDs\n        payloads\n        timestamp\n        eventName\n        isBatch\n        batchID\n        cron\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetRuns(\n    $appIDs: [UUID!]\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time\n    $status: [FunctionRunStatus!]\n    $timeField: RunsOrderByField!\n    $functionSlug: String\n    $functionRunCursor: String = null\n    $celQuery: String = null\n    $preview: Boolean = false\n  ) {\n    environment: workspace(id: $environmentID) {\n      runs(\n        filter: {\n          appIDs: $appIDs\n          from: $startTime\n          until: $endTime\n          status: $status\n          timeField: $timeField\n          fnSlug: $functionSlug\n          query: $celQuery\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n        after: $functionRunCursor\n        preview: $preview\n      ) {\n        edges {\n          node {\n            app {\n              externalID\n              name\n            }\n            cronSchedule\n            eventName\n            function {\n              name\n              slug\n            }\n            id\n            isBatch\n            queuedAt\n            endedAt\n            startedAt\n            status\n            hasAI\n          }\n        }\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          startCursor\n          endCursor\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetRuns(\n    $appIDs: [UUID!]\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time\n    $status: [FunctionRunStatus!]\n    $timeField: RunsOrderByField!\n    $functionSlug: String\n    $functionRunCursor: String = null\n    $celQuery: String = null\n    $preview: Boolean = false\n  ) {\n    environment: workspace(id: $environmentID) {\n      runs(\n        filter: {\n          appIDs: $appIDs\n          from: $startTime\n          until: $endTime\n          status: $status\n          timeField: $timeField\n          fnSlug: $functionSlug\n          query: $celQuery\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n        after: $functionRunCursor\n        preview: $preview\n      ) {\n        edges {\n          node {\n            app {\n              externalID\n              name\n            }\n            cronSchedule\n            eventName\n            function {\n              name\n              slug\n            }\n            id\n            isBatch\n            queuedAt\n            endedAt\n            startedAt\n            status\n            hasAI\n          }\n        }\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          startCursor\n          endCursor\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query CountRuns(\n    $appIDs: [UUID!]\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time\n    $status: [FunctionRunStatus!]\n    $timeField: RunsOrderByField!\n    $functionSlug: String\n    $celQuery: String = null\n  ) {\n    environment: workspace(id: $environmentID) {\n      runs(\n        filter: {\n          appIDs: $appIDs\n          from: $startTime\n          until: $endTime\n          status: $status\n          timeField: $timeField\n          fnSlug: $functionSlug\n          query: $celQuery\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n      ) {\n        totalCount\n      }\n    }\n  }\n"): (typeof documents)["\n  query CountRuns(\n    $appIDs: [UUID!]\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time\n    $status: [FunctionRunStatus!]\n    $timeField: RunsOrderByField!\n    $functionSlug: String\n    $celQuery: String = null\n  ) {\n    environment: workspace(id: $environmentID) {\n      runs(\n        filter: {\n          appIDs: $appIDs\n          from: $startTime\n          until: $endTime\n          status: $status\n          timeField: $timeField\n          fnSlug: $functionSlug\n          query: $celQuery\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n      ) {\n        totalCount\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query AppFilter($envSlug: String!) {\n    env: envBySlug(slug: $envSlug) {\n      apps {\n        externalID\n        id\n        name\n      }\n    }\n  }\n"): (typeof documents)["\n  query AppFilter($envSlug: String!) {\n    env: envBySlug(slug: $envSlug) {\n      apps {\n        externalID\n        id\n        name\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetWorkerConnections(\n    $envID: ID!\n    $appID: UUID!\n    $startTime: Time\n    $status: [ConnectV1ConnectionStatus!]\n    $timeField: ConnectV1WorkerConnectionsOrderByField!\n    $cursor: String = null\n    $orderBy: [ConnectV1WorkerConnectionsOrderBy!] = []\n    $first: Int!\n  ) {\n    environment: workspace(id: $envID) {\n      workerConnections(\n        first: $first\n        filter: {\n          appIDs: [$appID]\n          from: $startTime\n          status: $status\n          timeField: $timeField\n        }\n        orderBy: $orderBy\n        after: $cursor\n      ) {\n        edges {\n          node {\n            id\n            gatewayId\n            instanceID: instanceId\n            workerIp\n            app {\n              id\n            }\n            connectedAt\n            lastHeartbeatAt\n            disconnectedAt\n            disconnectReason\n            status\n            sdkLang\n            sdkVersion\n            sdkPlatform\n            appVersion\n            functionCount\n            cpuCores\n            memBytes\n            os\n          }\n        }\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          startCursor\n          endCursor\n        }\n        totalCount\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetWorkerConnections(\n    $envID: ID!\n    $appID: UUID!\n    $startTime: Time\n    $status: [ConnectV1ConnectionStatus!]\n    $timeField: ConnectV1WorkerConnectionsOrderByField!\n    $cursor: String = null\n    $orderBy: [ConnectV1WorkerConnectionsOrderBy!] = []\n    $first: Int!\n  ) {\n    environment: workspace(id: $envID) {\n      workerConnections(\n        first: $first\n        filter: {\n          appIDs: [$appID]\n          from: $startTime\n          status: $status\n          timeField: $timeField\n        }\n        orderBy: $orderBy\n        after: $cursor\n      ) {\n        edges {\n          node {\n            id\n            gatewayId\n            instanceID: instanceId\n            workerIp\n            app {\n              id\n            }\n            connectedAt\n            lastHeartbeatAt\n            disconnectedAt\n            disconnectReason\n            status\n            sdkLang\n            sdkVersion\n            sdkPlatform\n            appVersion\n            functionCount\n            cpuCores\n            memBytes\n            os\n          }\n        }\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          startCursor\n          endCursor\n        }\n        totalCount\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetWorkerCountConnections(\n    $envID: ID!\n    $appID: UUID!\n    $startTime: Time\n    $status: [ConnectV1ConnectionStatus!] = []\n    $timeField: ConnectV1WorkerConnectionsOrderByField!\n  ) {\n    environment: workspace(id: $envID) {\n      workerConnections(\n        filter: {\n          appIDs: [$appID]\n          from: $startTime\n          status: $status\n          timeField: $timeField\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n      ) {\n        totalCount\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetWorkerCountConnections(\n    $envID: ID!\n    $appID: UUID!\n    $startTime: Time\n    $status: [ConnectV1ConnectionStatus!] = []\n    $timeField: ConnectV1WorkerConnectionsOrderByField!\n  ) {\n    environment: workspace(id: $envID) {\n      workerConnections(\n        filter: {\n          appIDs: [$appID]\n          from: $startTime\n          status: $status\n          timeField: $timeField\n        }\n        orderBy: [{ field: $timeField, direction: DESC }]\n      ) {\n        totalCount\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetDeployss($environmentID: ID!) {\n    deploys(workspaceID: $environmentID) {\n      id\n      appName\n      authorID\n      checksum\n      createdAt\n      error\n      framework\n      metadata\n      sdkLanguage\n      sdkVersion\n      status\n\n      deployedFunctions {\n        id\n        name\n      }\n\n      removedFunctions {\n        id\n        name\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetDeployss($environmentID: ID!) {\n    deploys(workspaceID: $environmentID) {\n      id\n      appName\n      authorID\n      checksum\n      createdAt\n      error\n      framework\n      metadata\n      sdkLanguage\n      sdkVersion\n      status\n\n      deployedFunctions {\n        id\n        name\n      }\n\n      removedFunctions {\n        id\n        name\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEnvironments {\n    workspaces {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      webhookSigningKey\n      createdAt\n      isArchived\n      isAutoArchiveEnabled\n      lastDeployedAt\n    }\n  }\n"): (typeof documents)["\n  query GetEnvironments {\n    workspaces {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      webhookSigningKey\n      createdAt\n      isArchived\n      isAutoArchiveEnabled\n      lastDeployedAt\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEnvironmentBySlug($slug: String!) {\n    envBySlug(slug: $slug) {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n      webhookSigningKey\n    }\n  }\n"): (typeof documents)["\n  query GetEnvironmentBySlug($slug: String!) {\n    envBySlug(slug: $slug) {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n      webhookSigningKey\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetDefaultEnvironment {\n    defaultEnv {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n    }\n  }\n"): (typeof documents)["\n  query GetDefaultEnvironment {\n    defaultEnv {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetFunctionsUsage(\n    $environmentID: ID!\n    $page: Int\n    $archived: Boolean\n    $pageSize: Int\n  ) {\n    workspace(id: $environmentID) {\n      workflows(archived: $archived)\n        @paginated(perPage: $pageSize, page: $page) {\n        page {\n          page\n          perPage\n          totalItems\n          totalPages\n        }\n        data {\n          id\n          slug\n          dailyStarts: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"started\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyCompleted: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"completed\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyCancelled: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"cancelled\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyFailures: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"errored\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetFunctionsUsage(\n    $environmentID: ID!\n    $page: Int\n    $archived: Boolean\n    $pageSize: Int\n  ) {\n    workspace(id: $environmentID) {\n      workflows(archived: $archived)\n        @paginated(perPage: $pageSize, page: $page) {\n        page {\n          page\n          perPage\n          totalItems\n          totalPages\n        }\n        data {\n          id\n          slug\n          dailyStarts: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"started\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyCompleted: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"completed\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyCancelled: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"cancelled\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n          dailyFailures: usage(\n            opts: { period: \"hour\", range: \"day\" }\n            event: \"errored\"\n          ) {\n            total\n            data {\n              count\n            }\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetFunctions(\n    $environmentID: ID!\n    $page: Int\n    $archived: Boolean\n    $search: String\n    $pageSize: Int\n  ) {\n    workspace(id: $environmentID) {\n      workflows(archived: $archived, search: $search)\n        @paginated(perPage: $pageSize, page: $page) {\n        page {\n          page\n          perPage\n          totalItems\n          totalPages\n        }\n        data {\n          app {\n            name\n            externalID\n          }\n          id\n          slug\n          name\n          isPaused\n          isArchived\n          triggers {\n            type\n            value\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetFunctions(\n    $environmentID: ID!\n    $page: Int\n    $archived: Boolean\n    $search: String\n    $pageSize: Int\n  ) {\n    workspace(id: $environmentID) {\n      workflows(archived: $archived, search: $search)\n        @paginated(perPage: $pageSize, page: $page) {\n        page {\n          page\n          perPage\n          totalItems\n          totalPages\n        }\n        data {\n          app {\n            name\n            externalID\n          }\n          id\n          slug\n          name\n          isPaused\n          isArchived\n          triggers {\n            type\n            value\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetFunction($slug: String!, $environmentID: ID!) {\n    workspace(id: $environmentID) {\n      id\n      workflow: workflowBySlug(slug: $slug) {\n        id\n        name\n        slug\n        isPaused\n        isArchived\n        app {\n          externalID\n          name\n          latestSync {\n            lastSyncedAt\n          }\n        }\n        triggers {\n          type\n          value\n          condition\n        }\n        failureHandler {\n          slug\n          name\n        }\n        configuration {\n          cancellations {\n            event\n            timeout\n            condition\n          }\n          retries {\n            value\n            isDefault\n          }\n          priority\n          eventsBatch {\n            maxSize\n            timeout\n            key\n          }\n          concurrency {\n            scope\n            limit {\n              value\n              isPlanLimit\n            }\n            key\n          }\n          rateLimit {\n            limit\n            period\n            key\n          }\n          debounce {\n            period\n            key\n          }\n          throttle {\n            burst\n            key\n            limit\n            period\n          }\n          singleton {\n            key\n            mode\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetFunction($slug: String!, $environmentID: ID!) {\n    workspace(id: $environmentID) {\n      id\n      workflow: workflowBySlug(slug: $slug) {\n        id\n        name\n        slug\n        isPaused\n        isArchived\n        app {\n          externalID\n          name\n          latestSync {\n            lastSyncedAt\n          }\n        }\n        triggers {\n          type\n          value\n          condition\n        }\n        failureHandler {\n          slug\n          name\n        }\n        configuration {\n          cancellations {\n            event\n            timeout\n            condition\n          }\n          retries {\n            value\n            isDefault\n          }\n          priority\n          eventsBatch {\n            maxSize\n            timeout\n            key\n          }\n          concurrency {\n            scope\n            limit {\n              value\n              isPlanLimit\n            }\n            key\n          }\n          rateLimit {\n            limit\n            period\n            key\n          }\n          debounce {\n            period\n            key\n          }\n          throttle {\n            burst\n            key\n            limit\n            period\n          }\n          singleton {\n            key\n            mode\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetFunctionUsage(\n    $id: ID!\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time!\n  ) {\n    workspace(id: $environmentID) {\n      workflow(id: $id) {\n        dailyStarts: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"started\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyCancelled: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"cancelled\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyCompleted: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"completed\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyFailures: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"errored\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetFunctionUsage(\n    $id: ID!\n    $environmentID: ID!\n    $startTime: Time!\n    $endTime: Time!\n  ) {\n    workspace(id: $environmentID) {\n      workflow(id: $id) {\n        dailyStarts: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"started\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyCancelled: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"cancelled\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyCompleted: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"completed\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n        dailyFailures: usage(\n          opts: { from: $startTime, to: $endTime }\n          event: \"errored\"\n        ) {\n          period\n          total\n          data {\n            slot\n            count\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetProductionWorkspace {\n    defaultEnv {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n      webhookSigningKey\n    }\n  }\n"): (typeof documents)["\n  query GetProductionWorkspace {\n    defaultEnv {\n      id\n      name\n      slug\n      parentID\n      test\n      type\n      createdAt\n      lastDeployedAt\n      isArchived\n      isAutoArchiveEnabled\n      webhookSigningKey\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query Profile {\n    account {\n      name\n      marketplace\n    }\n  }\n"): (typeof documents)["\n  query Profile {\n    account {\n      name\n      marketplace\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation CancelRun($envID: UUID!, $runID: ULID!) {\n    cancelRun(envID: $envID, runID: $runID) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation CancelRun($envID: UUID!, $runID: ULID!) {\n    cancelRun(envID: $envID, runID: $runID) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetEventKeysForBlankSlate($environmentID: ID!) {\n    environment: workspace(id: $environmentID) {\n      ingestKeys(filter: { source: \"key\" }) {\n        name\n        presharedKey\n        createdAt\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetEventKeysForBlankSlate($environmentID: ID!) {\n    environment: workspace(id: $environmentID) {\n      ingestKeys(filter: { source: \"key\" }) {\n        name\n        presharedKey\n        createdAt\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  fragment TraceDetails on RunTraceSpan {\n    name\n    status\n    attempts\n    queuedAt\n    startedAt\n    endedAt\n    isRoot\n    isUserland\n    userlandSpan {\n      spanName\n      spanKind\n      serviceName\n      scopeName\n      scopeVersion\n      spanAttrs\n      resourceAttrs\n    }\n    outputID\n    stepID\n    spanID\n    stepOp\n    stepType\n    stepInfo {\n      __typename\n      ... on InvokeStepInfo {\n        triggeringEventID\n        functionID\n        timeout\n        returnEventID\n        runID\n        timedOut\n      }\n      ... on SleepStepInfo {\n        sleepUntil\n      }\n      ... on WaitForEventStepInfo {\n        eventName\n        expression\n        timeout\n        foundEventID\n        timedOut\n      }\n    }\n  }\n"): (typeof documents)["\n  fragment TraceDetails on RunTraceSpan {\n    name\n    status\n    attempts\n    queuedAt\n    startedAt\n    endedAt\n    isRoot\n    isUserland\n    userlandSpan {\n      spanName\n      spanKind\n      serviceName\n      scopeName\n      scopeVersion\n      spanAttrs\n      resourceAttrs\n    }\n    outputID\n    stepID\n    spanID\n    stepOp\n    stepType\n    stepInfo {\n      __typename\n      ... on InvokeStepInfo {\n        triggeringEventID\n        functionID\n        timeout\n        returnEventID\n        runID\n        timedOut\n      }\n      ... on SleepStepInfo {\n        sleepUntil\n      }\n      ... on WaitForEventStepInfo {\n        eventName\n        expression\n        timeout\n        foundEventID\n        timedOut\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetRunTrace($envID: ID!, $runID: String!, $preview: Boolean) {\n    workspace(id: $envID) {\n      run(runID: $runID) {\n        function {\n          app {\n            name\n            externalID\n          }\n          id\n          name\n          slug\n        }\n        status\n        trace(preview: $preview) {\n          ...TraceDetails\n          childrenSpans {\n            ...TraceDetails\n            childrenSpans {\n              ...TraceDetails\n              childrenSpans {\n                ...TraceDetails\n                childrenSpans {\n                  ...TraceDetails\n                }\n              }\n            }\n          }\n        }\n        hasAI\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetRunTrace($envID: ID!, $runID: String!, $preview: Boolean) {\n    workspace(id: $envID) {\n      run(runID: $runID) {\n        function {\n          app {\n            name\n            externalID\n          }\n          id\n          name\n          slug\n        }\n        status\n        trace(preview: $preview) {\n          ...TraceDetails\n          childrenSpans {\n            ...TraceDetails\n            childrenSpans {\n              ...TraceDetails\n              childrenSpans {\n                ...TraceDetails\n                childrenSpans {\n                  ...TraceDetails\n                }\n              }\n            }\n          }\n        }\n        hasAI\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query TraceResult($envID: ID!, $traceID: String!) {\n    workspace(id: $envID) {\n      runTraceSpanOutputByID(outputID: $traceID) {\n        data\n        input\n        error {\n          message\n          name\n          stack\n          cause\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query TraceResult($envID: ID!, $traceID: String!) {\n    workspace(id: $envID) {\n      runTraceSpanOutputByID(outputID: $traceID) {\n        data\n        input\n        error {\n          message\n          name\n          stack\n          cause\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation RerunFunctionRun(\n    $environmentID: ID!\n    $functionID: ID!\n    $functionRunID: ULID!\n  ) {\n    retryWorkflowRun(\n      input: { workspaceID: $environmentID, workflowID: $functionID }\n      workflowRunID: $functionRunID\n    ) {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation RerunFunctionRun(\n    $environmentID: ID!\n    $functionID: ID!\n    $functionRunID: ULID!\n  ) {\n    retryWorkflowRun(\n      input: { workspaceID: $environmentID, workflowID: $functionID }\n      workflowRunID: $functionRunID\n    ) {\n      id\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  mutation Rerun($runID: ULID!, $fromStep: RerunFromStepInput) {\n    rerun(runID: $runID, fromStep: $fromStep)\n  }\n"): (typeof documents)["\n  mutation Rerun($runID: ULID!, $fromStep: RerunFromStepInput) {\n    rerun(runID: $runID, fromStep: $fromStep)\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n  query GetAccountEntitlements {\n    account {\n      entitlements {\n        history {\n          limit\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query GetAccountEntitlements {\n    account {\n      entitlements {\n        history {\n          limit\n        }\n      }\n    }\n  }\n"];

export function graphql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;
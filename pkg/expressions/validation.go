package expressions

import (
	"context"
	"fmt"
	"slices"

	"github.com/google/cel-go/cel"
	celops "github.com/google/cel-go/common/operators"
	"github.com/hashicorp/go-multierror"
	celexprpb "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
)

type ValidationPolicy struct {
	DisallowMacros      bool
	DisallowNonLogicFns bool
	AllowDateTimeFns    bool
	AllowMathFns        bool
}

func DefaultRestrictiveValidationPolicy() *ValidationPolicy {
	return &ValidationPolicy{
		// DisallowMacros determines whether CEL macros are allowed.
		DisallowMacros: true,

		// DisallowNonLogicFns determines whether non-logical functions/operators are allowed.
		// Logic functions (conditionals, and/or/not, less/greater than, equals) are always allowed.
		// See the logicFnNames function in validation.go for a detailed list.
		// Indexing and selecting (Index, OptIndex, OptSelect) are always allowed; despite not
		// being strictly logic functions, CEL expressions without them are usually not useful.
		DisallowNonLogicFns: true,

		// AllowDateTimeFns determines whether date/time functions are allowed.
		// This option is only used if DisallowNonLogicFns is true; it adds some functions (date,
		// now_plus, now_minus, duration) to the set of allowed functions.
		// See the dateTimeFnNames function in validation.go for a detailed list.
		// If DisallowNonLogicFns is false, this option has no effect (i.e. all functions are allowed).
		AllowDateTimeFns: false,

		// AllowMathFns determines whether mathematical functions are allowed.
		// This option is only used if DisallowNonLogicFns is true; it adds some functions (e.g. add,
		// multiply, modulo, negate) to the set of allowed functions.
		// See the mathFnNames function in validation.go for a detailed list.
		// If DisallowNonLogicFns is false, this option has no effect (i.e. all functions are allowed).
		AllowMathFns: false,
	}
}

func validationErr(err error) error {
	if err == nil {
		return fmt.Errorf("validation failed")
	}
	return fmt.Errorf("validation failed: %w", err)
}

// Validate calls parse and check on an ASTs using NON CACHING parsing.  This MUST be non-caching
// as calling Check on an AST is not thread safe.
func Validate(_ context.Context, policy *ValidationPolicy, expression string) error {
	// Compile the expression as new.
	env, err := env()
	if err != nil {
		return validationErr(err)
	}

	ast, issues := env.Compile(expression)
	if issues != nil {
		return NewCompileError(issues.Err())
	}

	expr, err := cel.AstToCheckedExpr(ast)
	if err != nil {
		return NewCompileError(err)
	}

	if policy != nil {
		if err = validateAST(policy, expr.GetExpr()); err != nil {
			return validationErr(err)
		}
	}

	return nil
}

// validateAST iterates through an expression AST and checks for policy violations.
//
// It does not short-circuit after a violation is found; the returned error is a
// multierror containing all violations found in the AST.
//
// If the given AST contains errors, the function _will_ short-circuit; the caller
// may receive a single error or a multierror including a partial list of policy
// violations.
func validateAST(policy *ValidationPolicy, expr *celexprpb.Expr) (violations error) {
	switch expr.GetExprKind().(type) {
	case *celexprpb.Expr_ComprehensionExpr:
		// ComprehensionKind represents a comprehension expression generated by a macro.
		thisExp := expr.GetComprehensionExpr()
		if policy.DisallowMacros {
			violations = multierror.Append(violations,
				fmt.Errorf("macros are disallowed (contains '%s')",
					thisExp.String()))
		}
	case *celexprpb.Expr_SelectExpr:
		thisExp := expr.GetSelectExpr()
		if policy.DisallowMacros && thisExp.GetTestOnly() {
			violations = multierror.Append(violations,
				fmt.Errorf("macros are disallowed (uses 'has')"))
		}
		if operandErrs := validateAST(policy, thisExp.GetOperand()); operandErrs != nil {
			violations = multierror.Append(violations, operandErrs)
		}
	case *celexprpb.Expr_CallExpr:
		thisExp := expr.GetCallExpr()
		fnName := thisExp.GetFunction()

		if policy.DisallowMacros && slices.Contains(macroFnNames(), fnName) {
			violations = multierror.Append(violations,
				fmt.Errorf("macros are disallowed (uses '%s')",
					fnName))
		}

		if policy.DisallowNonLogicFns &&
			!slices.Contains(typeConvFnNames(), fnName) &&
			!slices.Contains(logicFnNames(), fnName) {
			if policy.AllowDateTimeFns && slices.Contains(dateTimeFnNames(), fnName) {
				// intentional no-op: this is allowed
			} else if policy.AllowMathFns && slices.Contains(mathFnNames(), fnName) {
				// intentional no-op: this is allowed
			} else {
				violations = multierror.Append(violations,
					fmt.Errorf("function calls are disallowed (uses '%s')",
						fnName))
			}
		}

		args := thisExp.GetArgs()
		for _, arg := range args {
			if argErrs := validateAST(policy, arg); argErrs != nil {
				violations = multierror.Append(violations, argErrs)
			}
		}
	}

	return
}

func macroFnNames() []string {
	return []string{
		celops.Has,
		celops.All,
		celops.Exists,
		celops.ExistsOne,
		celops.Map,
		celops.Filter,
	}
}

func logicFnNames() []string {
	return []string{
		celops.Conditional,
		celops.LogicalAnd,
		celops.LogicalOr,
		celops.LogicalNot,
		celops.Equals,
		celops.NotEquals,
		celops.Less,
		celops.LessEquals,
		celops.Greater,
		celops.GreaterEquals,
		celops.Index,
		celops.OptIndex,
		celops.OptSelect,
	}
}

func mathFnNames() []string {
	return []string{
		celops.Add,
		celops.Subtract,
		celops.Multiply,
		celops.Divide,
		celops.Modulo,
		celops.Negate,
	}
}

func typeConvFnNames() []string {
	return []string{
		"int",
		"uint",
		"double",
	}
}

func dateTimeFnNames() []string {
	return []string{
		"date",
		"now_plus",
		"now_minus",
		"duration",
	}
}

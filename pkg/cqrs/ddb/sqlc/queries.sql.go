// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteApp = `-- name: DeleteApp :exec
UPDATE apps SET deleted_at = NOW() WHERE id = ?
`

func (q *Queries) DeleteApp(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteApp, id)
	return err
}

const getAllApps = `-- name: GetAllApps :many
SELECT id, name, sdk_language, sdk_version, framework, metadata, status, error, checksum, created_at, deleted_at, url FROM apps
`

func (q *Queries) GetAllApps(ctx context.Context) ([]*App, error) {
	rows, err := q.db.QueryContext(ctx, getAllApps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*App
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SdkLanguage,
			&i.SdkVersion,
			&i.Framework,
			&i.Metadata,
			&i.Status,
			&i.Error,
			&i.Checksum,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppByChecksum = `-- name: GetAppByChecksum :one
SELECT id, name, sdk_language, sdk_version, framework, metadata, status, error, checksum, created_at, deleted_at, url FROM apps WHERE checksum = ?
`

func (q *Queries) GetAppByChecksum(ctx context.Context, checksum string) (*App, error) {
	row := q.db.QueryRowContext(ctx, getAppByChecksum, checksum)
	var i App
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SdkLanguage,
		&i.SdkVersion,
		&i.Framework,
		&i.Metadata,
		&i.Status,
		&i.Error,
		&i.Checksum,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Url,
	)
	return &i, err
}

const getAppFunctions = `-- name: GetAppFunctions :many
SELECT id, app_id, name, slug, config, created_at FROM functions WHERE app_id = ?
`

func (q *Queries) GetAppFunctions(ctx context.Context, appID uuid.UUID) ([]*Function, error) {
	rows, err := q.db.QueryContext(ctx, getAppFunctions, appID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Function
	for rows.Next() {
		var i Function
		if err := rows.Scan(
			&i.ID,
			&i.AppID,
			&i.Name,
			&i.Slug,
			&i.Config,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApps = `-- name: GetApps :many
SELECT id, name, sdk_language, sdk_version, framework, metadata, status, error, checksum, created_at, deleted_at, url FROM apps WHERE deleted_at IS NULL
`

func (q *Queries) GetApps(ctx context.Context) ([]*App, error) {
	rows, err := q.db.QueryContext(ctx, getApps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*App
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SdkLanguage,
			&i.SdkVersion,
			&i.Framework,
			&i.Metadata,
			&i.Status,
			&i.Error,
			&i.Checksum,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunctionByID = `-- name: GetFunctionByID :one
SELECT id, app_id, name, slug, config, created_at FROM functions WHERE id = ?
`

func (q *Queries) GetFunctionByID(ctx context.Context, id uuid.UUID) (*Function, error) {
	row := q.db.QueryRowContext(ctx, getFunctionByID, id)
	var i Function
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Name,
		&i.Slug,
		&i.Config,
		&i.CreatedAt,
	)
	return &i, err
}

const getFunctions = `-- name: GetFunctions :many
SELECT id, app_id, name, slug, config, created_at FROM functions
`

func (q *Queries) GetFunctions(ctx context.Context) ([]*Function, error) {
	rows, err := q.db.QueryContext(ctx, getFunctions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Function
	for rows.Next() {
		var i Function
		if err := rows.Scan(
			&i.ID,
			&i.AppID,
			&i.Name,
			&i.Slug,
			&i.Config,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertApp = `-- name: InsertApp :one
INSERT INTO apps
	(id, name, sdk_language, sdk_version, framework, metadata, status, error, checksum, url) VALUES
	(?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, name, sdk_language, sdk_version, framework, metadata, status, error, checksum, created_at, deleted_at, url
`

type InsertAppParams struct {
	ID          uuid.UUID
	Name        string
	SdkLanguage string
	SdkVersion  string
	Framework   sql.NullString
	Metadata    string
	Status      string
	Error       sql.NullString
	Checksum    string
	Url         string
}

func (q *Queries) InsertApp(ctx context.Context, arg InsertAppParams) (*App, error) {
	row := q.db.QueryRowContext(ctx, insertApp,
		arg.ID,
		arg.Name,
		arg.SdkLanguage,
		arg.SdkVersion,
		arg.Framework,
		arg.Metadata,
		arg.Status,
		arg.Error,
		arg.Checksum,
		arg.Url,
	)
	var i App
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SdkLanguage,
		&i.SdkVersion,
		&i.Framework,
		&i.Metadata,
		&i.Status,
		&i.Error,
		&i.Checksum,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Url,
	)
	return &i, err
}

const insertFunction = `-- name: InsertFunction :one
INSERT INTO functions
	(id, app_id, name, slug, config, created_at) VALUES
	(?, ?, ?, ?, ?, ?) RETURNING id, app_id, name, slug, config, created_at
`

type InsertFunctionParams struct {
	ID        uuid.UUID
	AppID     uuid.UUID
	Name      string
	Slug      string
	Config    string
	CreatedAt time.Time
}

// note - this is very basic right now.
func (q *Queries) InsertFunction(ctx context.Context, arg InsertFunctionParams) (*Function, error) {
	row := q.db.QueryRowContext(ctx, insertFunction,
		arg.ID,
		arg.AppID,
		arg.Name,
		arg.Slug,
		arg.Config,
		arg.CreatedAt,
	)
	var i Function
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Name,
		&i.Slug,
		&i.Config,
		&i.CreatedAt,
	)
	return &i, err
}

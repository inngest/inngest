package exechttp

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// SerializableRequest represents an *http.Request which can be serialized
// to JSON, for use with gateways.
//
// NOTE: DO NOT CALL json.Marshal() on this as this will escape special characters
// in the request URL and body.
type SerializableRequest struct {
	// Method specifies the HTTP method (GET, POST, PUT, etc.).
	// For client requests, an empty string means GET.
	Method string

	// Body represents the body used in a request.
	Body json.RawMessage

	// URL specifies either the URI being requested (for server
	// requests) or the URL to access (for client requests).
	//
	// For server requests, the URL is parsed from the URI
	// supplied on the Request-Line as stored in RequestURI.  For
	// most requests, fields other than Path and RawQuery will be
	// empty. (See RFC 7230, Section 5.3)
	//
	// For client requests, the URL's Host specifies the server to
	// connect to, while the Request's Host field optionally
	// specifies the Host header value to send in the HTTP
	// request.
	URL string

	// Header contains the request header fields either received
	// by the server or to be sent by the client.
	//
	// If a server received a request with header lines,
	//
	//	Host: example.com
	//	accept-encoding: gzip, deflate
	//	Accept-Language: en-us
	//	fOO: Bar
	//	foo: two
	//
	// then
	//
	//	Header = map[string][]string{
	//		"Accept-Encoding": {"gzip, deflate"},
	//		"Accept-Language": {"en-us"},
	//		"Foo": {"Bar", "two"},
	//	}
	//
	// For incoming requests, the Host header is promoted to the
	// Request.Host field and removed from the Header map.
	//
	// HTTP defines that header names are case-insensitive. The
	// request parser implements this by using CanonicalHeaderKey,
	// making the first character and any characters following a
	// hyphen uppercase and the rest lowercase.
	//
	// For client requests, certain headers such as Content-Length
	// and Connection are automatically written when needed and
	// values in Header may be ignored. See the documentation
	// for the Request.Write method.
	Header http.Header

	// Publish indicates the optional realtime publish options for this request.
	//
	// If specified, the HTTP response will be tee-read into the specific channel
	// and topic.
	Publish RequestPublishOpts `json:"publish,omitzero"`
}

func NewRequest(method string, url string, body json.RawMessage) (SerializableRequest, error) {
	if !validMethod(method) {
		return SerializableRequest{}, fmt.Errorf("invalid http method: %s", method)
	}
	return SerializableRequest{
		Method: method,
		URL:    url,
		Body:   body,
		Header: http.Header{},
	}, nil
}

// RequestPublishOpts allows requests to be streamed directly from the SDKGateway to
// to realtime topics, byte for byte as they're read from the response.
//
// This is necessary for streaming AI responses to frontends as they're received.
type RequestPublishOpts struct {
	// Channel is the channel that we publish to.
	Channel string `json:"channel"`
	// Topic is the topic that we publish to.
	Topic string `json:"topic"`
	// Token is an auth token used for publishing.  This is generated by the executor
	// and allows the SDKGateways to be stateless and authless.
	Token string `json:"token"`
	// PublishURL is the URL of the publish API.
	PublishURL string `json:"publishURL"`
	// RequestID is metadata attached to the request.  This is typically the step
	// ID, and allows us to tie together requests from the frontned if multiple
	// step requests are happening in parallel.
	RequestID string `json:"requestID"`
}

func (r RequestPublishOpts) ShouldPublish() bool {
	return r.Channel != "" && r.Topic != "" && r.Token != "" && r.PublishURL != ""
}

// Bytes returns a reader for the marshaled serialized request without escaping special characters
func (s SerializableRequest) Bytes() (io.Reader, error) {
	buf := bytes.Buffer{}
	e := json.NewEncoder(&buf)
	e.SetEscapeHTML(false)
	err := e.Encode(s)
	if err != nil {
		return nil, err
	}

	// Remove the trailing newline
	if buf.Len() > 0 && buf.Bytes()[buf.Len()-1] == '\n' {
		buf.Truncate(buf.Len() - 1)
	}

	return &buf, nil
}

// JSON returns the marshaled serialized request as bytes without escaping special characters
func (s SerializableRequest) JSON() ([]byte, error) {
	reader, err := s.Bytes()
	if err != nil {
		return nil, err
	}

	return io.ReadAll(reader)
}

// HTTPRequest converts the serializable request into a *http.Request ready to be sent
func (s SerializableRequest) HTTPRequest() (*http.Request, error) {
	var body io.Reader
	if len(s.Body) > 0 {
		// NOTE: The body is already valid JSON and must be sent off without marshaling again (passthrough)
		body = bytes.NewBuffer(s.Body)
	}

	req, err := http.NewRequest(s.Method, s.URL, body)
	if err != nil {
		return nil, err
	}

	// Set GetBody so that CheckRedirect can re-read the body on redirects.
	// Without this, the body is lost when following redirects (e.g. on Modal).
	if len(s.Body) > 0 {
		bodyBytes := s.Body
		req.GetBody = func() (io.ReadCloser, error) {
			return io.NopCloser(bytes.NewBuffer(bodyBytes)), nil
		}
	}

	req.Header = s.Header
	// Always close the request after reading the body, ensuring the connection is not recycled.
	req.Close = true
	req.Header.Add("user-agent", "Inngest")
	return req, nil
}

func validMethod(r string) bool {
	return r == http.MethodGet ||
		r == http.MethodHead ||
		r == http.MethodPost ||
		r == http.MethodPut ||
		r == http.MethodPatch ||
		r == http.MethodDelete ||
		r == http.MethodConnect ||
		r == http.MethodOptions ||
		r == http.MethodTrace
}

// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/google/uuid"
	"github.com/inngest/inngest/pkg/coreapi/graph/models"
	"github.com/inngest/inngest/pkg/cqrs"
	"github.com/inngest/inngest/pkg/enums"
	"github.com/inngest/inngest/pkg/function"
	types "github.com/inngest/inngest/pkg/gql_scalars"
	"github.com/inngest/inngest/pkg/history_reader"
	ulid "github.com/oklog/ulid/v2"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	App() AppResolver
	Event() EventResolver
	Function() FunctionResolver
	FunctionRun() FunctionRunResolver
	FunctionRunV2() FunctionRunV2Resolver
	Mutation() MutationResolver
	Query() QueryResolver
	RunsV2Connection() RunsV2ConnectionResolver
	StreamItem() StreamItemResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	App struct {
		Autodiscovered func(childComplexity int) int
		Checksum       func(childComplexity int) int
		Connected      func(childComplexity int) int
		Error          func(childComplexity int) int
		ExternalID     func(childComplexity int) int
		Framework      func(childComplexity int) int
		FunctionCount  func(childComplexity int) int
		Functions      func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
		SdkLanguage    func(childComplexity int) int
		SdkVersion     func(childComplexity int) int
		Url            func(childComplexity int) int
	}

	Event struct {
		CreatedAt    func(childComplexity int) int
		ExternalID   func(childComplexity int) int
		FunctionRuns func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Payload      func(childComplexity int) int
		PendingRuns  func(childComplexity int) int
		Raw          func(childComplexity int) int
		Schema       func(childComplexity int) int
		Status       func(childComplexity int) int
		TotalRuns    func(childComplexity int) int
		Workspace    func(childComplexity int) int
	}

	Function struct {
		App         func(childComplexity int) int
		AppID       func(childComplexity int) int
		Concurrency func(childComplexity int) int
		Config      func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Slug        func(childComplexity int) int
		Triggers    func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	FunctionEvent struct {
		CreatedAt   func(childComplexity int) int
		FunctionRun func(childComplexity int) int
		Output      func(childComplexity int) int
		Type        func(childComplexity int) int
		Workspace   func(childComplexity int) int
	}

	FunctionRun struct {
		BatchCreatedAt    func(childComplexity int) int
		BatchID           func(childComplexity int) int
		Cron              func(childComplexity int) int
		Event             func(childComplexity int) int
		EventID           func(childComplexity int) int
		Events            func(childComplexity int) int
		FinishedAt        func(childComplexity int) int
		Function          func(childComplexity int) int
		FunctionID        func(childComplexity int) int
		History           func(childComplexity int) int
		HistoryItemOutput func(childComplexity int, id ulid.ULID) int
		ID                func(childComplexity int) int
		Output            func(childComplexity int) int
		PendingSteps      func(childComplexity int) int
		StartedAt         func(childComplexity int) int
		Status            func(childComplexity int) int
		WaitingFor        func(childComplexity int) int
		Workspace         func(childComplexity int) int
	}

	FunctionRunV2 struct {
		App            func(childComplexity int) int
		AppID          func(childComplexity int) int
		BatchCreatedAt func(childComplexity int) int
		CronSchedule   func(childComplexity int) int
		EndedAt        func(childComplexity int) int
		EventName      func(childComplexity int) int
		Function       func(childComplexity int) int
		FunctionID     func(childComplexity int) int
		ID             func(childComplexity int) int
		IsBatch        func(childComplexity int) int
		Output         func(childComplexity int) int
		QueuedAt       func(childComplexity int) int
		SourceID       func(childComplexity int) int
		StartedAt      func(childComplexity int) int
		Status         func(childComplexity int) int
		Trace          func(childComplexity int) int
		TraceID        func(childComplexity int) int
		TriggerIDs     func(childComplexity int) int
	}

	FunctionRunV2Edge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	FunctionTrigger struct {
		Type  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	FunctionVersion struct {
		Config     func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		FunctionID func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
		ValidFrom  func(childComplexity int) int
		ValidTo    func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	InvokeStepInfo struct {
		FunctionID        func(childComplexity int) int
		ReturnEventID     func(childComplexity int) int
		RunID             func(childComplexity int) int
		TimedOut          func(childComplexity int) int
		Timeout           func(childComplexity int) int
		TriggeringEventID func(childComplexity int) int
	}

	Mutation struct {
		CancelRun       func(childComplexity int, runID ulid.ULID) int
		CreateApp       func(childComplexity int, input models.CreateAppInput) int
		DeleteApp       func(childComplexity int, id string) int
		DeleteAppByName func(childComplexity int, name string) int
		InvokeFunction  func(childComplexity int, data map[string]interface{}, functionSlug string, user map[string]interface{}) int
		Rerun           func(childComplexity int, runID ulid.ULID, fromStep *models.RerunFromStepInput) int
		UpdateApp       func(childComplexity int, input models.UpdateAppInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Apps                   func(childComplexity int) int
		Event                  func(childComplexity int, query models.EventQuery) int
		Events                 func(childComplexity int, query models.EventsQuery) int
		FunctionRun            func(childComplexity int, query models.FunctionRunQuery) int
		Functions              func(childComplexity int) int
		Run                    func(childComplexity int, runID string) int
		RunTraceSpanOutputByID func(childComplexity int, outputID string) int
		RunTrigger             func(childComplexity int, runID string) int
		Runs                   func(childComplexity int, first int, after *string, orderBy []*models.RunsV2OrderBy, filter models.RunsFilterV2) int
		Stream                 func(childComplexity int, query models.StreamQuery) int
	}

	RunHistoryCancel struct {
		EventID    func(childComplexity int) int
		Expression func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	RunHistoryInvokeFunction struct {
		CorrelationID func(childComplexity int) int
		EventID       func(childComplexity int) int
		FunctionID    func(childComplexity int) int
		Timeout       func(childComplexity int) int
	}

	RunHistoryInvokeFunctionResult struct {
		EventID func(childComplexity int) int
		RunID   func(childComplexity int) int
		Timeout func(childComplexity int) int
	}

	RunHistoryItem struct {
		Attempt              func(childComplexity int) int
		Cancel               func(childComplexity int) int
		CreatedAt            func(childComplexity int) int
		FunctionVersion      func(childComplexity int) int
		GroupID              func(childComplexity int) int
		ID                   func(childComplexity int) int
		InvokeFunction       func(childComplexity int) int
		InvokeFunctionResult func(childComplexity int) int
		Result               func(childComplexity int) int
		Sleep                func(childComplexity int) int
		StepName             func(childComplexity int) int
		StepType             func(childComplexity int) int
		Type                 func(childComplexity int) int
		URL                  func(childComplexity int) int
		WaitForEvent         func(childComplexity int) int
		WaitResult           func(childComplexity int) int
	}

	RunHistoryResult struct {
		DurationMS  func(childComplexity int) int
		ErrorCode   func(childComplexity int) int
		Framework   func(childComplexity int) int
		Platform    func(childComplexity int) int
		SDKLanguage func(childComplexity int) int
		SDKVersion  func(childComplexity int) int
		SizeBytes   func(childComplexity int) int
	}

	RunHistorySleep struct {
		Until func(childComplexity int) int
	}

	RunHistoryWaitForEvent struct {
		EventName  func(childComplexity int) int
		Expression func(childComplexity int) int
		Timeout    func(childComplexity int) int
	}

	RunHistoryWaitResult struct {
		EventID func(childComplexity int) int
		Timeout func(childComplexity int) int
	}

	RunStepInfo struct {
		Type func(childComplexity int) int
	}

	RunTraceSpan struct {
		AppID         func(childComplexity int) int
		Attempts      func(childComplexity int) int
		ChildrenSpans func(childComplexity int) int
		Duration      func(childComplexity int) int
		EndedAt       func(childComplexity int) int
		FunctionID    func(childComplexity int) int
		IsRoot        func(childComplexity int) int
		Name          func(childComplexity int) int
		OutputID      func(childComplexity int) int
		ParentSpan    func(childComplexity int) int
		ParentSpanID  func(childComplexity int) int
		QueuedAt      func(childComplexity int) int
		Run           func(childComplexity int) int
		RunID         func(childComplexity int) int
		SpanID        func(childComplexity int) int
		StartedAt     func(childComplexity int) int
		Status        func(childComplexity int) int
		StepID        func(childComplexity int) int
		StepInfo      func(childComplexity int) int
		StepOp        func(childComplexity int) int
		TraceID       func(childComplexity int) int
	}

	RunTraceSpanOutput struct {
		Data  func(childComplexity int) int
		Error func(childComplexity int) int
		Input func(childComplexity int) int
	}

	RunTraceTrigger struct {
		BatchID   func(childComplexity int) int
		Cron      func(childComplexity int) int
		EventName func(childComplexity int) int
		IDs       func(childComplexity int) int
		IsBatch   func(childComplexity int) int
		Payloads  func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	RunsV2Connection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SleepStepInfo struct {
		SleepUntil func(childComplexity int) int
	}

	StepError struct {
		Message func(childComplexity int) int
		Name    func(childComplexity int) int
		Stack   func(childComplexity int) int
	}

	StepEvent struct {
		CreatedAt   func(childComplexity int) int
		FunctionRun func(childComplexity int) int
		Name        func(childComplexity int) int
		Output      func(childComplexity int) int
		StepID      func(childComplexity int) int
		Type        func(childComplexity int) int
		WaitingFor  func(childComplexity int) int
		Workspace   func(childComplexity int) int
	}

	StepEventWait struct {
		EventName  func(childComplexity int) int
		ExpiryTime func(childComplexity int) int
		Expression func(childComplexity int) int
	}

	StreamItem struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		InBatch   func(childComplexity int) int
		Runs      func(childComplexity int) int
		Trigger   func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	WaitForEventStepInfo struct {
		EventName    func(childComplexity int) int
		Expression   func(childComplexity int) int
		FoundEventID func(childComplexity int) int
		TimedOut     func(childComplexity int) int
		Timeout      func(childComplexity int) int
	}

	Workspace struct {
		ID func(childComplexity int) int
	}
}

type AppResolver interface {
	ID(ctx context.Context, obj *cqrs.App) (string, error)
	ExternalID(ctx context.Context, obj *cqrs.App) (string, error)

	Framework(ctx context.Context, obj *cqrs.App) (*string, error)

	Error(ctx context.Context, obj *cqrs.App) (*string, error)
	Functions(ctx context.Context, obj *cqrs.App) ([]*models.Function, error)
	Connected(ctx context.Context, obj *cqrs.App) (bool, error)
	FunctionCount(ctx context.Context, obj *cqrs.App) (int, error)
	Autodiscovered(ctx context.Context, obj *cqrs.App) (bool, error)
}
type EventResolver interface {
	Status(ctx context.Context, obj *models.Event) (*models.EventStatus, error)
	PendingRuns(ctx context.Context, obj *models.Event) (*int, error)
	TotalRuns(ctx context.Context, obj *models.Event) (*int, error)
	Raw(ctx context.Context, obj *models.Event) (*string, error)
	FunctionRuns(ctx context.Context, obj *models.Event) ([]*models.FunctionRun, error)
}
type FunctionResolver interface {
	App(ctx context.Context, obj *models.Function) (*cqrs.App, error)
}
type FunctionRunResolver interface {
	Function(ctx context.Context, obj *models.FunctionRun) (*models.Function, error)

	Event(ctx context.Context, obj *models.FunctionRun) (*models.Event, error)
	Events(ctx context.Context, obj *models.FunctionRun) ([]*models.Event, error)

	BatchCreatedAt(ctx context.Context, obj *models.FunctionRun) (*time.Time, error)

	WaitingFor(ctx context.Context, obj *models.FunctionRun) (*models.StepEventWait, error)
	PendingSteps(ctx context.Context, obj *models.FunctionRun) (*int, error)

	History(ctx context.Context, obj *models.FunctionRun) ([]*history_reader.RunHistory, error)
	HistoryItemOutput(ctx context.Context, obj *models.FunctionRun, id ulid.ULID) (*string, error)
}
type FunctionRunV2Resolver interface {
	App(ctx context.Context, obj *models.FunctionRunV2) (*cqrs.App, error)

	Function(ctx context.Context, obj *models.FunctionRunV2) (*models.Function, error)

	Trace(ctx context.Context, obj *models.FunctionRunV2) (*models.RunTraceSpan, error)
}
type MutationResolver interface {
	CreateApp(ctx context.Context, input models.CreateAppInput) (*cqrs.App, error)
	UpdateApp(ctx context.Context, input models.UpdateAppInput) (*cqrs.App, error)
	DeleteApp(ctx context.Context, id string) (string, error)
	DeleteAppByName(ctx context.Context, name string) (bool, error)
	InvokeFunction(ctx context.Context, data map[string]interface{}, functionSlug string, user map[string]interface{}) (*bool, error)
	CancelRun(ctx context.Context, runID ulid.ULID) (*models.FunctionRun, error)
	Rerun(ctx context.Context, runID ulid.ULID, fromStep *models.RerunFromStepInput) (ulid.ULID, error)
}
type QueryResolver interface {
	Apps(ctx context.Context) ([]*cqrs.App, error)
	Stream(ctx context.Context, query models.StreamQuery) ([]*models.StreamItem, error)
	Event(ctx context.Context, query models.EventQuery) (*models.Event, error)
	Events(ctx context.Context, query models.EventsQuery) ([]*models.Event, error)
	Functions(ctx context.Context) ([]*models.Function, error)
	FunctionRun(ctx context.Context, query models.FunctionRunQuery) (*models.FunctionRun, error)
	Runs(ctx context.Context, first int, after *string, orderBy []*models.RunsV2OrderBy, filter models.RunsFilterV2) (*models.RunsV2Connection, error)
	Run(ctx context.Context, runID string) (*models.FunctionRunV2, error)
	RunTraceSpanOutputByID(ctx context.Context, outputID string) (*models.RunTraceSpanOutput, error)
	RunTrigger(ctx context.Context, runID string) (*models.RunTraceTrigger, error)
}
type RunsV2ConnectionResolver interface {
	TotalCount(ctx context.Context, obj *models.RunsV2Connection) (int, error)
}
type StreamItemResolver interface {
	InBatch(ctx context.Context, obj *models.StreamItem) (bool, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "App.autodiscovered":
		if e.complexity.App.Autodiscovered == nil {
			break
		}

		return e.complexity.App.Autodiscovered(childComplexity), true

	case "App.checksum":
		if e.complexity.App.Checksum == nil {
			break
		}

		return e.complexity.App.Checksum(childComplexity), true

	case "App.connected":
		if e.complexity.App.Connected == nil {
			break
		}

		return e.complexity.App.Connected(childComplexity), true

	case "App.error":
		if e.complexity.App.Error == nil {
			break
		}

		return e.complexity.App.Error(childComplexity), true

	case "App.externalID":
		if e.complexity.App.ExternalID == nil {
			break
		}

		return e.complexity.App.ExternalID(childComplexity), true

	case "App.framework":
		if e.complexity.App.Framework == nil {
			break
		}

		return e.complexity.App.Framework(childComplexity), true

	case "App.functionCount":
		if e.complexity.App.FunctionCount == nil {
			break
		}

		return e.complexity.App.FunctionCount(childComplexity), true

	case "App.functions":
		if e.complexity.App.Functions == nil {
			break
		}

		return e.complexity.App.Functions(childComplexity), true

	case "App.id":
		if e.complexity.App.ID == nil {
			break
		}

		return e.complexity.App.ID(childComplexity), true

	case "App.name":
		if e.complexity.App.Name == nil {
			break
		}

		return e.complexity.App.Name(childComplexity), true

	case "App.sdkLanguage":
		if e.complexity.App.SdkLanguage == nil {
			break
		}

		return e.complexity.App.SdkLanguage(childComplexity), true

	case "App.sdkVersion":
		if e.complexity.App.SdkVersion == nil {
			break
		}

		return e.complexity.App.SdkVersion(childComplexity), true

	case "App.url":
		if e.complexity.App.Url == nil {
			break
		}

		return e.complexity.App.Url(childComplexity), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.externalID":
		if e.complexity.Event.ExternalID == nil {
			break
		}

		return e.complexity.Event.ExternalID(childComplexity), true

	case "Event.functionRuns":
		if e.complexity.Event.FunctionRuns == nil {
			break
		}

		return e.complexity.Event.FunctionRuns(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.name":
		if e.complexity.Event.Name == nil {
			break
		}

		return e.complexity.Event.Name(childComplexity), true

	case "Event.payload":
		if e.complexity.Event.Payload == nil {
			break
		}

		return e.complexity.Event.Payload(childComplexity), true

	case "Event.pendingRuns":
		if e.complexity.Event.PendingRuns == nil {
			break
		}

		return e.complexity.Event.PendingRuns(childComplexity), true

	case "Event.raw":
		if e.complexity.Event.Raw == nil {
			break
		}

		return e.complexity.Event.Raw(childComplexity), true

	case "Event.schema":
		if e.complexity.Event.Schema == nil {
			break
		}

		return e.complexity.Event.Schema(childComplexity), true

	case "Event.status":
		if e.complexity.Event.Status == nil {
			break
		}

		return e.complexity.Event.Status(childComplexity), true

	case "Event.totalRuns":
		if e.complexity.Event.TotalRuns == nil {
			break
		}

		return e.complexity.Event.TotalRuns(childComplexity), true

	case "Event.workspace":
		if e.complexity.Event.Workspace == nil {
			break
		}

		return e.complexity.Event.Workspace(childComplexity), true

	case "Function.app":
		if e.complexity.Function.App == nil {
			break
		}

		return e.complexity.Function.App(childComplexity), true

	case "Function.appID":
		if e.complexity.Function.AppID == nil {
			break
		}

		return e.complexity.Function.AppID(childComplexity), true

	case "Function.concurrency":
		if e.complexity.Function.Concurrency == nil {
			break
		}

		return e.complexity.Function.Concurrency(childComplexity), true

	case "Function.config":
		if e.complexity.Function.Config == nil {
			break
		}

		return e.complexity.Function.Config(childComplexity), true

	case "Function.id":
		if e.complexity.Function.ID == nil {
			break
		}

		return e.complexity.Function.ID(childComplexity), true

	case "Function.name":
		if e.complexity.Function.Name == nil {
			break
		}

		return e.complexity.Function.Name(childComplexity), true

	case "Function.slug":
		if e.complexity.Function.Slug == nil {
			break
		}

		return e.complexity.Function.Slug(childComplexity), true

	case "Function.triggers":
		if e.complexity.Function.Triggers == nil {
			break
		}

		return e.complexity.Function.Triggers(childComplexity), true

	case "Function.url":
		if e.complexity.Function.URL == nil {
			break
		}

		return e.complexity.Function.URL(childComplexity), true

	case "FunctionEvent.createdAt":
		if e.complexity.FunctionEvent.CreatedAt == nil {
			break
		}

		return e.complexity.FunctionEvent.CreatedAt(childComplexity), true

	case "FunctionEvent.functionRun":
		if e.complexity.FunctionEvent.FunctionRun == nil {
			break
		}

		return e.complexity.FunctionEvent.FunctionRun(childComplexity), true

	case "FunctionEvent.output":
		if e.complexity.FunctionEvent.Output == nil {
			break
		}

		return e.complexity.FunctionEvent.Output(childComplexity), true

	case "FunctionEvent.type":
		if e.complexity.FunctionEvent.Type == nil {
			break
		}

		return e.complexity.FunctionEvent.Type(childComplexity), true

	case "FunctionEvent.workspace":
		if e.complexity.FunctionEvent.Workspace == nil {
			break
		}

		return e.complexity.FunctionEvent.Workspace(childComplexity), true

	case "FunctionRun.batchCreatedAt":
		if e.complexity.FunctionRun.BatchCreatedAt == nil {
			break
		}

		return e.complexity.FunctionRun.BatchCreatedAt(childComplexity), true

	case "FunctionRun.batchID":
		if e.complexity.FunctionRun.BatchID == nil {
			break
		}

		return e.complexity.FunctionRun.BatchID(childComplexity), true

	case "FunctionRun.cron":
		if e.complexity.FunctionRun.Cron == nil {
			break
		}

		return e.complexity.FunctionRun.Cron(childComplexity), true

	case "FunctionRun.event":
		if e.complexity.FunctionRun.Event == nil {
			break
		}

		return e.complexity.FunctionRun.Event(childComplexity), true

	case "FunctionRun.eventID":
		if e.complexity.FunctionRun.EventID == nil {
			break
		}

		return e.complexity.FunctionRun.EventID(childComplexity), true

	case "FunctionRun.events":
		if e.complexity.FunctionRun.Events == nil {
			break
		}

		return e.complexity.FunctionRun.Events(childComplexity), true

	case "FunctionRun.finishedAt":
		if e.complexity.FunctionRun.FinishedAt == nil {
			break
		}

		return e.complexity.FunctionRun.FinishedAt(childComplexity), true

	case "FunctionRun.function":
		if e.complexity.FunctionRun.Function == nil {
			break
		}

		return e.complexity.FunctionRun.Function(childComplexity), true

	case "FunctionRun.functionID":
		if e.complexity.FunctionRun.FunctionID == nil {
			break
		}

		return e.complexity.FunctionRun.FunctionID(childComplexity), true

	case "FunctionRun.history":
		if e.complexity.FunctionRun.History == nil {
			break
		}

		return e.complexity.FunctionRun.History(childComplexity), true

	case "FunctionRun.historyItemOutput":
		if e.complexity.FunctionRun.HistoryItemOutput == nil {
			break
		}

		args, err := ec.field_FunctionRun_historyItemOutput_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FunctionRun.HistoryItemOutput(childComplexity, args["id"].(ulid.ULID)), true

	case "FunctionRun.id":
		if e.complexity.FunctionRun.ID == nil {
			break
		}

		return e.complexity.FunctionRun.ID(childComplexity), true

	case "FunctionRun.output":
		if e.complexity.FunctionRun.Output == nil {
			break
		}

		return e.complexity.FunctionRun.Output(childComplexity), true

	case "FunctionRun.pendingSteps":
		if e.complexity.FunctionRun.PendingSteps == nil {
			break
		}

		return e.complexity.FunctionRun.PendingSteps(childComplexity), true

	case "FunctionRun.startedAt":
		if e.complexity.FunctionRun.StartedAt == nil {
			break
		}

		return e.complexity.FunctionRun.StartedAt(childComplexity), true

	case "FunctionRun.status":
		if e.complexity.FunctionRun.Status == nil {
			break
		}

		return e.complexity.FunctionRun.Status(childComplexity), true

	case "FunctionRun.waitingFor":
		if e.complexity.FunctionRun.WaitingFor == nil {
			break
		}

		return e.complexity.FunctionRun.WaitingFor(childComplexity), true

	case "FunctionRun.workspace":
		if e.complexity.FunctionRun.Workspace == nil {
			break
		}

		return e.complexity.FunctionRun.Workspace(childComplexity), true

	case "FunctionRunV2.app":
		if e.complexity.FunctionRunV2.App == nil {
			break
		}

		return e.complexity.FunctionRunV2.App(childComplexity), true

	case "FunctionRunV2.appID":
		if e.complexity.FunctionRunV2.AppID == nil {
			break
		}

		return e.complexity.FunctionRunV2.AppID(childComplexity), true

	case "FunctionRunV2.batchCreatedAt":
		if e.complexity.FunctionRunV2.BatchCreatedAt == nil {
			break
		}

		return e.complexity.FunctionRunV2.BatchCreatedAt(childComplexity), true

	case "FunctionRunV2.cronSchedule":
		if e.complexity.FunctionRunV2.CronSchedule == nil {
			break
		}

		return e.complexity.FunctionRunV2.CronSchedule(childComplexity), true

	case "FunctionRunV2.endedAt":
		if e.complexity.FunctionRunV2.EndedAt == nil {
			break
		}

		return e.complexity.FunctionRunV2.EndedAt(childComplexity), true

	case "FunctionRunV2.eventName":
		if e.complexity.FunctionRunV2.EventName == nil {
			break
		}

		return e.complexity.FunctionRunV2.EventName(childComplexity), true

	case "FunctionRunV2.function":
		if e.complexity.FunctionRunV2.Function == nil {
			break
		}

		return e.complexity.FunctionRunV2.Function(childComplexity), true

	case "FunctionRunV2.functionID":
		if e.complexity.FunctionRunV2.FunctionID == nil {
			break
		}

		return e.complexity.FunctionRunV2.FunctionID(childComplexity), true

	case "FunctionRunV2.id":
		if e.complexity.FunctionRunV2.ID == nil {
			break
		}

		return e.complexity.FunctionRunV2.ID(childComplexity), true

	case "FunctionRunV2.isBatch":
		if e.complexity.FunctionRunV2.IsBatch == nil {
			break
		}

		return e.complexity.FunctionRunV2.IsBatch(childComplexity), true

	case "FunctionRunV2.output":
		if e.complexity.FunctionRunV2.Output == nil {
			break
		}

		return e.complexity.FunctionRunV2.Output(childComplexity), true

	case "FunctionRunV2.queuedAt":
		if e.complexity.FunctionRunV2.QueuedAt == nil {
			break
		}

		return e.complexity.FunctionRunV2.QueuedAt(childComplexity), true

	case "FunctionRunV2.sourceID":
		if e.complexity.FunctionRunV2.SourceID == nil {
			break
		}

		return e.complexity.FunctionRunV2.SourceID(childComplexity), true

	case "FunctionRunV2.startedAt":
		if e.complexity.FunctionRunV2.StartedAt == nil {
			break
		}

		return e.complexity.FunctionRunV2.StartedAt(childComplexity), true

	case "FunctionRunV2.status":
		if e.complexity.FunctionRunV2.Status == nil {
			break
		}

		return e.complexity.FunctionRunV2.Status(childComplexity), true

	case "FunctionRunV2.trace":
		if e.complexity.FunctionRunV2.Trace == nil {
			break
		}

		return e.complexity.FunctionRunV2.Trace(childComplexity), true

	case "FunctionRunV2.traceID":
		if e.complexity.FunctionRunV2.TraceID == nil {
			break
		}

		return e.complexity.FunctionRunV2.TraceID(childComplexity), true

	case "FunctionRunV2.triggerIDs":
		if e.complexity.FunctionRunV2.TriggerIDs == nil {
			break
		}

		return e.complexity.FunctionRunV2.TriggerIDs(childComplexity), true

	case "FunctionRunV2Edge.cursor":
		if e.complexity.FunctionRunV2Edge.Cursor == nil {
			break
		}

		return e.complexity.FunctionRunV2Edge.Cursor(childComplexity), true

	case "FunctionRunV2Edge.node":
		if e.complexity.FunctionRunV2Edge.Node == nil {
			break
		}

		return e.complexity.FunctionRunV2Edge.Node(childComplexity), true

	case "FunctionTrigger.type":
		if e.complexity.FunctionTrigger.Type == nil {
			break
		}

		return e.complexity.FunctionTrigger.Type(childComplexity), true

	case "FunctionTrigger.value":
		if e.complexity.FunctionTrigger.Value == nil {
			break
		}

		return e.complexity.FunctionTrigger.Value(childComplexity), true

	case "FunctionVersion.config":
		if e.complexity.FunctionVersion.Config == nil {
			break
		}

		return e.complexity.FunctionVersion.Config(childComplexity), true

	case "FunctionVersion.createdAt":
		if e.complexity.FunctionVersion.CreatedAt == nil {
			break
		}

		return e.complexity.FunctionVersion.CreatedAt(childComplexity), true

	case "FunctionVersion.functionId":
		if e.complexity.FunctionVersion.FunctionID == nil {
			break
		}

		return e.complexity.FunctionVersion.FunctionID(childComplexity), true

	case "FunctionVersion.updatedAt":
		if e.complexity.FunctionVersion.UpdatedAt == nil {
			break
		}

		return e.complexity.FunctionVersion.UpdatedAt(childComplexity), true

	case "FunctionVersion.validFrom":
		if e.complexity.FunctionVersion.ValidFrom == nil {
			break
		}

		return e.complexity.FunctionVersion.ValidFrom(childComplexity), true

	case "FunctionVersion.validTo":
		if e.complexity.FunctionVersion.ValidTo == nil {
			break
		}

		return e.complexity.FunctionVersion.ValidTo(childComplexity), true

	case "FunctionVersion.version":
		if e.complexity.FunctionVersion.Version == nil {
			break
		}

		return e.complexity.FunctionVersion.Version(childComplexity), true

	case "InvokeStepInfo.functionID":
		if e.complexity.InvokeStepInfo.FunctionID == nil {
			break
		}

		return e.complexity.InvokeStepInfo.FunctionID(childComplexity), true

	case "InvokeStepInfo.returnEventID":
		if e.complexity.InvokeStepInfo.ReturnEventID == nil {
			break
		}

		return e.complexity.InvokeStepInfo.ReturnEventID(childComplexity), true

	case "InvokeStepInfo.runID":
		if e.complexity.InvokeStepInfo.RunID == nil {
			break
		}

		return e.complexity.InvokeStepInfo.RunID(childComplexity), true

	case "InvokeStepInfo.timedOut":
		if e.complexity.InvokeStepInfo.TimedOut == nil {
			break
		}

		return e.complexity.InvokeStepInfo.TimedOut(childComplexity), true

	case "InvokeStepInfo.timeout":
		if e.complexity.InvokeStepInfo.Timeout == nil {
			break
		}

		return e.complexity.InvokeStepInfo.Timeout(childComplexity), true

	case "InvokeStepInfo.triggeringEventID":
		if e.complexity.InvokeStepInfo.TriggeringEventID == nil {
			break
		}

		return e.complexity.InvokeStepInfo.TriggeringEventID(childComplexity), true

	case "Mutation.cancelRun":
		if e.complexity.Mutation.CancelRun == nil {
			break
		}

		args, err := ec.field_Mutation_cancelRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelRun(childComplexity, args["runID"].(ulid.ULID)), true

	case "Mutation.createApp":
		if e.complexity.Mutation.CreateApp == nil {
			break
		}

		args, err := ec.field_Mutation_createApp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateApp(childComplexity, args["input"].(models.CreateAppInput)), true

	case "Mutation.deleteApp":
		if e.complexity.Mutation.DeleteApp == nil {
			break
		}

		args, err := ec.field_Mutation_deleteApp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteApp(childComplexity, args["id"].(string)), true

	case "Mutation.deleteAppByName":
		if e.complexity.Mutation.DeleteAppByName == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAppByName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAppByName(childComplexity, args["name"].(string)), true

	case "Mutation.invokeFunction":
		if e.complexity.Mutation.InvokeFunction == nil {
			break
		}

		args, err := ec.field_Mutation_invokeFunction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.InvokeFunction(childComplexity, args["data"].(map[string]interface{}), args["functionSlug"].(string), args["user"].(map[string]interface{})), true

	case "Mutation.rerun":
		if e.complexity.Mutation.Rerun == nil {
			break
		}

		args, err := ec.field_Mutation_rerun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Rerun(childComplexity, args["runID"].(ulid.ULID), args["fromStep"].(*models.RerunFromStepInput)), true

	case "Mutation.updateApp":
		if e.complexity.Mutation.UpdateApp == nil {
			break
		}

		args, err := ec.field_Mutation_updateApp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateApp(childComplexity, args["input"].(models.UpdateAppInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.apps":
		if e.complexity.Query.Apps == nil {
			break
		}

		return e.complexity.Query.Apps(childComplexity), true

	case "Query.event":
		if e.complexity.Query.Event == nil {
			break
		}

		args, err := ec.field_Query_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Event(childComplexity, args["query"].(models.EventQuery)), true

	case "Query.events":
		if e.complexity.Query.Events == nil {
			break
		}

		args, err := ec.field_Query_events_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Events(childComplexity, args["query"].(models.EventsQuery)), true

	case "Query.functionRun":
		if e.complexity.Query.FunctionRun == nil {
			break
		}

		args, err := ec.field_Query_functionRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FunctionRun(childComplexity, args["query"].(models.FunctionRunQuery)), true

	case "Query.functions":
		if e.complexity.Query.Functions == nil {
			break
		}

		return e.complexity.Query.Functions(childComplexity), true

	case "Query.run":
		if e.complexity.Query.Run == nil {
			break
		}

		args, err := ec.field_Query_run_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Run(childComplexity, args["runID"].(string)), true

	case "Query.runTraceSpanOutputByID":
		if e.complexity.Query.RunTraceSpanOutputByID == nil {
			break
		}

		args, err := ec.field_Query_runTraceSpanOutputByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RunTraceSpanOutputByID(childComplexity, args["outputID"].(string)), true

	case "Query.runTrigger":
		if e.complexity.Query.RunTrigger == nil {
			break
		}

		args, err := ec.field_Query_runTrigger_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RunTrigger(childComplexity, args["runID"].(string)), true

	case "Query.runs":
		if e.complexity.Query.Runs == nil {
			break
		}

		args, err := ec.field_Query_runs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Runs(childComplexity, args["first"].(int), args["after"].(*string), args["orderBy"].([]*models.RunsV2OrderBy), args["filter"].(models.RunsFilterV2)), true

	case "Query.stream":
		if e.complexity.Query.Stream == nil {
			break
		}

		args, err := ec.field_Query_stream_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Stream(childComplexity, args["query"].(models.StreamQuery)), true

	case "RunHistoryCancel.eventID":
		if e.complexity.RunHistoryCancel.EventID == nil {
			break
		}

		return e.complexity.RunHistoryCancel.EventID(childComplexity), true

	case "RunHistoryCancel.expression":
		if e.complexity.RunHistoryCancel.Expression == nil {
			break
		}

		return e.complexity.RunHistoryCancel.Expression(childComplexity), true

	case "RunHistoryCancel.userID":
		if e.complexity.RunHistoryCancel.UserID == nil {
			break
		}

		return e.complexity.RunHistoryCancel.UserID(childComplexity), true

	case "RunHistoryInvokeFunction.correlationID":
		if e.complexity.RunHistoryInvokeFunction.CorrelationID == nil {
			break
		}

		return e.complexity.RunHistoryInvokeFunction.CorrelationID(childComplexity), true

	case "RunHistoryInvokeFunction.eventID":
		if e.complexity.RunHistoryInvokeFunction.EventID == nil {
			break
		}

		return e.complexity.RunHistoryInvokeFunction.EventID(childComplexity), true

	case "RunHistoryInvokeFunction.functionID":
		if e.complexity.RunHistoryInvokeFunction.FunctionID == nil {
			break
		}

		return e.complexity.RunHistoryInvokeFunction.FunctionID(childComplexity), true

	case "RunHistoryInvokeFunction.timeout":
		if e.complexity.RunHistoryInvokeFunction.Timeout == nil {
			break
		}

		return e.complexity.RunHistoryInvokeFunction.Timeout(childComplexity), true

	case "RunHistoryInvokeFunctionResult.eventID":
		if e.complexity.RunHistoryInvokeFunctionResult.EventID == nil {
			break
		}

		return e.complexity.RunHistoryInvokeFunctionResult.EventID(childComplexity), true

	case "RunHistoryInvokeFunctionResult.runID":
		if e.complexity.RunHistoryInvokeFunctionResult.RunID == nil {
			break
		}

		return e.complexity.RunHistoryInvokeFunctionResult.RunID(childComplexity), true

	case "RunHistoryInvokeFunctionResult.timeout":
		if e.complexity.RunHistoryInvokeFunctionResult.Timeout == nil {
			break
		}

		return e.complexity.RunHistoryInvokeFunctionResult.Timeout(childComplexity), true

	case "RunHistoryItem.attempt":
		if e.complexity.RunHistoryItem.Attempt == nil {
			break
		}

		return e.complexity.RunHistoryItem.Attempt(childComplexity), true

	case "RunHistoryItem.cancel":
		if e.complexity.RunHistoryItem.Cancel == nil {
			break
		}

		return e.complexity.RunHistoryItem.Cancel(childComplexity), true

	case "RunHistoryItem.createdAt":
		if e.complexity.RunHistoryItem.CreatedAt == nil {
			break
		}

		return e.complexity.RunHistoryItem.CreatedAt(childComplexity), true

	case "RunHistoryItem.functionVersion":
		if e.complexity.RunHistoryItem.FunctionVersion == nil {
			break
		}

		return e.complexity.RunHistoryItem.FunctionVersion(childComplexity), true

	case "RunHistoryItem.groupID":
		if e.complexity.RunHistoryItem.GroupID == nil {
			break
		}

		return e.complexity.RunHistoryItem.GroupID(childComplexity), true

	case "RunHistoryItem.id":
		if e.complexity.RunHistoryItem.ID == nil {
			break
		}

		return e.complexity.RunHistoryItem.ID(childComplexity), true

	case "RunHistoryItem.invokeFunction":
		if e.complexity.RunHistoryItem.InvokeFunction == nil {
			break
		}

		return e.complexity.RunHistoryItem.InvokeFunction(childComplexity), true

	case "RunHistoryItem.invokeFunctionResult":
		if e.complexity.RunHistoryItem.InvokeFunctionResult == nil {
			break
		}

		return e.complexity.RunHistoryItem.InvokeFunctionResult(childComplexity), true

	case "RunHistoryItem.result":
		if e.complexity.RunHistoryItem.Result == nil {
			break
		}

		return e.complexity.RunHistoryItem.Result(childComplexity), true

	case "RunHistoryItem.sleep":
		if e.complexity.RunHistoryItem.Sleep == nil {
			break
		}

		return e.complexity.RunHistoryItem.Sleep(childComplexity), true

	case "RunHistoryItem.stepName":
		if e.complexity.RunHistoryItem.StepName == nil {
			break
		}

		return e.complexity.RunHistoryItem.StepName(childComplexity), true

	case "RunHistoryItem.stepType":
		if e.complexity.RunHistoryItem.StepType == nil {
			break
		}

		return e.complexity.RunHistoryItem.StepType(childComplexity), true

	case "RunHistoryItem.type":
		if e.complexity.RunHistoryItem.Type == nil {
			break
		}

		return e.complexity.RunHistoryItem.Type(childComplexity), true

	case "RunHistoryItem.url":
		if e.complexity.RunHistoryItem.URL == nil {
			break
		}

		return e.complexity.RunHistoryItem.URL(childComplexity), true

	case "RunHistoryItem.waitForEvent":
		if e.complexity.RunHistoryItem.WaitForEvent == nil {
			break
		}

		return e.complexity.RunHistoryItem.WaitForEvent(childComplexity), true

	case "RunHistoryItem.waitResult":
		if e.complexity.RunHistoryItem.WaitResult == nil {
			break
		}

		return e.complexity.RunHistoryItem.WaitResult(childComplexity), true

	case "RunHistoryResult.durationMS":
		if e.complexity.RunHistoryResult.DurationMS == nil {
			break
		}

		return e.complexity.RunHistoryResult.DurationMS(childComplexity), true

	case "RunHistoryResult.errorCode":
		if e.complexity.RunHistoryResult.ErrorCode == nil {
			break
		}

		return e.complexity.RunHistoryResult.ErrorCode(childComplexity), true

	case "RunHistoryResult.framework":
		if e.complexity.RunHistoryResult.Framework == nil {
			break
		}

		return e.complexity.RunHistoryResult.Framework(childComplexity), true

	case "RunHistoryResult.platform":
		if e.complexity.RunHistoryResult.Platform == nil {
			break
		}

		return e.complexity.RunHistoryResult.Platform(childComplexity), true

	case "RunHistoryResult.sdkLanguage":
		if e.complexity.RunHistoryResult.SDKLanguage == nil {
			break
		}

		return e.complexity.RunHistoryResult.SDKLanguage(childComplexity), true

	case "RunHistoryResult.sdkVersion":
		if e.complexity.RunHistoryResult.SDKVersion == nil {
			break
		}

		return e.complexity.RunHistoryResult.SDKVersion(childComplexity), true

	case "RunHistoryResult.sizeBytes":
		if e.complexity.RunHistoryResult.SizeBytes == nil {
			break
		}

		return e.complexity.RunHistoryResult.SizeBytes(childComplexity), true

	case "RunHistorySleep.until":
		if e.complexity.RunHistorySleep.Until == nil {
			break
		}

		return e.complexity.RunHistorySleep.Until(childComplexity), true

	case "RunHistoryWaitForEvent.eventName":
		if e.complexity.RunHistoryWaitForEvent.EventName == nil {
			break
		}

		return e.complexity.RunHistoryWaitForEvent.EventName(childComplexity), true

	case "RunHistoryWaitForEvent.expression":
		if e.complexity.RunHistoryWaitForEvent.Expression == nil {
			break
		}

		return e.complexity.RunHistoryWaitForEvent.Expression(childComplexity), true

	case "RunHistoryWaitForEvent.timeout":
		if e.complexity.RunHistoryWaitForEvent.Timeout == nil {
			break
		}

		return e.complexity.RunHistoryWaitForEvent.Timeout(childComplexity), true

	case "RunHistoryWaitResult.eventID":
		if e.complexity.RunHistoryWaitResult.EventID == nil {
			break
		}

		return e.complexity.RunHistoryWaitResult.EventID(childComplexity), true

	case "RunHistoryWaitResult.timeout":
		if e.complexity.RunHistoryWaitResult.Timeout == nil {
			break
		}

		return e.complexity.RunHistoryWaitResult.Timeout(childComplexity), true

	case "RunStepInfo.type":
		if e.complexity.RunStepInfo.Type == nil {
			break
		}

		return e.complexity.RunStepInfo.Type(childComplexity), true

	case "RunTraceSpan.appID":
		if e.complexity.RunTraceSpan.AppID == nil {
			break
		}

		return e.complexity.RunTraceSpan.AppID(childComplexity), true

	case "RunTraceSpan.attempts":
		if e.complexity.RunTraceSpan.Attempts == nil {
			break
		}

		return e.complexity.RunTraceSpan.Attempts(childComplexity), true

	case "RunTraceSpan.childrenSpans":
		if e.complexity.RunTraceSpan.ChildrenSpans == nil {
			break
		}

		return e.complexity.RunTraceSpan.ChildrenSpans(childComplexity), true

	case "RunTraceSpan.duration":
		if e.complexity.RunTraceSpan.Duration == nil {
			break
		}

		return e.complexity.RunTraceSpan.Duration(childComplexity), true

	case "RunTraceSpan.endedAt":
		if e.complexity.RunTraceSpan.EndedAt == nil {
			break
		}

		return e.complexity.RunTraceSpan.EndedAt(childComplexity), true

	case "RunTraceSpan.functionID":
		if e.complexity.RunTraceSpan.FunctionID == nil {
			break
		}

		return e.complexity.RunTraceSpan.FunctionID(childComplexity), true

	case "RunTraceSpan.isRoot":
		if e.complexity.RunTraceSpan.IsRoot == nil {
			break
		}

		return e.complexity.RunTraceSpan.IsRoot(childComplexity), true

	case "RunTraceSpan.name":
		if e.complexity.RunTraceSpan.Name == nil {
			break
		}

		return e.complexity.RunTraceSpan.Name(childComplexity), true

	case "RunTraceSpan.outputID":
		if e.complexity.RunTraceSpan.OutputID == nil {
			break
		}

		return e.complexity.RunTraceSpan.OutputID(childComplexity), true

	case "RunTraceSpan.parentSpan":
		if e.complexity.RunTraceSpan.ParentSpan == nil {
			break
		}

		return e.complexity.RunTraceSpan.ParentSpan(childComplexity), true

	case "RunTraceSpan.parentSpanID":
		if e.complexity.RunTraceSpan.ParentSpanID == nil {
			break
		}

		return e.complexity.RunTraceSpan.ParentSpanID(childComplexity), true

	case "RunTraceSpan.queuedAt":
		if e.complexity.RunTraceSpan.QueuedAt == nil {
			break
		}

		return e.complexity.RunTraceSpan.QueuedAt(childComplexity), true

	case "RunTraceSpan.run":
		if e.complexity.RunTraceSpan.Run == nil {
			break
		}

		return e.complexity.RunTraceSpan.Run(childComplexity), true

	case "RunTraceSpan.runID":
		if e.complexity.RunTraceSpan.RunID == nil {
			break
		}

		return e.complexity.RunTraceSpan.RunID(childComplexity), true

	case "RunTraceSpan.spanID":
		if e.complexity.RunTraceSpan.SpanID == nil {
			break
		}

		return e.complexity.RunTraceSpan.SpanID(childComplexity), true

	case "RunTraceSpan.startedAt":
		if e.complexity.RunTraceSpan.StartedAt == nil {
			break
		}

		return e.complexity.RunTraceSpan.StartedAt(childComplexity), true

	case "RunTraceSpan.status":
		if e.complexity.RunTraceSpan.Status == nil {
			break
		}

		return e.complexity.RunTraceSpan.Status(childComplexity), true

	case "RunTraceSpan.stepID":
		if e.complexity.RunTraceSpan.StepID == nil {
			break
		}

		return e.complexity.RunTraceSpan.StepID(childComplexity), true

	case "RunTraceSpan.stepInfo":
		if e.complexity.RunTraceSpan.StepInfo == nil {
			break
		}

		return e.complexity.RunTraceSpan.StepInfo(childComplexity), true

	case "RunTraceSpan.stepOp":
		if e.complexity.RunTraceSpan.StepOp == nil {
			break
		}

		return e.complexity.RunTraceSpan.StepOp(childComplexity), true

	case "RunTraceSpan.traceID":
		if e.complexity.RunTraceSpan.TraceID == nil {
			break
		}

		return e.complexity.RunTraceSpan.TraceID(childComplexity), true

	case "RunTraceSpanOutput.data":
		if e.complexity.RunTraceSpanOutput.Data == nil {
			break
		}

		return e.complexity.RunTraceSpanOutput.Data(childComplexity), true

	case "RunTraceSpanOutput.error":
		if e.complexity.RunTraceSpanOutput.Error == nil {
			break
		}

		return e.complexity.RunTraceSpanOutput.Error(childComplexity), true

	case "RunTraceSpanOutput.input":
		if e.complexity.RunTraceSpanOutput.Input == nil {
			break
		}

		return e.complexity.RunTraceSpanOutput.Input(childComplexity), true

	case "RunTraceTrigger.batchID":
		if e.complexity.RunTraceTrigger.BatchID == nil {
			break
		}

		return e.complexity.RunTraceTrigger.BatchID(childComplexity), true

	case "RunTraceTrigger.cron":
		if e.complexity.RunTraceTrigger.Cron == nil {
			break
		}

		return e.complexity.RunTraceTrigger.Cron(childComplexity), true

	case "RunTraceTrigger.eventName":
		if e.complexity.RunTraceTrigger.EventName == nil {
			break
		}

		return e.complexity.RunTraceTrigger.EventName(childComplexity), true

	case "RunTraceTrigger.IDs":
		if e.complexity.RunTraceTrigger.IDs == nil {
			break
		}

		return e.complexity.RunTraceTrigger.IDs(childComplexity), true

	case "RunTraceTrigger.isBatch":
		if e.complexity.RunTraceTrigger.IsBatch == nil {
			break
		}

		return e.complexity.RunTraceTrigger.IsBatch(childComplexity), true

	case "RunTraceTrigger.payloads":
		if e.complexity.RunTraceTrigger.Payloads == nil {
			break
		}

		return e.complexity.RunTraceTrigger.Payloads(childComplexity), true

	case "RunTraceTrigger.timestamp":
		if e.complexity.RunTraceTrigger.Timestamp == nil {
			break
		}

		return e.complexity.RunTraceTrigger.Timestamp(childComplexity), true

	case "RunsV2Connection.edges":
		if e.complexity.RunsV2Connection.Edges == nil {
			break
		}

		return e.complexity.RunsV2Connection.Edges(childComplexity), true

	case "RunsV2Connection.pageInfo":
		if e.complexity.RunsV2Connection.PageInfo == nil {
			break
		}

		return e.complexity.RunsV2Connection.PageInfo(childComplexity), true

	case "RunsV2Connection.totalCount":
		if e.complexity.RunsV2Connection.TotalCount == nil {
			break
		}

		return e.complexity.RunsV2Connection.TotalCount(childComplexity), true

	case "SleepStepInfo.sleepUntil":
		if e.complexity.SleepStepInfo.SleepUntil == nil {
			break
		}

		return e.complexity.SleepStepInfo.SleepUntil(childComplexity), true

	case "StepError.message":
		if e.complexity.StepError.Message == nil {
			break
		}

		return e.complexity.StepError.Message(childComplexity), true

	case "StepError.name":
		if e.complexity.StepError.Name == nil {
			break
		}

		return e.complexity.StepError.Name(childComplexity), true

	case "StepError.stack":
		if e.complexity.StepError.Stack == nil {
			break
		}

		return e.complexity.StepError.Stack(childComplexity), true

	case "StepEvent.createdAt":
		if e.complexity.StepEvent.CreatedAt == nil {
			break
		}

		return e.complexity.StepEvent.CreatedAt(childComplexity), true

	case "StepEvent.functionRun":
		if e.complexity.StepEvent.FunctionRun == nil {
			break
		}

		return e.complexity.StepEvent.FunctionRun(childComplexity), true

	case "StepEvent.name":
		if e.complexity.StepEvent.Name == nil {
			break
		}

		return e.complexity.StepEvent.Name(childComplexity), true

	case "StepEvent.output":
		if e.complexity.StepEvent.Output == nil {
			break
		}

		return e.complexity.StepEvent.Output(childComplexity), true

	case "StepEvent.stepID":
		if e.complexity.StepEvent.StepID == nil {
			break
		}

		return e.complexity.StepEvent.StepID(childComplexity), true

	case "StepEvent.type":
		if e.complexity.StepEvent.Type == nil {
			break
		}

		return e.complexity.StepEvent.Type(childComplexity), true

	case "StepEvent.waitingFor":
		if e.complexity.StepEvent.WaitingFor == nil {
			break
		}

		return e.complexity.StepEvent.WaitingFor(childComplexity), true

	case "StepEvent.workspace":
		if e.complexity.StepEvent.Workspace == nil {
			break
		}

		return e.complexity.StepEvent.Workspace(childComplexity), true

	case "StepEventWait.eventName":
		if e.complexity.StepEventWait.EventName == nil {
			break
		}

		return e.complexity.StepEventWait.EventName(childComplexity), true

	case "StepEventWait.expiryTime":
		if e.complexity.StepEventWait.ExpiryTime == nil {
			break
		}

		return e.complexity.StepEventWait.ExpiryTime(childComplexity), true

	case "StepEventWait.expression":
		if e.complexity.StepEventWait.Expression == nil {
			break
		}

		return e.complexity.StepEventWait.Expression(childComplexity), true

	case "StreamItem.createdAt":
		if e.complexity.StreamItem.CreatedAt == nil {
			break
		}

		return e.complexity.StreamItem.CreatedAt(childComplexity), true

	case "StreamItem.id":
		if e.complexity.StreamItem.ID == nil {
			break
		}

		return e.complexity.StreamItem.ID(childComplexity), true

	case "StreamItem.inBatch":
		if e.complexity.StreamItem.InBatch == nil {
			break
		}

		return e.complexity.StreamItem.InBatch(childComplexity), true

	case "StreamItem.runs":
		if e.complexity.StreamItem.Runs == nil {
			break
		}

		return e.complexity.StreamItem.Runs(childComplexity), true

	case "StreamItem.trigger":
		if e.complexity.StreamItem.Trigger == nil {
			break
		}

		return e.complexity.StreamItem.Trigger(childComplexity), true

	case "StreamItem.type":
		if e.complexity.StreamItem.Type == nil {
			break
		}

		return e.complexity.StreamItem.Type(childComplexity), true

	case "WaitForEventStepInfo.eventName":
		if e.complexity.WaitForEventStepInfo.EventName == nil {
			break
		}

		return e.complexity.WaitForEventStepInfo.EventName(childComplexity), true

	case "WaitForEventStepInfo.expression":
		if e.complexity.WaitForEventStepInfo.Expression == nil {
			break
		}

		return e.complexity.WaitForEventStepInfo.Expression(childComplexity), true

	case "WaitForEventStepInfo.foundEventID":
		if e.complexity.WaitForEventStepInfo.FoundEventID == nil {
			break
		}

		return e.complexity.WaitForEventStepInfo.FoundEventID(childComplexity), true

	case "WaitForEventStepInfo.timedOut":
		if e.complexity.WaitForEventStepInfo.TimedOut == nil {
			break
		}

		return e.complexity.WaitForEventStepInfo.TimedOut(childComplexity), true

	case "WaitForEventStepInfo.timeout":
		if e.complexity.WaitForEventStepInfo.Timeout == nil {
			break
		}

		return e.complexity.WaitForEventStepInfo.Timeout(childComplexity), true

	case "Workspace.id":
		if e.complexity.Workspace.ID == nil {
			break
		}

		return e.complexity.Workspace.ID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputActionVersionQuery,
		ec.unmarshalInputCreateAppInput,
		ec.unmarshalInputEventQuery,
		ec.unmarshalInputEventsQuery,
		ec.unmarshalInputFunctionRunQuery,
		ec.unmarshalInputFunctionRunsQuery,
		ec.unmarshalInputRerunFromStepInput,
		ec.unmarshalInputRunsFilterV2,
		ec.unmarshalInputRunsV2OrderBy,
		ec.unmarshalInputStreamQuery,
		ec.unmarshalInputUpdateAppInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../gql.mutations.graphql", Input: `scalar Map

type Mutation {
  createApp(input: CreateAppInput!): App!
  updateApp(input: UpdateAppInput!): App!
  deleteApp(id: String!): String! # returns the ID of the deleted app
  deleteAppByName(name: String!): Boolean!

  invokeFunction(
    data: Map
    functionSlug: String!
    user: Map
  ): Boolean

  cancelRun(runID: ULID!): FunctionRun!
  rerun(runID: ULID!, fromStep: RerunFromStepInput): ULID!
}

input CreateAppInput {
  url: String!
}

input UpdateAppInput {
  id: String!
  url: String!
}

input RerunFromStepInput {
  stepID: String!
  input: Bytes
}
`, BuiltIn: false},
	{Name: "../gql.query.graphql", Input: `type Query {
  apps: [App!]!

  stream(query: StreamQuery!): [StreamItem!]!

  # Get an individual event
  event(query: EventQuery!): Event

  # Get all events sent
  events(query: EventsQuery!): [Event!]

  # Get all functions registered
  functions: [Function!]

  # Get an individual function run
  functionRun(query: FunctionRunQuery!): FunctionRun

  runs(
    first: Int! = 100
    after: String
    orderBy: [RunsV2OrderBy!]!
    filter: RunsFilterV2!
  ): RunsV2Connection!
  # runsMetrics(filter: RunsFilterV2!): MetricsResponse!
  run(runID: String!): FunctionRunV2
  runTraceSpanOutputByID(outputID: String!): RunTraceSpanOutput!
  runTrigger(runID: String!): RunTraceTrigger!
}

input ActionVersionQuery {
  dsn: String!
  versionMajor: Int
  versionMinor: Int
}

input EventQuery {
  workspaceId: ID! = "local"
  eventId: ID!
}

input EventsQuery {
  workspaceId: ID! = "local"
  lastEventId: ID
}

input FunctionRunQuery {
  workspaceId: ID! = "local"
  functionRunId: ID!
}

input FunctionRunsQuery {
  workspaceId: ID! = "local"
}

input StreamQuery {
  # after allows you to query for items after an ID. If not provided this
  # defaults to the most recent items in the stream, eg now.
  after: ID
  # before allows you to receive items in a stream before an ID.
  # This is useful as you can add the last stream ID as the before
  # field, ensuring that only new items are received.
  before: ID
  limit: Int! = 20
  includeInternalEvents: Boolean
}
`, BuiltIn: false},
	{Name: "../gql.schema.graphql", Input: `scalar Time

"""
The environment for the function to be run: ` + "`" + `"prod"` + "`" + ` or ` + "`" + `"test"` + "`" + `
"""
scalar Environment

scalar Uint
scalar ULID
scalar UUID
scalar Bytes

"The pagination information in a connection."
type PageInfo {
  "Indicates if there are any pages subsequent to the current page."
  hasNextPage: Boolean!

  "Indicates if there are any pages prior to the current page."
  hasPreviousPage: Boolean!

  "When paginating backward, the cursor to query the previous page."
  startCursor: String

  "When paginating forward, the cursor to query the next page."
  endCursor: String
}

type Workspace {
  id: ID!
}

type StreamItem {
  id: ID!
  trigger: String! # Event name or cron
  type: StreamType!
  createdAt: Time!
  runs: [FunctionRun]
  inBatch: Boolean!
}

enum StreamType {
  EVENT
  CRON
}

type FunctionVersion {
  functionId: ID!
  version: Uint!
  config: String!

  validFrom: Time
  validTo: Time
  createdAt: Time!
  updatedAt: Time!
}

type Event {
  id: ULID!
  externalID: String
  workspace: Workspace
  name: String
  createdAt: Time
  payload: String
  schema: String
  status: EventStatus
  pendingRuns: Int
  # The total number of function runs triggered by this event.
  totalRuns: Int
  # The raw JSON of this event, as it would've be sent by the producer.
  raw: String
  functionRuns: [FunctionRun!]
}

enum EventStatus {
  # The event has triggered one or more functions, none of them have failed, and
  # some of are them are still running.
  RUNNING

  # The event has triggered one or more functions and all of them have completed
  # successfully.
  COMPLETED

  # The event has triggered one or more functions and has paused for a period of
  # time or is waiting for an event.
  PAUSED

  # The event has triggered one or more functions and all have failed.
  FAILED

  # The event has triggered one or more functions, at least one - but not all -
  # have failed, and all have run finished running.
  PARTIALLY_FAILED

  # The event triggered no functions.
  NO_FUNCTIONS
}

enum FunctionStatus {
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  # todo: SLEEPING, WAITING FOR EVENT when this is available with queue changes.
}

type App {
  id: ID!
  externalID: String!
  name: String!
  sdkLanguage: String!
  sdkVersion: String!
  framework: String
  url: String
  checksum: String
  error: String
  functions: [Function!]!

  # These fields are UI convenience fields
  connected: Boolean!
  functionCount: Int!
  autodiscovered: Boolean!
}

type Function {
  id: String!
  name: String!
  slug: String!
  config: String!
  concurrency: Int!
  triggers: [FunctionTrigger!]
  url: String!
  appID: String!
  app: App!
}

enum FunctionTriggerTypes {
  EVENT
  CRON
}

type FunctionTrigger {
  type: FunctionTriggerTypes!
  value: String!
}

enum FunctionRunStatus {
  COMPLETED
  FAILED
  CANCELLED
  RUNNING
  QUEUED
}

enum FunctionEventType {
  STARTED
  COMPLETED
  FAILED
  CANCELLED
}

type FunctionEvent {
  workspace: Workspace
  functionRun: FunctionRun
  type: FunctionEventType
  output: String
  createdAt: Time
}

enum StepEventType {
  SCHEDULED
  STARTED
  COMPLETED
  ERRORED
  FAILED
  WAITING
}

type StepEvent {
  workspace: Workspace
  functionRun: FunctionRun
  stepID: String
  name: String
  type: StepEventType
  output: String
  createdAt: Time
  waitingFor: StepEventWait
}

union FunctionRunEvent = FunctionEvent | StepEvent

type StepEventWait {
  eventName: String
  expression: String
  expiryTime: Time!
}

type FunctionRun {
  id: ID!
  functionID: String!

  # related fields
  function: Function
  workspace: Workspace
  event: Event
  events: [Event!]!
  batchID: ULID
  batchCreatedAt: Time

  status: FunctionRunStatus
  waitingFor: StepEventWait
  pendingSteps: Int @deprecated
  startedAt: Time
  finishedAt: Time
  output: String # JSON encoded output of the function, or JSON encoded error if this is a failure.
  history: [RunHistoryItem!]!
  historyItemOutput(id: ULID!): String
  eventID: ID!
  cron: String
}

enum HistoryType {
  FunctionCancelled
  FunctionCompleted
  FunctionFailed
  FunctionScheduled
  FunctionStarted
  FunctionStatusUpdated
  None
  StepCompleted
  StepErrored
  StepFailed
  StepScheduled
  StepSleeping
  StepStarted
  StepWaiting
}

enum HistoryStepType {
  Run
  Send
  Sleep
  Wait
}

type RunHistoryItem {
  attempt: Int!
  cancel: RunHistoryCancel
  createdAt: Time!
  functionVersion: Int!
  groupID: UUID
  id: ULID!
  result: RunHistoryResult
  sleep: RunHistorySleep
  stepName: String
  stepType: HistoryStepType
  type: HistoryType!
  url: String
  waitForEvent: RunHistoryWaitForEvent
  waitResult: RunHistoryWaitResult
  invokeFunction: RunHistoryInvokeFunction
  invokeFunctionResult: RunHistoryInvokeFunctionResult
}

type RunHistoryCancel {
  eventID: ULID
  expression: String
  userID: UUID
}

type RunHistoryResult {
  durationMS: Int!
  errorCode: String
  framework: String
  platform: String
  sdkLanguage: String!
  sdkVersion: String!
  sizeBytes: Int!
}

type RunHistorySleep {
  until: Time!
}

type RunHistoryWaitForEvent {
  eventName: String!
  expression: String
  timeout: Time!
}

type RunHistoryWaitResult {
  eventID: ULID
  timeout: Boolean!
}

type RunHistoryInvokeFunction {
  eventID: ULID!
  functionID: String!
  correlationID: String!
  timeout: Time!
}

type RunHistoryInvokeFunctionResult {
  eventID: ULID
  timeout: Boolean!
  runID: ULID
}

# trace runs
input RunsFilterV2 {
  from: Time!
  until: Time
  timeField: RunsV2OrderByField = QUEUED_AT

  status: [FunctionRunStatus!]
  functionIDs: [UUID!]
  appIDs: [UUID!]

  query: String # CEL query string
}

input RunsV2OrderBy {
  field: RunsV2OrderByField!
  direction: RunsOrderByDirection!
}

enum RunsV2OrderByField {
  QUEUED_AT
  STARTED_AT
  ENDED_AT
}

enum RunsOrderByDirection {
  ASC
  DESC
}

type FunctionRunV2 {
  id: ULID!
  appID: UUID!
  app: App!
  functionID: UUID!
  function: Function!
  traceID: String!

  # timestamps
  queuedAt: Time!
  startedAt: Time
  endedAt: Time

  status: FunctionRunStatus!
  sourceID: String # The parent trace / run that triggered this run
  triggerIDs: [ULID!]!
  eventName: String
  isBatch: Boolean!
  batchCreatedAt: Time
  cronSchedule: String

  output: Bytes

  trace: RunTraceSpan
}

type RunsV2Connection {
  edges: [FunctionRunV2Edge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FunctionRunV2Edge {
  node: FunctionRunV2!
  cursor: String!
}

enum RunTraceSpanStatus {
  FAILED # step completed with an error
  QUEUED # step of run is queued but not started
  RUNNING # actively being executed right now
  COMPLETED # step completed successfully
  # TIMED_OUT # wait for event timed out waiting
  WAITING # sleeping, waiting for an event
  CANCELLED # cancelled run
}

enum StepOp {
  INVOKE # invoke another function
  RUN # run a function
  SLEEP # sleep for a duration
  WAIT_FOR_EVENT # wait for an event
}

union StepInfo = InvokeStepInfo | SleepStepInfo | WaitForEventStepInfo | RunStepInfo

type InvokeStepInfo {
  triggeringEventID: ULID!
  functionID: String!
  timeout: Time!
  returnEventID: ULID
  runID: ULID
  timedOut: Boolean
}

type SleepStepInfo {
  sleepUntil: Time!
}

type WaitForEventStepInfo {
  eventName: String!
  expression: String
  timeout: Time!
  foundEventID: ULID
  timedOut: Boolean
}

type RunStepInfo {
  type: String
}

type RunTraceSpan {
  appID: UUID!
  functionID: UUID!

  runID: ULID!
  run: FunctionRun! # the run that generated this span <== links should be here
  # Internal
  spanID: String! # internal span ID, or a virtual span ID
  traceID: String! # the internal ID of the trace this span belongs to
  # Required
  name: String! # the name of the span
  status: RunTraceSpanStatus! # the status of the span
  attempts: Int # if this node contains retry attempts, this is the current attempt number
  # groupID: String!

  # cursor: String! # used for "pagination", is just a hash to the user
  duration: Int # the duration of the span in milliseconds (calculated), if null, it's still running
  outputID: String
  queuedAt: Time!
  startedAt: Time # the start time of the span
  endedAt: Time # the end time of the span, only present if it's ended
  childrenSpans: [RunTraceSpan!]! # the children spans of this span - invoke
  stepOp: StepOp # the operation this span represents; nil means it can't be attributed to a step yet
  stepID: String # the ID of the step this span is associated with
  stepInfo: StepInfo # info about the step - use fragments to access appropriately
  # Nice-to-haves for navigating the trace
  isRoot: Boolean! # whether this span is the root span of the trace (shortcut for presence of rootspan)
  parentSpanID: String
  parentSpan: RunTraceSpan # the parent span of this span
}

type RunTraceSpanOutput {
  input: Bytes
  data: Bytes
  error: StepError
}

type StepError {
  message: String!
  name: String
  stack: String
}

type RunTraceTrigger {
  eventName: String
  IDs: [ULID!]! # the ULIDs of all events associated with this run
  payloads: [Bytes!]! # a list of event objects
  timestamp: Time! # the timestamp of the single event or the batch
  isBatch: Boolean! # indicates if this trigger is a batch trigger
  batchID: ULID # the batchID of this list of events if available
  cron: String # The cron expression if available
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_FunctionRun_historyItemOutput_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ulid.ULID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNULID2githubcomoklogulidv2ULID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ulid.ULID
	if tmp, ok := rawArgs["runID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runID"))
		arg0, err = ec.unmarshalNULID2githubcomoklogulidv2ULID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createApp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateAppInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateAppInput2githubcominngestinngestpkgcoreapigraphmodelsCreateAppInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteAppByName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteApp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_invokeFunction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["functionSlug"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("functionSlug"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["functionSlug"] = arg1
	var arg2 map[string]interface{}
	if tmp, ok := rawArgs["user"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
		arg2, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["user"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_rerun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ulid.ULID
	if tmp, ok := rawArgs["runID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runID"))
		arg0, err = ec.unmarshalNULID2githubcomoklogulidv2ULID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runID"] = arg0
	var arg1 *models.RerunFromStepInput
	if tmp, ok := rawArgs["fromStep"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromStep"))
		arg1, err = ec.unmarshalORerunFromStepInput2githubcominngestinngestpkgcoreapigraphmodelsRerunFromStepInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fromStep"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateApp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateAppInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateAppInput2githubcominngestinngestpkgcoreapigraphmodelsUpdateAppInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_event_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.EventQuery
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNEventQuery2githubcominngestinngestpkgcoreapigraphmodelsEventQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_events_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.EventsQuery
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNEventsQuery2githubcominngestinngestpkgcoreapigraphmodelsEventsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_functionRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.FunctionRunQuery
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNFunctionRunQuery2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_runTraceSpanOutputByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["outputID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("outputID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["outputID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_runTrigger_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["runID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_run_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["runID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["runID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_runs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 []*models.RunsV2OrderBy
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg2, err = ec.unmarshalNRunsV2OrderBy2githubcominngestinngestpkgcoreapigraphmodelsRunsV2OrderBy(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg2
	var arg3 models.RunsFilterV2
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg3, err = ec.unmarshalNRunsFilterV22githubcominngestinngestpkgcoreapigraphmodelsRunsFilterV2(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_stream_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.StreamQuery
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNStreamQuery2githubcominngestinngestpkgcoreapigraphmodelsStreamQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _App_id(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.App().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_externalID(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_externalID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.App().ExternalID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_externalID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_name(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_sdkLanguage(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_sdkLanguage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SdkLanguage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_sdkLanguage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_sdkVersion(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_sdkVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SdkVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_sdkVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_framework(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_framework(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.App().Framework(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_framework(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_url(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Url, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_checksum(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_checksum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Checksum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_checksum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_error(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.App().Error(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_functions(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_functions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.App().Functions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Function)
	fc.Result = res
	return ec.marshalNFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_functions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Function_id(ctx, field)
			case "name":
				return ec.fieldContext_Function_name(ctx, field)
			case "slug":
				return ec.fieldContext_Function_slug(ctx, field)
			case "config":
				return ec.fieldContext_Function_config(ctx, field)
			case "concurrency":
				return ec.fieldContext_Function_concurrency(ctx, field)
			case "triggers":
				return ec.fieldContext_Function_triggers(ctx, field)
			case "url":
				return ec.fieldContext_Function_url(ctx, field)
			case "appID":
				return ec.fieldContext_Function_appID(ctx, field)
			case "app":
				return ec.fieldContext_Function_app(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Function", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_connected(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_connected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.App().Connected(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_connected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_functionCount(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_functionCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.App().FunctionCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_functionCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _App_autodiscovered(ctx context.Context, field graphql.CollectedField, obj *cqrs.App) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_App_autodiscovered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.App().Autodiscovered(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_App_autodiscovered(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "App",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ulid.ULID)
	fc.Result = res
	return ec.marshalNULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_externalID(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_externalID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_externalID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_workspace(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_workspace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workspace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Workspace)
	fc.Result = res
	return ec.marshalOWorkspace2githubcominngestinngestpkgcoreapigraphmodelsWorkspace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_workspace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workspace_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workspace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_name(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_payload(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_payload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Payload, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_payload(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_schema(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_status(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.EventStatus)
	fc.Result = res
	return ec.marshalOEventStatus2githubcominngestinngestpkgcoreapigraphmodelsEventStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_pendingRuns(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_pendingRuns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().PendingRuns(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_pendingRuns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_totalRuns(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_totalRuns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().TotalRuns(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_totalRuns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_raw(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().Raw(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_functionRuns(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_functionRuns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().FunctionRuns(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.FunctionRun)
	fc.Result = res
	return ec.marshalOFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_functionRuns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FunctionRun_id(ctx, field)
			case "functionID":
				return ec.fieldContext_FunctionRun_functionID(ctx, field)
			case "function":
				return ec.fieldContext_FunctionRun_function(ctx, field)
			case "workspace":
				return ec.fieldContext_FunctionRun_workspace(ctx, field)
			case "event":
				return ec.fieldContext_FunctionRun_event(ctx, field)
			case "events":
				return ec.fieldContext_FunctionRun_events(ctx, field)
			case "batchID":
				return ec.fieldContext_FunctionRun_batchID(ctx, field)
			case "batchCreatedAt":
				return ec.fieldContext_FunctionRun_batchCreatedAt(ctx, field)
			case "status":
				return ec.fieldContext_FunctionRun_status(ctx, field)
			case "waitingFor":
				return ec.fieldContext_FunctionRun_waitingFor(ctx, field)
			case "pendingSteps":
				return ec.fieldContext_FunctionRun_pendingSteps(ctx, field)
			case "startedAt":
				return ec.fieldContext_FunctionRun_startedAt(ctx, field)
			case "finishedAt":
				return ec.fieldContext_FunctionRun_finishedAt(ctx, field)
			case "output":
				return ec.fieldContext_FunctionRun_output(ctx, field)
			case "history":
				return ec.fieldContext_FunctionRun_history(ctx, field)
			case "historyItemOutput":
				return ec.fieldContext_FunctionRun_historyItemOutput(ctx, field)
			case "eventID":
				return ec.fieldContext_FunctionRun_eventID(ctx, field)
			case "cron":
				return ec.fieldContext_FunctionRun_cron(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionRun", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Function_id(ctx context.Context, field graphql.CollectedField, obj *models.Function) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Function_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Function_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Function",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Function_name(ctx context.Context, field graphql.CollectedField, obj *models.Function) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Function_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Function_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Function",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Function_slug(ctx context.Context, field graphql.CollectedField, obj *models.Function) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Function_slug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Function_slug(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Function",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Function_config(ctx context.Context, field graphql.CollectedField, obj *models.Function) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Function_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Function_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Function",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Function_concurrency(ctx context.Context, field graphql.CollectedField, obj *models.Function) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Function_concurrency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Concurrency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Function_concurrency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Function",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Function_triggers(ctx context.Context, field graphql.CollectedField, obj *models.Function) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Function_triggers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Triggers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.FunctionTrigger)
	fc.Result = res
	return ec.marshalOFunctionTrigger2githubcominngestinngestpkgcoreapigraphmodelsFunctionTrigger(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Function_triggers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Function",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_FunctionTrigger_type(ctx, field)
			case "value":
				return ec.fieldContext_FunctionTrigger_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionTrigger", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Function_url(ctx context.Context, field graphql.CollectedField, obj *models.Function) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Function_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Function_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Function",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Function_appID(ctx context.Context, field graphql.CollectedField, obj *models.Function) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Function_appID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Function_appID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Function",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Function_app(ctx context.Context, field graphql.CollectedField, obj *models.Function) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Function_app(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Function().App(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cqrs.App)
	fc.Result = res
	return ec.marshalNApp2githubcominngestinngestpkgcqrsApp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Function_app(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Function",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_App_id(ctx, field)
			case "externalID":
				return ec.fieldContext_App_externalID(ctx, field)
			case "name":
				return ec.fieldContext_App_name(ctx, field)
			case "sdkLanguage":
				return ec.fieldContext_App_sdkLanguage(ctx, field)
			case "sdkVersion":
				return ec.fieldContext_App_sdkVersion(ctx, field)
			case "framework":
				return ec.fieldContext_App_framework(ctx, field)
			case "url":
				return ec.fieldContext_App_url(ctx, field)
			case "checksum":
				return ec.fieldContext_App_checksum(ctx, field)
			case "error":
				return ec.fieldContext_App_error(ctx, field)
			case "functions":
				return ec.fieldContext_App_functions(ctx, field)
			case "connected":
				return ec.fieldContext_App_connected(ctx, field)
			case "functionCount":
				return ec.fieldContext_App_functionCount(ctx, field)
			case "autodiscovered":
				return ec.fieldContext_App_autodiscovered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type App", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionEvent_workspace(ctx context.Context, field graphql.CollectedField, obj *models.FunctionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionEvent_workspace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workspace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Workspace)
	fc.Result = res
	return ec.marshalOWorkspace2githubcominngestinngestpkgcoreapigraphmodelsWorkspace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionEvent_workspace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workspace_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workspace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionEvent_functionRun(ctx context.Context, field graphql.CollectedField, obj *models.FunctionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionEvent_functionRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionRun, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.FunctionRun)
	fc.Result = res
	return ec.marshalOFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionEvent_functionRun(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FunctionRun_id(ctx, field)
			case "functionID":
				return ec.fieldContext_FunctionRun_functionID(ctx, field)
			case "function":
				return ec.fieldContext_FunctionRun_function(ctx, field)
			case "workspace":
				return ec.fieldContext_FunctionRun_workspace(ctx, field)
			case "event":
				return ec.fieldContext_FunctionRun_event(ctx, field)
			case "events":
				return ec.fieldContext_FunctionRun_events(ctx, field)
			case "batchID":
				return ec.fieldContext_FunctionRun_batchID(ctx, field)
			case "batchCreatedAt":
				return ec.fieldContext_FunctionRun_batchCreatedAt(ctx, field)
			case "status":
				return ec.fieldContext_FunctionRun_status(ctx, field)
			case "waitingFor":
				return ec.fieldContext_FunctionRun_waitingFor(ctx, field)
			case "pendingSteps":
				return ec.fieldContext_FunctionRun_pendingSteps(ctx, field)
			case "startedAt":
				return ec.fieldContext_FunctionRun_startedAt(ctx, field)
			case "finishedAt":
				return ec.fieldContext_FunctionRun_finishedAt(ctx, field)
			case "output":
				return ec.fieldContext_FunctionRun_output(ctx, field)
			case "history":
				return ec.fieldContext_FunctionRun_history(ctx, field)
			case "historyItemOutput":
				return ec.fieldContext_FunctionRun_historyItemOutput(ctx, field)
			case "eventID":
				return ec.fieldContext_FunctionRun_eventID(ctx, field)
			case "cron":
				return ec.fieldContext_FunctionRun_cron(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionRun", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionEvent_type(ctx context.Context, field graphql.CollectedField, obj *models.FunctionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionEvent_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.FunctionEventType)
	fc.Result = res
	return ec.marshalOFunctionEventType2githubcominngestinngestpkgcoreapigraphmodelsFunctionEventType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionEvent_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FunctionEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionEvent_output(ctx context.Context, field graphql.CollectedField, obj *models.FunctionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionEvent_output(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionEvent_output(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionEvent_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.FunctionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionEvent_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionEvent_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_id(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_functionID(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_functionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_functionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_function(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_function(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRun().Function(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Function)
	fc.Result = res
	return ec.marshalOFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_function(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Function_id(ctx, field)
			case "name":
				return ec.fieldContext_Function_name(ctx, field)
			case "slug":
				return ec.fieldContext_Function_slug(ctx, field)
			case "config":
				return ec.fieldContext_Function_config(ctx, field)
			case "concurrency":
				return ec.fieldContext_Function_concurrency(ctx, field)
			case "triggers":
				return ec.fieldContext_Function_triggers(ctx, field)
			case "url":
				return ec.fieldContext_Function_url(ctx, field)
			case "appID":
				return ec.fieldContext_Function_appID(ctx, field)
			case "app":
				return ec.fieldContext_Function_app(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Function", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_workspace(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_workspace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workspace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Workspace)
	fc.Result = res
	return ec.marshalOWorkspace2githubcominngestinngestpkgcoreapigraphmodelsWorkspace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_workspace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workspace_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workspace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_event(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRun().Event(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	fc.Result = res
	return ec.marshalOEvent2githubcominngestinngestpkgcoreapigraphmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "externalID":
				return ec.fieldContext_Event_externalID(ctx, field)
			case "workspace":
				return ec.fieldContext_Event_workspace(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "payload":
				return ec.fieldContext_Event_payload(ctx, field)
			case "schema":
				return ec.fieldContext_Event_schema(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "pendingRuns":
				return ec.fieldContext_Event_pendingRuns(ctx, field)
			case "totalRuns":
				return ec.fieldContext_Event_totalRuns(ctx, field)
			case "raw":
				return ec.fieldContext_Event_raw(ctx, field)
			case "functionRuns":
				return ec.fieldContext_Event_functionRuns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_events(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRun().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Event)
	fc.Result = res
	return ec.marshalNEvent2githubcominngestinngestpkgcoreapigraphmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "externalID":
				return ec.fieldContext_Event_externalID(ctx, field)
			case "workspace":
				return ec.fieldContext_Event_workspace(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "payload":
				return ec.fieldContext_Event_payload(ctx, field)
			case "schema":
				return ec.fieldContext_Event_schema(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "pendingRuns":
				return ec.fieldContext_Event_pendingRuns(ctx, field)
			case "totalRuns":
				return ec.fieldContext_Event_totalRuns(ctx, field)
			case "raw":
				return ec.fieldContext_Event_raw(ctx, field)
			case "functionRuns":
				return ec.fieldContext_Event_functionRuns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_batchID(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_batchID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ulid.ULID)
	fc.Result = res
	return ec.marshalOULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_batchID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_batchCreatedAt(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_batchCreatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRun().BatchCreatedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_batchCreatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_status(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.FunctionRunStatus)
	fc.Result = res
	return ec.marshalOFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FunctionRunStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_waitingFor(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_waitingFor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRun().WaitingFor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.StepEventWait)
	fc.Result = res
	return ec.marshalOStepEventWait2githubcominngestinngestpkgcoreapigraphmodelsStepEventWait(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_waitingFor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "eventName":
				return ec.fieldContext_StepEventWait_eventName(ctx, field)
			case "expression":
				return ec.fieldContext_StepEventWait_expression(ctx, field)
			case "expiryTime":
				return ec.fieldContext_StepEventWait_expiryTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StepEventWait", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_pendingSteps(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_pendingSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRun().PendingSteps(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_pendingSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_startedAt(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_startedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_finishedAt(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_finishedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_finishedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_output(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_output(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_output(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_history(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_history(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRun().History(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*history_reader.RunHistory)
	fc.Result = res
	return ec.marshalNRunHistoryItem2githubcominngestinngestpkghistory_readerRunHistory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_history(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "attempt":
				return ec.fieldContext_RunHistoryItem_attempt(ctx, field)
			case "cancel":
				return ec.fieldContext_RunHistoryItem_cancel(ctx, field)
			case "createdAt":
				return ec.fieldContext_RunHistoryItem_createdAt(ctx, field)
			case "functionVersion":
				return ec.fieldContext_RunHistoryItem_functionVersion(ctx, field)
			case "groupID":
				return ec.fieldContext_RunHistoryItem_groupID(ctx, field)
			case "id":
				return ec.fieldContext_RunHistoryItem_id(ctx, field)
			case "result":
				return ec.fieldContext_RunHistoryItem_result(ctx, field)
			case "sleep":
				return ec.fieldContext_RunHistoryItem_sleep(ctx, field)
			case "stepName":
				return ec.fieldContext_RunHistoryItem_stepName(ctx, field)
			case "stepType":
				return ec.fieldContext_RunHistoryItem_stepType(ctx, field)
			case "type":
				return ec.fieldContext_RunHistoryItem_type(ctx, field)
			case "url":
				return ec.fieldContext_RunHistoryItem_url(ctx, field)
			case "waitForEvent":
				return ec.fieldContext_RunHistoryItem_waitForEvent(ctx, field)
			case "waitResult":
				return ec.fieldContext_RunHistoryItem_waitResult(ctx, field)
			case "invokeFunction":
				return ec.fieldContext_RunHistoryItem_invokeFunction(ctx, field)
			case "invokeFunctionResult":
				return ec.fieldContext_RunHistoryItem_invokeFunctionResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunHistoryItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_historyItemOutput(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_historyItemOutput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRun().HistoryItemOutput(rctx, obj, fc.Args["id"].(ulid.ULID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_historyItemOutput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FunctionRun_historyItemOutput_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_eventID(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_eventID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_eventID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRun_cron(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRun_cron(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cron, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRun_cron(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_id(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ulid.ULID)
	fc.Result = res
	return ec.marshalNULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_appID(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_appID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomgoogleuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_appID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_app(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_app(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRunV2().App(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cqrs.App)
	fc.Result = res
	return ec.marshalNApp2githubcominngestinngestpkgcqrsApp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_app(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_App_id(ctx, field)
			case "externalID":
				return ec.fieldContext_App_externalID(ctx, field)
			case "name":
				return ec.fieldContext_App_name(ctx, field)
			case "sdkLanguage":
				return ec.fieldContext_App_sdkLanguage(ctx, field)
			case "sdkVersion":
				return ec.fieldContext_App_sdkVersion(ctx, field)
			case "framework":
				return ec.fieldContext_App_framework(ctx, field)
			case "url":
				return ec.fieldContext_App_url(ctx, field)
			case "checksum":
				return ec.fieldContext_App_checksum(ctx, field)
			case "error":
				return ec.fieldContext_App_error(ctx, field)
			case "functions":
				return ec.fieldContext_App_functions(ctx, field)
			case "connected":
				return ec.fieldContext_App_connected(ctx, field)
			case "functionCount":
				return ec.fieldContext_App_functionCount(ctx, field)
			case "autodiscovered":
				return ec.fieldContext_App_autodiscovered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type App", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_functionID(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_functionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomgoogleuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_functionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_function(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_function(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRunV2().Function(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Function)
	fc.Result = res
	return ec.marshalNFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_function(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Function_id(ctx, field)
			case "name":
				return ec.fieldContext_Function_name(ctx, field)
			case "slug":
				return ec.fieldContext_Function_slug(ctx, field)
			case "config":
				return ec.fieldContext_Function_config(ctx, field)
			case "concurrency":
				return ec.fieldContext_Function_concurrency(ctx, field)
			case "triggers":
				return ec.fieldContext_Function_triggers(ctx, field)
			case "url":
				return ec.fieldContext_Function_url(ctx, field)
			case "appID":
				return ec.fieldContext_Function_appID(ctx, field)
			case "app":
				return ec.fieldContext_Function_app(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Function", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_traceID(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_traceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TraceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_traceID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_queuedAt(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_queuedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueuedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_queuedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_startedAt(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_startedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_endedAt(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_endedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_endedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_status(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.FunctionRunStatus)
	fc.Result = res
	return ec.marshalNFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FunctionRunStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_sourceID(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_sourceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_sourceID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_triggerIDs(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_triggerIDs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ulid.ULID)
	fc.Result = res
	return ec.marshalNULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_triggerIDs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_eventName(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_eventName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_eventName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_isBatch(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_isBatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsBatch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_isBatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_batchCreatedAt(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_batchCreatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchCreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_batchCreatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_cronSchedule(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_cronSchedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CronSchedule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_cronSchedule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_output(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_output(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOBytes2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_output(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2_trace(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2_trace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FunctionRunV2().Trace(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RunTraceSpan)
	fc.Result = res
	return ec.marshalORunTraceSpan2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2_trace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appID":
				return ec.fieldContext_RunTraceSpan_appID(ctx, field)
			case "functionID":
				return ec.fieldContext_RunTraceSpan_functionID(ctx, field)
			case "runID":
				return ec.fieldContext_RunTraceSpan_runID(ctx, field)
			case "run":
				return ec.fieldContext_RunTraceSpan_run(ctx, field)
			case "spanID":
				return ec.fieldContext_RunTraceSpan_spanID(ctx, field)
			case "traceID":
				return ec.fieldContext_RunTraceSpan_traceID(ctx, field)
			case "name":
				return ec.fieldContext_RunTraceSpan_name(ctx, field)
			case "status":
				return ec.fieldContext_RunTraceSpan_status(ctx, field)
			case "attempts":
				return ec.fieldContext_RunTraceSpan_attempts(ctx, field)
			case "duration":
				return ec.fieldContext_RunTraceSpan_duration(ctx, field)
			case "outputID":
				return ec.fieldContext_RunTraceSpan_outputID(ctx, field)
			case "queuedAt":
				return ec.fieldContext_RunTraceSpan_queuedAt(ctx, field)
			case "startedAt":
				return ec.fieldContext_RunTraceSpan_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_RunTraceSpan_endedAt(ctx, field)
			case "childrenSpans":
				return ec.fieldContext_RunTraceSpan_childrenSpans(ctx, field)
			case "stepOp":
				return ec.fieldContext_RunTraceSpan_stepOp(ctx, field)
			case "stepID":
				return ec.fieldContext_RunTraceSpan_stepID(ctx, field)
			case "stepInfo":
				return ec.fieldContext_RunTraceSpan_stepInfo(ctx, field)
			case "isRoot":
				return ec.fieldContext_RunTraceSpan_isRoot(ctx, field)
			case "parentSpanID":
				return ec.fieldContext_RunTraceSpan_parentSpanID(ctx, field)
			case "parentSpan":
				return ec.fieldContext_RunTraceSpan_parentSpan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunTraceSpan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2Edge_node(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2Edge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2Edge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.FunctionRunV2)
	fc.Result = res
	return ec.marshalNFunctionRunV22githubcominngestinngestpkgcoreapigraphmodelsFunctionRunV2(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2Edge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2Edge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FunctionRunV2_id(ctx, field)
			case "appID":
				return ec.fieldContext_FunctionRunV2_appID(ctx, field)
			case "app":
				return ec.fieldContext_FunctionRunV2_app(ctx, field)
			case "functionID":
				return ec.fieldContext_FunctionRunV2_functionID(ctx, field)
			case "function":
				return ec.fieldContext_FunctionRunV2_function(ctx, field)
			case "traceID":
				return ec.fieldContext_FunctionRunV2_traceID(ctx, field)
			case "queuedAt":
				return ec.fieldContext_FunctionRunV2_queuedAt(ctx, field)
			case "startedAt":
				return ec.fieldContext_FunctionRunV2_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_FunctionRunV2_endedAt(ctx, field)
			case "status":
				return ec.fieldContext_FunctionRunV2_status(ctx, field)
			case "sourceID":
				return ec.fieldContext_FunctionRunV2_sourceID(ctx, field)
			case "triggerIDs":
				return ec.fieldContext_FunctionRunV2_triggerIDs(ctx, field)
			case "eventName":
				return ec.fieldContext_FunctionRunV2_eventName(ctx, field)
			case "isBatch":
				return ec.fieldContext_FunctionRunV2_isBatch(ctx, field)
			case "batchCreatedAt":
				return ec.fieldContext_FunctionRunV2_batchCreatedAt(ctx, field)
			case "cronSchedule":
				return ec.fieldContext_FunctionRunV2_cronSchedule(ctx, field)
			case "output":
				return ec.fieldContext_FunctionRunV2_output(ctx, field)
			case "trace":
				return ec.fieldContext_FunctionRunV2_trace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionRunV2", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionRunV2Edge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.FunctionRunV2Edge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionRunV2Edge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionRunV2Edge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionRunV2Edge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionTrigger_type(ctx context.Context, field graphql.CollectedField, obj *models.FunctionTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionTrigger_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.FunctionTriggerTypes)
	fc.Result = res
	return ec.marshalNFunctionTriggerTypes2githubcominngestinngestpkgcoreapigraphmodelsFunctionTriggerTypes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionTrigger_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FunctionTriggerTypes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionTrigger_value(ctx context.Context, field graphql.CollectedField, obj *models.FunctionTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionTrigger_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionTrigger_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionVersion_functionId(ctx context.Context, field graphql.CollectedField, obj *function.FunctionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionVersion_functionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionVersion_functionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionVersion_version(ctx context.Context, field graphql.CollectedField, obj *function.FunctionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionVersion_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionVersion_config(ctx context.Context, field graphql.CollectedField, obj *function.FunctionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionVersion_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionVersion_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionVersion_validFrom(ctx context.Context, field graphql.CollectedField, obj *function.FunctionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionVersion_validFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionVersion_validFrom(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionVersion_validTo(ctx context.Context, field graphql.CollectedField, obj *function.FunctionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionVersion_validTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionVersion_validTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionVersion_createdAt(ctx context.Context, field graphql.CollectedField, obj *function.FunctionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionVersion_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionVersion_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionVersion_updatedAt(ctx context.Context, field graphql.CollectedField, obj *function.FunctionVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionVersion_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionVersion_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvokeStepInfo_triggeringEventID(ctx context.Context, field graphql.CollectedField, obj *models.InvokeStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvokeStepInfo_triggeringEventID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggeringEventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ulid.ULID)
	fc.Result = res
	return ec.marshalNULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvokeStepInfo_triggeringEventID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvokeStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvokeStepInfo_functionID(ctx context.Context, field graphql.CollectedField, obj *models.InvokeStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvokeStepInfo_functionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvokeStepInfo_functionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvokeStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvokeStepInfo_timeout(ctx context.Context, field graphql.CollectedField, obj *models.InvokeStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvokeStepInfo_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvokeStepInfo_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvokeStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvokeStepInfo_returnEventID(ctx context.Context, field graphql.CollectedField, obj *models.InvokeStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvokeStepInfo_returnEventID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReturnEventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ulid.ULID)
	fc.Result = res
	return ec.marshalOULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvokeStepInfo_returnEventID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvokeStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvokeStepInfo_runID(ctx context.Context, field graphql.CollectedField, obj *models.InvokeStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvokeStepInfo_runID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ulid.ULID)
	fc.Result = res
	return ec.marshalOULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvokeStepInfo_runID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvokeStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvokeStepInfo_timedOut(ctx context.Context, field graphql.CollectedField, obj *models.InvokeStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvokeStepInfo_timedOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimedOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvokeStepInfo_timedOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvokeStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createApp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createApp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateApp(rctx, fc.Args["input"].(models.CreateAppInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cqrs.App)
	fc.Result = res
	return ec.marshalNApp2githubcominngestinngestpkgcqrsApp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createApp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_App_id(ctx, field)
			case "externalID":
				return ec.fieldContext_App_externalID(ctx, field)
			case "name":
				return ec.fieldContext_App_name(ctx, field)
			case "sdkLanguage":
				return ec.fieldContext_App_sdkLanguage(ctx, field)
			case "sdkVersion":
				return ec.fieldContext_App_sdkVersion(ctx, field)
			case "framework":
				return ec.fieldContext_App_framework(ctx, field)
			case "url":
				return ec.fieldContext_App_url(ctx, field)
			case "checksum":
				return ec.fieldContext_App_checksum(ctx, field)
			case "error":
				return ec.fieldContext_App_error(ctx, field)
			case "functions":
				return ec.fieldContext_App_functions(ctx, field)
			case "connected":
				return ec.fieldContext_App_connected(ctx, field)
			case "functionCount":
				return ec.fieldContext_App_functionCount(ctx, field)
			case "autodiscovered":
				return ec.fieldContext_App_autodiscovered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type App", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createApp_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateApp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateApp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateApp(rctx, fc.Args["input"].(models.UpdateAppInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*cqrs.App)
	fc.Result = res
	return ec.marshalNApp2githubcominngestinngestpkgcqrsApp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateApp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_App_id(ctx, field)
			case "externalID":
				return ec.fieldContext_App_externalID(ctx, field)
			case "name":
				return ec.fieldContext_App_name(ctx, field)
			case "sdkLanguage":
				return ec.fieldContext_App_sdkLanguage(ctx, field)
			case "sdkVersion":
				return ec.fieldContext_App_sdkVersion(ctx, field)
			case "framework":
				return ec.fieldContext_App_framework(ctx, field)
			case "url":
				return ec.fieldContext_App_url(ctx, field)
			case "checksum":
				return ec.fieldContext_App_checksum(ctx, field)
			case "error":
				return ec.fieldContext_App_error(ctx, field)
			case "functions":
				return ec.fieldContext_App_functions(ctx, field)
			case "connected":
				return ec.fieldContext_App_connected(ctx, field)
			case "functionCount":
				return ec.fieldContext_App_functionCount(ctx, field)
			case "autodiscovered":
				return ec.fieldContext_App_autodiscovered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type App", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateApp_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteApp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteApp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteApp(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteApp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteApp_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteAppByName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteAppByName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteAppByName(rctx, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteAppByName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteAppByName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_invokeFunction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_invokeFunction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().InvokeFunction(rctx, fc.Args["data"].(map[string]interface{}), fc.Args["functionSlug"].(string), fc.Args["user"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_invokeFunction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_invokeFunction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelRun(rctx, fc.Args["runID"].(ulid.ULID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.FunctionRun)
	fc.Result = res
	return ec.marshalNFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelRun(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FunctionRun_id(ctx, field)
			case "functionID":
				return ec.fieldContext_FunctionRun_functionID(ctx, field)
			case "function":
				return ec.fieldContext_FunctionRun_function(ctx, field)
			case "workspace":
				return ec.fieldContext_FunctionRun_workspace(ctx, field)
			case "event":
				return ec.fieldContext_FunctionRun_event(ctx, field)
			case "events":
				return ec.fieldContext_FunctionRun_events(ctx, field)
			case "batchID":
				return ec.fieldContext_FunctionRun_batchID(ctx, field)
			case "batchCreatedAt":
				return ec.fieldContext_FunctionRun_batchCreatedAt(ctx, field)
			case "status":
				return ec.fieldContext_FunctionRun_status(ctx, field)
			case "waitingFor":
				return ec.fieldContext_FunctionRun_waitingFor(ctx, field)
			case "pendingSteps":
				return ec.fieldContext_FunctionRun_pendingSteps(ctx, field)
			case "startedAt":
				return ec.fieldContext_FunctionRun_startedAt(ctx, field)
			case "finishedAt":
				return ec.fieldContext_FunctionRun_finishedAt(ctx, field)
			case "output":
				return ec.fieldContext_FunctionRun_output(ctx, field)
			case "history":
				return ec.fieldContext_FunctionRun_history(ctx, field)
			case "historyItemOutput":
				return ec.fieldContext_FunctionRun_historyItemOutput(ctx, field)
			case "eventID":
				return ec.fieldContext_FunctionRun_eventID(ctx, field)
			case "cron":
				return ec.fieldContext_FunctionRun_cron(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionRun", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelRun_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rerun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rerun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Rerun(rctx, fc.Args["runID"].(ulid.ULID), fc.Args["fromStep"].(*models.RerunFromStepInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ulid.ULID)
	fc.Result = res
	return ec.marshalNULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rerun(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rerun_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_apps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_apps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Apps(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*cqrs.App)
	fc.Result = res
	return ec.marshalNApp2githubcominngestinngestpkgcqrsApp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_apps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_App_id(ctx, field)
			case "externalID":
				return ec.fieldContext_App_externalID(ctx, field)
			case "name":
				return ec.fieldContext_App_name(ctx, field)
			case "sdkLanguage":
				return ec.fieldContext_App_sdkLanguage(ctx, field)
			case "sdkVersion":
				return ec.fieldContext_App_sdkVersion(ctx, field)
			case "framework":
				return ec.fieldContext_App_framework(ctx, field)
			case "url":
				return ec.fieldContext_App_url(ctx, field)
			case "checksum":
				return ec.fieldContext_App_checksum(ctx, field)
			case "error":
				return ec.fieldContext_App_error(ctx, field)
			case "functions":
				return ec.fieldContext_App_functions(ctx, field)
			case "connected":
				return ec.fieldContext_App_connected(ctx, field)
			case "functionCount":
				return ec.fieldContext_App_functionCount(ctx, field)
			case "autodiscovered":
				return ec.fieldContext_App_autodiscovered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type App", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_stream(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_stream(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Stream(rctx, fc.Args["query"].(models.StreamQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.StreamItem)
	fc.Result = res
	return ec.marshalNStreamItem2githubcominngestinngestpkgcoreapigraphmodelsStreamItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_stream(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_StreamItem_id(ctx, field)
			case "trigger":
				return ec.fieldContext_StreamItem_trigger(ctx, field)
			case "type":
				return ec.fieldContext_StreamItem_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_StreamItem_createdAt(ctx, field)
			case "runs":
				return ec.fieldContext_StreamItem_runs(ctx, field)
			case "inBatch":
				return ec.fieldContext_StreamItem_inBatch(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StreamItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_stream_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_event(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Event(rctx, fc.Args["query"].(models.EventQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	fc.Result = res
	return ec.marshalOEvent2githubcominngestinngestpkgcoreapigraphmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "externalID":
				return ec.fieldContext_Event_externalID(ctx, field)
			case "workspace":
				return ec.fieldContext_Event_workspace(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "payload":
				return ec.fieldContext_Event_payload(ctx, field)
			case "schema":
				return ec.fieldContext_Event_schema(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "pendingRuns":
				return ec.fieldContext_Event_pendingRuns(ctx, field)
			case "totalRuns":
				return ec.fieldContext_Event_totalRuns(ctx, field)
			case "raw":
				return ec.fieldContext_Event_raw(ctx, field)
			case "functionRuns":
				return ec.fieldContext_Event_functionRuns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_event_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_events(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Events(rctx, fc.Args["query"].(models.EventsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Event)
	fc.Result = res
	return ec.marshalOEvent2githubcominngestinngestpkgcoreapigraphmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "externalID":
				return ec.fieldContext_Event_externalID(ctx, field)
			case "workspace":
				return ec.fieldContext_Event_workspace(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "payload":
				return ec.fieldContext_Event_payload(ctx, field)
			case "schema":
				return ec.fieldContext_Event_schema(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "pendingRuns":
				return ec.fieldContext_Event_pendingRuns(ctx, field)
			case "totalRuns":
				return ec.fieldContext_Event_totalRuns(ctx, field)
			case "raw":
				return ec.fieldContext_Event_raw(ctx, field)
			case "functionRuns":
				return ec.fieldContext_Event_functionRuns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_functions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_functions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Functions(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Function)
	fc.Result = res
	return ec.marshalOFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_functions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Function_id(ctx, field)
			case "name":
				return ec.fieldContext_Function_name(ctx, field)
			case "slug":
				return ec.fieldContext_Function_slug(ctx, field)
			case "config":
				return ec.fieldContext_Function_config(ctx, field)
			case "concurrency":
				return ec.fieldContext_Function_concurrency(ctx, field)
			case "triggers":
				return ec.fieldContext_Function_triggers(ctx, field)
			case "url":
				return ec.fieldContext_Function_url(ctx, field)
			case "appID":
				return ec.fieldContext_Function_appID(ctx, field)
			case "app":
				return ec.fieldContext_Function_app(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Function", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_functionRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_functionRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FunctionRun(rctx, fc.Args["query"].(models.FunctionRunQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.FunctionRun)
	fc.Result = res
	return ec.marshalOFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_functionRun(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FunctionRun_id(ctx, field)
			case "functionID":
				return ec.fieldContext_FunctionRun_functionID(ctx, field)
			case "function":
				return ec.fieldContext_FunctionRun_function(ctx, field)
			case "workspace":
				return ec.fieldContext_FunctionRun_workspace(ctx, field)
			case "event":
				return ec.fieldContext_FunctionRun_event(ctx, field)
			case "events":
				return ec.fieldContext_FunctionRun_events(ctx, field)
			case "batchID":
				return ec.fieldContext_FunctionRun_batchID(ctx, field)
			case "batchCreatedAt":
				return ec.fieldContext_FunctionRun_batchCreatedAt(ctx, field)
			case "status":
				return ec.fieldContext_FunctionRun_status(ctx, field)
			case "waitingFor":
				return ec.fieldContext_FunctionRun_waitingFor(ctx, field)
			case "pendingSteps":
				return ec.fieldContext_FunctionRun_pendingSteps(ctx, field)
			case "startedAt":
				return ec.fieldContext_FunctionRun_startedAt(ctx, field)
			case "finishedAt":
				return ec.fieldContext_FunctionRun_finishedAt(ctx, field)
			case "output":
				return ec.fieldContext_FunctionRun_output(ctx, field)
			case "history":
				return ec.fieldContext_FunctionRun_history(ctx, field)
			case "historyItemOutput":
				return ec.fieldContext_FunctionRun_historyItemOutput(ctx, field)
			case "eventID":
				return ec.fieldContext_FunctionRun_eventID(ctx, field)
			case "cron":
				return ec.fieldContext_FunctionRun_cron(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionRun", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_functionRun_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_runs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Runs(rctx, fc.Args["first"].(int), fc.Args["after"].(*string), fc.Args["orderBy"].([]*models.RunsV2OrderBy), fc.Args["filter"].(models.RunsFilterV2))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RunsV2Connection)
	fc.Result = res
	return ec.marshalNRunsV2Connection2githubcominngestinngestpkgcoreapigraphmodelsRunsV2Connection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_RunsV2Connection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RunsV2Connection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RunsV2Connection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunsV2Connection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_runs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_run(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_run(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Run(rctx, fc.Args["runID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.FunctionRunV2)
	fc.Result = res
	return ec.marshalOFunctionRunV22githubcominngestinngestpkgcoreapigraphmodelsFunctionRunV2(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_run(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FunctionRunV2_id(ctx, field)
			case "appID":
				return ec.fieldContext_FunctionRunV2_appID(ctx, field)
			case "app":
				return ec.fieldContext_FunctionRunV2_app(ctx, field)
			case "functionID":
				return ec.fieldContext_FunctionRunV2_functionID(ctx, field)
			case "function":
				return ec.fieldContext_FunctionRunV2_function(ctx, field)
			case "traceID":
				return ec.fieldContext_FunctionRunV2_traceID(ctx, field)
			case "queuedAt":
				return ec.fieldContext_FunctionRunV2_queuedAt(ctx, field)
			case "startedAt":
				return ec.fieldContext_FunctionRunV2_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_FunctionRunV2_endedAt(ctx, field)
			case "status":
				return ec.fieldContext_FunctionRunV2_status(ctx, field)
			case "sourceID":
				return ec.fieldContext_FunctionRunV2_sourceID(ctx, field)
			case "triggerIDs":
				return ec.fieldContext_FunctionRunV2_triggerIDs(ctx, field)
			case "eventName":
				return ec.fieldContext_FunctionRunV2_eventName(ctx, field)
			case "isBatch":
				return ec.fieldContext_FunctionRunV2_isBatch(ctx, field)
			case "batchCreatedAt":
				return ec.fieldContext_FunctionRunV2_batchCreatedAt(ctx, field)
			case "cronSchedule":
				return ec.fieldContext_FunctionRunV2_cronSchedule(ctx, field)
			case "output":
				return ec.fieldContext_FunctionRunV2_output(ctx, field)
			case "trace":
				return ec.fieldContext_FunctionRunV2_trace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionRunV2", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_run_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_runTraceSpanOutputByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runTraceSpanOutputByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RunTraceSpanOutputByID(rctx, fc.Args["outputID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RunTraceSpanOutput)
	fc.Result = res
	return ec.marshalNRunTraceSpanOutput2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpanOutput(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runTraceSpanOutputByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "input":
				return ec.fieldContext_RunTraceSpanOutput_input(ctx, field)
			case "data":
				return ec.fieldContext_RunTraceSpanOutput_data(ctx, field)
			case "error":
				return ec.fieldContext_RunTraceSpanOutput_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunTraceSpanOutput", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_runTraceSpanOutputByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_runTrigger(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runTrigger(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RunTrigger(rctx, fc.Args["runID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RunTraceTrigger)
	fc.Result = res
	return ec.marshalNRunTraceTrigger2githubcominngestinngestpkgcoreapigraphmodelsRunTraceTrigger(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runTrigger(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "eventName":
				return ec.fieldContext_RunTraceTrigger_eventName(ctx, field)
			case "IDs":
				return ec.fieldContext_RunTraceTrigger_IDs(ctx, field)
			case "payloads":
				return ec.fieldContext_RunTraceTrigger_payloads(ctx, field)
			case "timestamp":
				return ec.fieldContext_RunTraceTrigger_timestamp(ctx, field)
			case "isBatch":
				return ec.fieldContext_RunTraceTrigger_isBatch(ctx, field)
			case "batchID":
				return ec.fieldContext_RunTraceTrigger_batchID(ctx, field)
			case "cron":
				return ec.fieldContext_RunTraceTrigger_cron(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunTraceTrigger", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_runTrigger_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryCancel_eventID(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryCancel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryCancel_eventID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ulid.ULID)
	fc.Result = res
	return ec.marshalOULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryCancel_eventID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryCancel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryCancel_expression(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryCancel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryCancel_expression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryCancel_expression(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryCancel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryCancel_userID(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryCancel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryCancel_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2githubcomgoogleuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryCancel_userID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryCancel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryInvokeFunction_eventID(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryInvokeFunction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryInvokeFunction_eventID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ulid.ULID)
	fc.Result = res
	return ec.marshalNULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryInvokeFunction_eventID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryInvokeFunction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryInvokeFunction_functionID(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryInvokeFunction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryInvokeFunction_functionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryInvokeFunction_functionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryInvokeFunction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryInvokeFunction_correlationID(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryInvokeFunction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryInvokeFunction_correlationID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CorrelationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryInvokeFunction_correlationID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryInvokeFunction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryInvokeFunction_timeout(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryInvokeFunction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryInvokeFunction_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryInvokeFunction_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryInvokeFunction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryInvokeFunctionResult_eventID(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryInvokeFunctionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryInvokeFunctionResult_eventID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ulid.ULID)
	fc.Result = res
	return ec.marshalOULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryInvokeFunctionResult_eventID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryInvokeFunctionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryInvokeFunctionResult_timeout(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryInvokeFunctionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryInvokeFunctionResult_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryInvokeFunctionResult_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryInvokeFunctionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryInvokeFunctionResult_runID(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryInvokeFunctionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryInvokeFunctionResult_runID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ulid.ULID)
	fc.Result = res
	return ec.marshalOULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryInvokeFunctionResult_runID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryInvokeFunctionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_attempt(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_attempt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Attempt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_attempt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_cancel(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_cancel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cancel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*history_reader.RunHistoryCancel)
	fc.Result = res
	return ec.marshalORunHistoryCancel2githubcominngestinngestpkghistory_readerRunHistoryCancel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_cancel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "eventID":
				return ec.fieldContext_RunHistoryCancel_eventID(ctx, field)
			case "expression":
				return ec.fieldContext_RunHistoryCancel_expression(ctx, field)
			case "userID":
				return ec.fieldContext_RunHistoryCancel_userID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunHistoryCancel", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_createdAt(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_functionVersion(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_functionVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_functionVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_groupID(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_groupID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2githubcomgoogleuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_groupID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_id(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ulid.ULID)
	fc.Result = res
	return ec.marshalNULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_result(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*history_reader.RunHistoryResult)
	fc.Result = res
	return ec.marshalORunHistoryResult2githubcominngestinngestpkghistory_readerRunHistoryResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_result(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "durationMS":
				return ec.fieldContext_RunHistoryResult_durationMS(ctx, field)
			case "errorCode":
				return ec.fieldContext_RunHistoryResult_errorCode(ctx, field)
			case "framework":
				return ec.fieldContext_RunHistoryResult_framework(ctx, field)
			case "platform":
				return ec.fieldContext_RunHistoryResult_platform(ctx, field)
			case "sdkLanguage":
				return ec.fieldContext_RunHistoryResult_sdkLanguage(ctx, field)
			case "sdkVersion":
				return ec.fieldContext_RunHistoryResult_sdkVersion(ctx, field)
			case "sizeBytes":
				return ec.fieldContext_RunHistoryResult_sizeBytes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunHistoryResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_sleep(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_sleep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sleep, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*history_reader.RunHistorySleep)
	fc.Result = res
	return ec.marshalORunHistorySleep2githubcominngestinngestpkghistory_readerRunHistorySleep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_sleep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "until":
				return ec.fieldContext_RunHistorySleep_until(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunHistorySleep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_stepName(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_stepName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_stepName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_stepType(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_stepType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*enums.HistoryStepType)
	fc.Result = res
	return ec.marshalOHistoryStepType2githubcominngestinngestpkgenumsHistoryStepType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_stepType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HistoryStepType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_type(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(enums.HistoryType)
	fc.Result = res
	return ec.marshalNHistoryType2githubcominngestinngestpkgenumsHistoryType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HistoryType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_url(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_waitForEvent(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_waitForEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WaitForEvent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*history_reader.RunHistoryWaitForEvent)
	fc.Result = res
	return ec.marshalORunHistoryWaitForEvent2githubcominngestinngestpkghistory_readerRunHistoryWaitForEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_waitForEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "eventName":
				return ec.fieldContext_RunHistoryWaitForEvent_eventName(ctx, field)
			case "expression":
				return ec.fieldContext_RunHistoryWaitForEvent_expression(ctx, field)
			case "timeout":
				return ec.fieldContext_RunHistoryWaitForEvent_timeout(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunHistoryWaitForEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_waitResult(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_waitResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WaitResult, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*history_reader.RunHistoryWaitResult)
	fc.Result = res
	return ec.marshalORunHistoryWaitResult2githubcominngestinngestpkghistory_readerRunHistoryWaitResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_waitResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "eventID":
				return ec.fieldContext_RunHistoryWaitResult_eventID(ctx, field)
			case "timeout":
				return ec.fieldContext_RunHistoryWaitResult_timeout(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunHistoryWaitResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_invokeFunction(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_invokeFunction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvokeFunction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*history_reader.RunHistoryInvokeFunction)
	fc.Result = res
	return ec.marshalORunHistoryInvokeFunction2githubcominngestinngestpkghistory_readerRunHistoryInvokeFunction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_invokeFunction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "eventID":
				return ec.fieldContext_RunHistoryInvokeFunction_eventID(ctx, field)
			case "functionID":
				return ec.fieldContext_RunHistoryInvokeFunction_functionID(ctx, field)
			case "correlationID":
				return ec.fieldContext_RunHistoryInvokeFunction_correlationID(ctx, field)
			case "timeout":
				return ec.fieldContext_RunHistoryInvokeFunction_timeout(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunHistoryInvokeFunction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryItem_invokeFunctionResult(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryItem_invokeFunctionResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvokeFunctionResult, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*history_reader.RunHistoryInvokeFunctionResult)
	fc.Result = res
	return ec.marshalORunHistoryInvokeFunctionResult2githubcominngestinngestpkghistory_readerRunHistoryInvokeFunctionResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryItem_invokeFunctionResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "eventID":
				return ec.fieldContext_RunHistoryInvokeFunctionResult_eventID(ctx, field)
			case "timeout":
				return ec.fieldContext_RunHistoryInvokeFunctionResult_timeout(ctx, field)
			case "runID":
				return ec.fieldContext_RunHistoryInvokeFunctionResult_runID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunHistoryInvokeFunctionResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryResult_durationMS(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryResult_durationMS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DurationMS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryResult_durationMS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryResult_errorCode(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryResult_errorCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryResult_errorCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryResult_framework(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryResult_framework(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Framework, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryResult_framework(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryResult_platform(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryResult_platform(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platform, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryResult_platform(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryResult_sdkLanguage(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryResult_sdkLanguage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SDKLanguage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryResult_sdkLanguage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryResult_sdkVersion(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryResult_sdkVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SDKVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryResult_sdkVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryResult_sizeBytes(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryResult_sizeBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SizeBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryResult_sizeBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistorySleep_until(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistorySleep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistorySleep_until(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Until, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistorySleep_until(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistorySleep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryWaitForEvent_eventName(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryWaitForEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryWaitForEvent_eventName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryWaitForEvent_eventName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryWaitForEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryWaitForEvent_expression(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryWaitForEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryWaitForEvent_expression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryWaitForEvent_expression(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryWaitForEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryWaitForEvent_timeout(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryWaitForEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryWaitForEvent_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryWaitForEvent_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryWaitForEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryWaitResult_eventID(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryWaitResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryWaitResult_eventID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ulid.ULID)
	fc.Result = res
	return ec.marshalOULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryWaitResult_eventID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryWaitResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunHistoryWaitResult_timeout(ctx context.Context, field graphql.CollectedField, obj *history_reader.RunHistoryWaitResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunHistoryWaitResult_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunHistoryWaitResult_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunHistoryWaitResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunStepInfo_type(ctx context.Context, field graphql.CollectedField, obj *models.RunStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunStepInfo_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunStepInfo_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_appID(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_appID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomgoogleuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_appID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_functionID(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_functionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubcomgoogleuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_functionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_runID(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_runID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ulid.ULID)
	fc.Result = res
	return ec.marshalNULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_runID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_run(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_run(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Run, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.FunctionRun)
	fc.Result = res
	return ec.marshalNFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_run(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FunctionRun_id(ctx, field)
			case "functionID":
				return ec.fieldContext_FunctionRun_functionID(ctx, field)
			case "function":
				return ec.fieldContext_FunctionRun_function(ctx, field)
			case "workspace":
				return ec.fieldContext_FunctionRun_workspace(ctx, field)
			case "event":
				return ec.fieldContext_FunctionRun_event(ctx, field)
			case "events":
				return ec.fieldContext_FunctionRun_events(ctx, field)
			case "batchID":
				return ec.fieldContext_FunctionRun_batchID(ctx, field)
			case "batchCreatedAt":
				return ec.fieldContext_FunctionRun_batchCreatedAt(ctx, field)
			case "status":
				return ec.fieldContext_FunctionRun_status(ctx, field)
			case "waitingFor":
				return ec.fieldContext_FunctionRun_waitingFor(ctx, field)
			case "pendingSteps":
				return ec.fieldContext_FunctionRun_pendingSteps(ctx, field)
			case "startedAt":
				return ec.fieldContext_FunctionRun_startedAt(ctx, field)
			case "finishedAt":
				return ec.fieldContext_FunctionRun_finishedAt(ctx, field)
			case "output":
				return ec.fieldContext_FunctionRun_output(ctx, field)
			case "history":
				return ec.fieldContext_FunctionRun_history(ctx, field)
			case "historyItemOutput":
				return ec.fieldContext_FunctionRun_historyItemOutput(ctx, field)
			case "eventID":
				return ec.fieldContext_FunctionRun_eventID(ctx, field)
			case "cron":
				return ec.fieldContext_FunctionRun_cron(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionRun", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_spanID(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_spanID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpanID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_spanID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_traceID(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_traceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TraceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_traceID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_name(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_status(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.RunTraceSpanStatus)
	fc.Result = res
	return ec.marshalNRunTraceSpanStatus2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpanStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RunTraceSpanStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_attempts(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_attempts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Attempts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_attempts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_duration(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_outputID(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_outputID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutputID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_outputID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_queuedAt(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_queuedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueuedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_queuedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_startedAt(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_startedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_endedAt(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_endedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_endedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_childrenSpans(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_childrenSpans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildrenSpans, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.RunTraceSpan)
	fc.Result = res
	return ec.marshalNRunTraceSpan2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_childrenSpans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appID":
				return ec.fieldContext_RunTraceSpan_appID(ctx, field)
			case "functionID":
				return ec.fieldContext_RunTraceSpan_functionID(ctx, field)
			case "runID":
				return ec.fieldContext_RunTraceSpan_runID(ctx, field)
			case "run":
				return ec.fieldContext_RunTraceSpan_run(ctx, field)
			case "spanID":
				return ec.fieldContext_RunTraceSpan_spanID(ctx, field)
			case "traceID":
				return ec.fieldContext_RunTraceSpan_traceID(ctx, field)
			case "name":
				return ec.fieldContext_RunTraceSpan_name(ctx, field)
			case "status":
				return ec.fieldContext_RunTraceSpan_status(ctx, field)
			case "attempts":
				return ec.fieldContext_RunTraceSpan_attempts(ctx, field)
			case "duration":
				return ec.fieldContext_RunTraceSpan_duration(ctx, field)
			case "outputID":
				return ec.fieldContext_RunTraceSpan_outputID(ctx, field)
			case "queuedAt":
				return ec.fieldContext_RunTraceSpan_queuedAt(ctx, field)
			case "startedAt":
				return ec.fieldContext_RunTraceSpan_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_RunTraceSpan_endedAt(ctx, field)
			case "childrenSpans":
				return ec.fieldContext_RunTraceSpan_childrenSpans(ctx, field)
			case "stepOp":
				return ec.fieldContext_RunTraceSpan_stepOp(ctx, field)
			case "stepID":
				return ec.fieldContext_RunTraceSpan_stepID(ctx, field)
			case "stepInfo":
				return ec.fieldContext_RunTraceSpan_stepInfo(ctx, field)
			case "isRoot":
				return ec.fieldContext_RunTraceSpan_isRoot(ctx, field)
			case "parentSpanID":
				return ec.fieldContext_RunTraceSpan_parentSpanID(ctx, field)
			case "parentSpan":
				return ec.fieldContext_RunTraceSpan_parentSpan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunTraceSpan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_stepOp(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_stepOp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepOp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.StepOp)
	fc.Result = res
	return ec.marshalOStepOp2githubcominngestinngestpkgcoreapigraphmodelsStepOp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_stepOp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StepOp does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_stepID(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_stepID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_stepID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_stepInfo(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_stepInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.StepInfo)
	fc.Result = res
	return ec.marshalOStepInfo2githubcominngestinngestpkgcoreapigraphmodelsStepInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_stepInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StepInfo does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_isRoot(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_isRoot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRoot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_isRoot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_parentSpanID(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_parentSpanID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentSpanID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_parentSpanID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpan_parentSpan(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpan_parentSpan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentSpan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RunTraceSpan)
	fc.Result = res
	return ec.marshalORunTraceSpan2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpan_parentSpan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appID":
				return ec.fieldContext_RunTraceSpan_appID(ctx, field)
			case "functionID":
				return ec.fieldContext_RunTraceSpan_functionID(ctx, field)
			case "runID":
				return ec.fieldContext_RunTraceSpan_runID(ctx, field)
			case "run":
				return ec.fieldContext_RunTraceSpan_run(ctx, field)
			case "spanID":
				return ec.fieldContext_RunTraceSpan_spanID(ctx, field)
			case "traceID":
				return ec.fieldContext_RunTraceSpan_traceID(ctx, field)
			case "name":
				return ec.fieldContext_RunTraceSpan_name(ctx, field)
			case "status":
				return ec.fieldContext_RunTraceSpan_status(ctx, field)
			case "attempts":
				return ec.fieldContext_RunTraceSpan_attempts(ctx, field)
			case "duration":
				return ec.fieldContext_RunTraceSpan_duration(ctx, field)
			case "outputID":
				return ec.fieldContext_RunTraceSpan_outputID(ctx, field)
			case "queuedAt":
				return ec.fieldContext_RunTraceSpan_queuedAt(ctx, field)
			case "startedAt":
				return ec.fieldContext_RunTraceSpan_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_RunTraceSpan_endedAt(ctx, field)
			case "childrenSpans":
				return ec.fieldContext_RunTraceSpan_childrenSpans(ctx, field)
			case "stepOp":
				return ec.fieldContext_RunTraceSpan_stepOp(ctx, field)
			case "stepID":
				return ec.fieldContext_RunTraceSpan_stepID(ctx, field)
			case "stepInfo":
				return ec.fieldContext_RunTraceSpan_stepInfo(ctx, field)
			case "isRoot":
				return ec.fieldContext_RunTraceSpan_isRoot(ctx, field)
			case "parentSpanID":
				return ec.fieldContext_RunTraceSpan_parentSpanID(ctx, field)
			case "parentSpan":
				return ec.fieldContext_RunTraceSpan_parentSpan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunTraceSpan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpanOutput_input(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpanOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpanOutput_input(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Input, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOBytes2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpanOutput_input(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpanOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpanOutput_data(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpanOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpanOutput_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOBytes2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpanOutput_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpanOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceSpanOutput_error(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceSpanOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceSpanOutput_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.StepError)
	fc.Result = res
	return ec.marshalOStepError2githubcominngestinngestpkgcoreapigraphmodelsStepError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceSpanOutput_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceSpanOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_StepError_message(ctx, field)
			case "name":
				return ec.fieldContext_StepError_name(ctx, field)
			case "stack":
				return ec.fieldContext_StepError_stack(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StepError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceTrigger_eventName(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceTrigger_eventName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceTrigger_eventName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceTrigger_IDs(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceTrigger_IDs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ulid.ULID)
	fc.Result = res
	return ec.marshalNULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceTrigger_IDs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceTrigger_payloads(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceTrigger_payloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Payloads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNBytes2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceTrigger_payloads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceTrigger_timestamp(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceTrigger_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceTrigger_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceTrigger_isBatch(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceTrigger_isBatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsBatch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceTrigger_isBatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceTrigger_batchID(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceTrigger_batchID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ulid.ULID)
	fc.Result = res
	return ec.marshalOULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceTrigger_batchID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunTraceTrigger_cron(ctx context.Context, field graphql.CollectedField, obj *models.RunTraceTrigger) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunTraceTrigger_cron(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cron, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunTraceTrigger_cron(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunTraceTrigger",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunsV2Connection_edges(ctx context.Context, field graphql.CollectedField, obj *models.RunsV2Connection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunsV2Connection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.FunctionRunV2Edge)
	fc.Result = res
	return ec.marshalNFunctionRunV2Edge2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunV2Edge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunsV2Connection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunsV2Connection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_FunctionRunV2Edge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_FunctionRunV2Edge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionRunV2Edge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunsV2Connection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.RunsV2Connection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunsV2Connection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcominngestinngestpkgcoreapigraphmodelsPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunsV2Connection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunsV2Connection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunsV2Connection_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.RunsV2Connection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunsV2Connection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RunsV2Connection().TotalCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunsV2Connection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunsV2Connection",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepStepInfo_sleepUntil(ctx context.Context, field graphql.CollectedField, obj *models.SleepStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepStepInfo_sleepUntil(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SleepUntil, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepStepInfo_sleepUntil(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepError_message(ctx context.Context, field graphql.CollectedField, obj *models.StepError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepError_name(ctx context.Context, field graphql.CollectedField, obj *models.StepError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepError_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepError_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepError_stack(ctx context.Context, field graphql.CollectedField, obj *models.StepError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepError_stack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepError_stack(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEvent_workspace(ctx context.Context, field graphql.CollectedField, obj *models.StepEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEvent_workspace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workspace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Workspace)
	fc.Result = res
	return ec.marshalOWorkspace2githubcominngestinngestpkgcoreapigraphmodelsWorkspace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEvent_workspace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workspace_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workspace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEvent_functionRun(ctx context.Context, field graphql.CollectedField, obj *models.StepEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEvent_functionRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionRun, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.FunctionRun)
	fc.Result = res
	return ec.marshalOFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEvent_functionRun(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FunctionRun_id(ctx, field)
			case "functionID":
				return ec.fieldContext_FunctionRun_functionID(ctx, field)
			case "function":
				return ec.fieldContext_FunctionRun_function(ctx, field)
			case "workspace":
				return ec.fieldContext_FunctionRun_workspace(ctx, field)
			case "event":
				return ec.fieldContext_FunctionRun_event(ctx, field)
			case "events":
				return ec.fieldContext_FunctionRun_events(ctx, field)
			case "batchID":
				return ec.fieldContext_FunctionRun_batchID(ctx, field)
			case "batchCreatedAt":
				return ec.fieldContext_FunctionRun_batchCreatedAt(ctx, field)
			case "status":
				return ec.fieldContext_FunctionRun_status(ctx, field)
			case "waitingFor":
				return ec.fieldContext_FunctionRun_waitingFor(ctx, field)
			case "pendingSteps":
				return ec.fieldContext_FunctionRun_pendingSteps(ctx, field)
			case "startedAt":
				return ec.fieldContext_FunctionRun_startedAt(ctx, field)
			case "finishedAt":
				return ec.fieldContext_FunctionRun_finishedAt(ctx, field)
			case "output":
				return ec.fieldContext_FunctionRun_output(ctx, field)
			case "history":
				return ec.fieldContext_FunctionRun_history(ctx, field)
			case "historyItemOutput":
				return ec.fieldContext_FunctionRun_historyItemOutput(ctx, field)
			case "eventID":
				return ec.fieldContext_FunctionRun_eventID(ctx, field)
			case "cron":
				return ec.fieldContext_FunctionRun_cron(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionRun", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEvent_stepID(ctx context.Context, field graphql.CollectedField, obj *models.StepEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEvent_stepID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEvent_stepID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEvent_name(ctx context.Context, field graphql.CollectedField, obj *models.StepEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEvent_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEvent_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEvent_type(ctx context.Context, field graphql.CollectedField, obj *models.StepEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEvent_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.StepEventType)
	fc.Result = res
	return ec.marshalOStepEventType2githubcominngestinngestpkgcoreapigraphmodelsStepEventType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEvent_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StepEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEvent_output(ctx context.Context, field graphql.CollectedField, obj *models.StepEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEvent_output(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEvent_output(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEvent_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.StepEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEvent_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEvent_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEvent_waitingFor(ctx context.Context, field graphql.CollectedField, obj *models.StepEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEvent_waitingFor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WaitingFor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.StepEventWait)
	fc.Result = res
	return ec.marshalOStepEventWait2githubcominngestinngestpkgcoreapigraphmodelsStepEventWait(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEvent_waitingFor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "eventName":
				return ec.fieldContext_StepEventWait_eventName(ctx, field)
			case "expression":
				return ec.fieldContext_StepEventWait_expression(ctx, field)
			case "expiryTime":
				return ec.fieldContext_StepEventWait_expiryTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StepEventWait", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEventWait_eventName(ctx context.Context, field graphql.CollectedField, obj *models.StepEventWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEventWait_eventName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEventWait_eventName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEventWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEventWait_expression(ctx context.Context, field graphql.CollectedField, obj *models.StepEventWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEventWait_expression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEventWait_expression(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEventWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepEventWait_expiryTime(ctx context.Context, field graphql.CollectedField, obj *models.StepEventWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepEventWait_expiryTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiryTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepEventWait_expiryTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepEventWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StreamItem_id(ctx context.Context, field graphql.CollectedField, obj *models.StreamItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StreamItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StreamItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StreamItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StreamItem_trigger(ctx context.Context, field graphql.CollectedField, obj *models.StreamItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StreamItem_trigger(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Trigger, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StreamItem_trigger(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StreamItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StreamItem_type(ctx context.Context, field graphql.CollectedField, obj *models.StreamItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StreamItem_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.StreamType)
	fc.Result = res
	return ec.marshalNStreamType2githubcominngestinngestpkgcoreapigraphmodelsStreamType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StreamItem_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StreamItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StreamType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StreamItem_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.StreamItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StreamItem_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StreamItem_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StreamItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StreamItem_runs(ctx context.Context, field graphql.CollectedField, obj *models.StreamItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StreamItem_runs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.FunctionRun)
	fc.Result = res
	return ec.marshalOFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StreamItem_runs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StreamItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FunctionRun_id(ctx, field)
			case "functionID":
				return ec.fieldContext_FunctionRun_functionID(ctx, field)
			case "function":
				return ec.fieldContext_FunctionRun_function(ctx, field)
			case "workspace":
				return ec.fieldContext_FunctionRun_workspace(ctx, field)
			case "event":
				return ec.fieldContext_FunctionRun_event(ctx, field)
			case "events":
				return ec.fieldContext_FunctionRun_events(ctx, field)
			case "batchID":
				return ec.fieldContext_FunctionRun_batchID(ctx, field)
			case "batchCreatedAt":
				return ec.fieldContext_FunctionRun_batchCreatedAt(ctx, field)
			case "status":
				return ec.fieldContext_FunctionRun_status(ctx, field)
			case "waitingFor":
				return ec.fieldContext_FunctionRun_waitingFor(ctx, field)
			case "pendingSteps":
				return ec.fieldContext_FunctionRun_pendingSteps(ctx, field)
			case "startedAt":
				return ec.fieldContext_FunctionRun_startedAt(ctx, field)
			case "finishedAt":
				return ec.fieldContext_FunctionRun_finishedAt(ctx, field)
			case "output":
				return ec.fieldContext_FunctionRun_output(ctx, field)
			case "history":
				return ec.fieldContext_FunctionRun_history(ctx, field)
			case "historyItemOutput":
				return ec.fieldContext_FunctionRun_historyItemOutput(ctx, field)
			case "eventID":
				return ec.fieldContext_FunctionRun_eventID(ctx, field)
			case "cron":
				return ec.fieldContext_FunctionRun_cron(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionRun", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StreamItem_inBatch(ctx context.Context, field graphql.CollectedField, obj *models.StreamItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StreamItem_inBatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StreamItem().InBatch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StreamItem_inBatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StreamItem",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitForEventStepInfo_eventName(ctx context.Context, field graphql.CollectedField, obj *models.WaitForEventStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitForEventStepInfo_eventName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitForEventStepInfo_eventName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitForEventStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitForEventStepInfo_expression(ctx context.Context, field graphql.CollectedField, obj *models.WaitForEventStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitForEventStepInfo_expression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitForEventStepInfo_expression(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitForEventStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitForEventStepInfo_timeout(ctx context.Context, field graphql.CollectedField, obj *models.WaitForEventStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitForEventStepInfo_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitForEventStepInfo_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitForEventStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitForEventStepInfo_foundEventID(ctx context.Context, field graphql.CollectedField, obj *models.WaitForEventStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitForEventStepInfo_foundEventID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FoundEventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ulid.ULID)
	fc.Result = res
	return ec.marshalOULID2githubcomoklogulidv2ULID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitForEventStepInfo_foundEventID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitForEventStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ULID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaitForEventStepInfo_timedOut(ctx context.Context, field graphql.CollectedField, obj *models.WaitForEventStepInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaitForEventStepInfo_timedOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimedOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaitForEventStepInfo_timedOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaitForEventStepInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workspace_id(ctx context.Context, field graphql.CollectedField, obj *models.Workspace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Workspace_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Workspace_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workspace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputActionVersionQuery(ctx context.Context, obj interface{}) (models.ActionVersionQuery, error) {
	var it models.ActionVersionQuery
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dsn", "versionMajor", "versionMinor"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dsn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dsn"))
			it.Dsn, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "versionMajor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionMajor"))
			it.VersionMajor, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "versionMinor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionMinor"))
			it.VersionMinor, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateAppInput(ctx context.Context, obj interface{}) (models.CreateAppInput, error) {
	var it models.CreateAppInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			it.URL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventQuery(ctx context.Context, obj interface{}) (models.EventQuery, error) {
	var it models.EventQuery
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["workspaceId"]; !present {
		asMap["workspaceId"] = "local"
	}

	fieldsInOrder := [...]string{"workspaceId", "eventId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "workspaceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workspaceId"))
			it.WorkspaceID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventId"))
			it.EventID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventsQuery(ctx context.Context, obj interface{}) (models.EventsQuery, error) {
	var it models.EventsQuery
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["workspaceId"]; !present {
		asMap["workspaceId"] = "local"
	}

	fieldsInOrder := [...]string{"workspaceId", "lastEventId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "workspaceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workspaceId"))
			it.WorkspaceID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastEventId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastEventId"))
			it.LastEventID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFunctionRunQuery(ctx context.Context, obj interface{}) (models.FunctionRunQuery, error) {
	var it models.FunctionRunQuery
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["workspaceId"]; !present {
		asMap["workspaceId"] = "local"
	}

	fieldsInOrder := [...]string{"workspaceId", "functionRunId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "workspaceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workspaceId"))
			it.WorkspaceID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "functionRunId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("functionRunId"))
			it.FunctionRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFunctionRunsQuery(ctx context.Context, obj interface{}) (models.FunctionRunsQuery, error) {
	var it models.FunctionRunsQuery
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["workspaceId"]; !present {
		asMap["workspaceId"] = "local"
	}

	fieldsInOrder := [...]string{"workspaceId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "workspaceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workspaceId"))
			it.WorkspaceID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRerunFromStepInput(ctx context.Context, obj interface{}) (models.RerunFromStepInput, error) {
	var it models.RerunFromStepInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"stepID", "input"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "stepID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepID"))
			it.StepID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "input":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
			it.Input, err = ec.unmarshalOBytes2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRunsFilterV2(ctx context.Context, obj interface{}) (models.RunsFilterV2, error) {
	var it models.RunsFilterV2
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["timeField"]; !present {
		asMap["timeField"] = "QUEUED_AT"
	}

	fieldsInOrder := [...]string{"from", "until", "timeField", "status", "functionIDs", "appIDs", "query"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "from":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			it.From, err = ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "until":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("until"))
			it.Until, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timeField":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeField"))
			it.TimeField, err = ec.unmarshalORunsV2OrderByField2githubcominngestinngestpkgcoreapigraphmodelsRunsV2OrderByField(ctx, v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			it.Status, err = ec.unmarshalOFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "functionIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("functionIDs"))
			it.FunctionIDs, err = ec.unmarshalOUUID2githubcomgoogleuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "appIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appIDs"))
			it.AppIDs, err = ec.unmarshalOUUID2githubcomgoogleuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "query":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			it.Query, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRunsV2OrderBy(ctx context.Context, obj interface{}) (models.RunsV2OrderBy, error) {
	var it models.RunsV2OrderBy
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNRunsV2OrderByField2githubcominngestinngestpkgcoreapigraphmodelsRunsV2OrderByField(ctx, v)
			if err != nil {
				return it, err
			}
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNRunsOrderByDirection2githubcominngestinngestpkgcoreapigraphmodelsRunsOrderByDirection(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStreamQuery(ctx context.Context, obj interface{}) (models.StreamQuery, error) {
	var it models.StreamQuery
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 20
	}

	fieldsInOrder := [...]string{"after", "before", "limit", "includeInternalEvents"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "includeInternalEvents":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeInternalEvents"))
			it.IncludeInternalEvents, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAppInput(ctx context.Context, obj interface{}) (models.UpdateAppInput, error) {
	var it models.UpdateAppInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			it.URL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _FunctionRunEvent(ctx context.Context, sel ast.SelectionSet, obj models.FunctionRunEvent) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case models.FunctionEvent:
		return ec._FunctionEvent(ctx, sel, &obj)
	case *models.FunctionEvent:
		if obj == nil {
			return graphql.Null
		}
		return ec._FunctionEvent(ctx, sel, obj)
	case models.StepEvent:
		return ec._StepEvent(ctx, sel, &obj)
	case *models.StepEvent:
		if obj == nil {
			return graphql.Null
		}
		return ec._StepEvent(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _StepInfo(ctx context.Context, sel ast.SelectionSet, obj models.StepInfo) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case models.InvokeStepInfo:
		return ec._InvokeStepInfo(ctx, sel, &obj)
	case *models.InvokeStepInfo:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvokeStepInfo(ctx, sel, obj)
	case models.SleepStepInfo:
		return ec._SleepStepInfo(ctx, sel, &obj)
	case *models.SleepStepInfo:
		if obj == nil {
			return graphql.Null
		}
		return ec._SleepStepInfo(ctx, sel, obj)
	case models.WaitForEventStepInfo:
		return ec._WaitForEventStepInfo(ctx, sel, &obj)
	case *models.WaitForEventStepInfo:
		if obj == nil {
			return graphql.Null
		}
		return ec._WaitForEventStepInfo(ctx, sel, obj)
	case models.RunStepInfo:
		return ec._RunStepInfo(ctx, sel, &obj)
	case *models.RunStepInfo:
		if obj == nil {
			return graphql.Null
		}
		return ec._RunStepInfo(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var appImplementors = []string{"App"}

func (ec *executionContext) _App(ctx context.Context, sel ast.SelectionSet, obj *cqrs.App) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, appImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("App")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._App_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "externalID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._App_externalID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._App_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sdkLanguage":

			out.Values[i] = ec._App_sdkLanguage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sdkVersion":

			out.Values[i] = ec._App_sdkVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "framework":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._App_framework(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "url":

			out.Values[i] = ec._App_url(ctx, field, obj)

		case "checksum":

			out.Values[i] = ec._App_checksum(ctx, field, obj)

		case "error":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._App_error(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "functions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._App_functions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "connected":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._App_connected(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "functionCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._App_functionCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "autodiscovered":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._App_autodiscovered(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var eventImplementors = []string{"Event"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *models.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":

			out.Values[i] = ec._Event_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "externalID":

			out.Values[i] = ec._Event_externalID(ctx, field, obj)

		case "workspace":

			out.Values[i] = ec._Event_workspace(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Event_name(ctx, field, obj)

		case "createdAt":

			out.Values[i] = ec._Event_createdAt(ctx, field, obj)

		case "payload":

			out.Values[i] = ec._Event_payload(ctx, field, obj)

		case "schema":

			out.Values[i] = ec._Event_schema(ctx, field, obj)

		case "status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_status(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "pendingRuns":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_pendingRuns(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "totalRuns":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_totalRuns(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "raw":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_raw(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "functionRuns":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_functionRuns(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var functionImplementors = []string{"Function"}

func (ec *executionContext) _Function(ctx context.Context, sel ast.SelectionSet, obj *models.Function) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, functionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Function")
		case "id":

			out.Values[i] = ec._Function_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Function_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "slug":

			out.Values[i] = ec._Function_slug(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "config":

			out.Values[i] = ec._Function_config(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "concurrency":

			out.Values[i] = ec._Function_concurrency(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "triggers":

			out.Values[i] = ec._Function_triggers(ctx, field, obj)

		case "url":

			out.Values[i] = ec._Function_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "appID":

			out.Values[i] = ec._Function_appID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "app":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Function_app(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var functionEventImplementors = []string{"FunctionEvent", "FunctionRunEvent"}

func (ec *executionContext) _FunctionEvent(ctx context.Context, sel ast.SelectionSet, obj *models.FunctionEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, functionEventImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionEvent")
		case "workspace":

			out.Values[i] = ec._FunctionEvent_workspace(ctx, field, obj)

		case "functionRun":

			out.Values[i] = ec._FunctionEvent_functionRun(ctx, field, obj)

		case "type":

			out.Values[i] = ec._FunctionEvent_type(ctx, field, obj)

		case "output":

			out.Values[i] = ec._FunctionEvent_output(ctx, field, obj)

		case "createdAt":

			out.Values[i] = ec._FunctionEvent_createdAt(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var functionRunImplementors = []string{"FunctionRun"}

func (ec *executionContext) _FunctionRun(ctx context.Context, sel ast.SelectionSet, obj *models.FunctionRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, functionRunImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionRun")
		case "id":

			out.Values[i] = ec._FunctionRun_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "functionID":

			out.Values[i] = ec._FunctionRun_functionID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "function":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRun_function(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "workspace":

			out.Values[i] = ec._FunctionRun_workspace(ctx, field, obj)

		case "event":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRun_event(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "events":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRun_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "batchID":

			out.Values[i] = ec._FunctionRun_batchID(ctx, field, obj)

		case "batchCreatedAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRun_batchCreatedAt(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "status":

			out.Values[i] = ec._FunctionRun_status(ctx, field, obj)

		case "waitingFor":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRun_waitingFor(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "pendingSteps":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRun_pendingSteps(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "startedAt":

			out.Values[i] = ec._FunctionRun_startedAt(ctx, field, obj)

		case "finishedAt":

			out.Values[i] = ec._FunctionRun_finishedAt(ctx, field, obj)

		case "output":

			out.Values[i] = ec._FunctionRun_output(ctx, field, obj)

		case "history":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRun_history(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "historyItemOutput":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRun_historyItemOutput(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "eventID":

			out.Values[i] = ec._FunctionRun_eventID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cron":

			out.Values[i] = ec._FunctionRun_cron(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var functionRunV2Implementors = []string{"FunctionRunV2"}

func (ec *executionContext) _FunctionRunV2(ctx context.Context, sel ast.SelectionSet, obj *models.FunctionRunV2) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, functionRunV2Implementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionRunV2")
		case "id":

			out.Values[i] = ec._FunctionRunV2_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "appID":

			out.Values[i] = ec._FunctionRunV2_appID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "app":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRunV2_app(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "functionID":

			out.Values[i] = ec._FunctionRunV2_functionID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "function":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRunV2_function(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "traceID":

			out.Values[i] = ec._FunctionRunV2_traceID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "queuedAt":

			out.Values[i] = ec._FunctionRunV2_queuedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "startedAt":

			out.Values[i] = ec._FunctionRunV2_startedAt(ctx, field, obj)

		case "endedAt":

			out.Values[i] = ec._FunctionRunV2_endedAt(ctx, field, obj)

		case "status":

			out.Values[i] = ec._FunctionRunV2_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sourceID":

			out.Values[i] = ec._FunctionRunV2_sourceID(ctx, field, obj)

		case "triggerIDs":

			out.Values[i] = ec._FunctionRunV2_triggerIDs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "eventName":

			out.Values[i] = ec._FunctionRunV2_eventName(ctx, field, obj)

		case "isBatch":

			out.Values[i] = ec._FunctionRunV2_isBatch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "batchCreatedAt":

			out.Values[i] = ec._FunctionRunV2_batchCreatedAt(ctx, field, obj)

		case "cronSchedule":

			out.Values[i] = ec._FunctionRunV2_cronSchedule(ctx, field, obj)

		case "output":

			out.Values[i] = ec._FunctionRunV2_output(ctx, field, obj)

		case "trace":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FunctionRunV2_trace(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var functionRunV2EdgeImplementors = []string{"FunctionRunV2Edge"}

func (ec *executionContext) _FunctionRunV2Edge(ctx context.Context, sel ast.SelectionSet, obj *models.FunctionRunV2Edge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, functionRunV2EdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionRunV2Edge")
		case "node":

			out.Values[i] = ec._FunctionRunV2Edge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cursor":

			out.Values[i] = ec._FunctionRunV2Edge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var functionTriggerImplementors = []string{"FunctionTrigger"}

func (ec *executionContext) _FunctionTrigger(ctx context.Context, sel ast.SelectionSet, obj *models.FunctionTrigger) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, functionTriggerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionTrigger")
		case "type":

			out.Values[i] = ec._FunctionTrigger_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._FunctionTrigger_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var functionVersionImplementors = []string{"FunctionVersion"}

func (ec *executionContext) _FunctionVersion(ctx context.Context, sel ast.SelectionSet, obj *function.FunctionVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, functionVersionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionVersion")
		case "functionId":

			out.Values[i] = ec._FunctionVersion_functionId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._FunctionVersion_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "config":

			out.Values[i] = ec._FunctionVersion_config(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "validFrom":

			out.Values[i] = ec._FunctionVersion_validFrom(ctx, field, obj)

		case "validTo":

			out.Values[i] = ec._FunctionVersion_validTo(ctx, field, obj)

		case "createdAt":

			out.Values[i] = ec._FunctionVersion_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":

			out.Values[i] = ec._FunctionVersion_updatedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var invokeStepInfoImplementors = []string{"InvokeStepInfo", "StepInfo"}

func (ec *executionContext) _InvokeStepInfo(ctx context.Context, sel ast.SelectionSet, obj *models.InvokeStepInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invokeStepInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvokeStepInfo")
		case "triggeringEventID":

			out.Values[i] = ec._InvokeStepInfo_triggeringEventID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "functionID":

			out.Values[i] = ec._InvokeStepInfo_functionID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timeout":

			out.Values[i] = ec._InvokeStepInfo_timeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "returnEventID":

			out.Values[i] = ec._InvokeStepInfo_returnEventID(ctx, field, obj)

		case "runID":

			out.Values[i] = ec._InvokeStepInfo_runID(ctx, field, obj)

		case "timedOut":

			out.Values[i] = ec._InvokeStepInfo_timedOut(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createApp":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createApp(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateApp":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateApp(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteApp":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteApp(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteAppByName":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteAppByName(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "invokeFunction":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_invokeFunction(ctx, field)
			})

		case "cancelRun":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelRun(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rerun":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rerun(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *models.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "apps":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_apps(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "stream":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_stream(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "event":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_event(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "events":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_events(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "functions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_functions(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "functionRun":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_functionRun(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "runs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_runs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "run":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_run(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "runTraceSpanOutputByID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_runTraceSpanOutputByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "runTrigger":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_runTrigger(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runHistoryCancelImplementors = []string{"RunHistoryCancel"}

func (ec *executionContext) _RunHistoryCancel(ctx context.Context, sel ast.SelectionSet, obj *history_reader.RunHistoryCancel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runHistoryCancelImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunHistoryCancel")
		case "eventID":

			out.Values[i] = ec._RunHistoryCancel_eventID(ctx, field, obj)

		case "expression":

			out.Values[i] = ec._RunHistoryCancel_expression(ctx, field, obj)

		case "userID":

			out.Values[i] = ec._RunHistoryCancel_userID(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runHistoryInvokeFunctionImplementors = []string{"RunHistoryInvokeFunction"}

func (ec *executionContext) _RunHistoryInvokeFunction(ctx context.Context, sel ast.SelectionSet, obj *history_reader.RunHistoryInvokeFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runHistoryInvokeFunctionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunHistoryInvokeFunction")
		case "eventID":

			out.Values[i] = ec._RunHistoryInvokeFunction_eventID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "functionID":

			out.Values[i] = ec._RunHistoryInvokeFunction_functionID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "correlationID":

			out.Values[i] = ec._RunHistoryInvokeFunction_correlationID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timeout":

			out.Values[i] = ec._RunHistoryInvokeFunction_timeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runHistoryInvokeFunctionResultImplementors = []string{"RunHistoryInvokeFunctionResult"}

func (ec *executionContext) _RunHistoryInvokeFunctionResult(ctx context.Context, sel ast.SelectionSet, obj *history_reader.RunHistoryInvokeFunctionResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runHistoryInvokeFunctionResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunHistoryInvokeFunctionResult")
		case "eventID":

			out.Values[i] = ec._RunHistoryInvokeFunctionResult_eventID(ctx, field, obj)

		case "timeout":

			out.Values[i] = ec._RunHistoryInvokeFunctionResult_timeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "runID":

			out.Values[i] = ec._RunHistoryInvokeFunctionResult_runID(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runHistoryItemImplementors = []string{"RunHistoryItem"}

func (ec *executionContext) _RunHistoryItem(ctx context.Context, sel ast.SelectionSet, obj *history_reader.RunHistory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runHistoryItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunHistoryItem")
		case "attempt":

			out.Values[i] = ec._RunHistoryItem_attempt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cancel":

			out.Values[i] = ec._RunHistoryItem_cancel(ctx, field, obj)

		case "createdAt":

			out.Values[i] = ec._RunHistoryItem_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "functionVersion":

			out.Values[i] = ec._RunHistoryItem_functionVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "groupID":

			out.Values[i] = ec._RunHistoryItem_groupID(ctx, field, obj)

		case "id":

			out.Values[i] = ec._RunHistoryItem_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "result":

			out.Values[i] = ec._RunHistoryItem_result(ctx, field, obj)

		case "sleep":

			out.Values[i] = ec._RunHistoryItem_sleep(ctx, field, obj)

		case "stepName":

			out.Values[i] = ec._RunHistoryItem_stepName(ctx, field, obj)

		case "stepType":

			out.Values[i] = ec._RunHistoryItem_stepType(ctx, field, obj)

		case "type":

			out.Values[i] = ec._RunHistoryItem_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":

			out.Values[i] = ec._RunHistoryItem_url(ctx, field, obj)

		case "waitForEvent":

			out.Values[i] = ec._RunHistoryItem_waitForEvent(ctx, field, obj)

		case "waitResult":

			out.Values[i] = ec._RunHistoryItem_waitResult(ctx, field, obj)

		case "invokeFunction":

			out.Values[i] = ec._RunHistoryItem_invokeFunction(ctx, field, obj)

		case "invokeFunctionResult":

			out.Values[i] = ec._RunHistoryItem_invokeFunctionResult(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runHistoryResultImplementors = []string{"RunHistoryResult"}

func (ec *executionContext) _RunHistoryResult(ctx context.Context, sel ast.SelectionSet, obj *history_reader.RunHistoryResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runHistoryResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunHistoryResult")
		case "durationMS":

			out.Values[i] = ec._RunHistoryResult_durationMS(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errorCode":

			out.Values[i] = ec._RunHistoryResult_errorCode(ctx, field, obj)

		case "framework":

			out.Values[i] = ec._RunHistoryResult_framework(ctx, field, obj)

		case "platform":

			out.Values[i] = ec._RunHistoryResult_platform(ctx, field, obj)

		case "sdkLanguage":

			out.Values[i] = ec._RunHistoryResult_sdkLanguage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sdkVersion":

			out.Values[i] = ec._RunHistoryResult_sdkVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sizeBytes":

			out.Values[i] = ec._RunHistoryResult_sizeBytes(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runHistorySleepImplementors = []string{"RunHistorySleep"}

func (ec *executionContext) _RunHistorySleep(ctx context.Context, sel ast.SelectionSet, obj *history_reader.RunHistorySleep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runHistorySleepImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunHistorySleep")
		case "until":

			out.Values[i] = ec._RunHistorySleep_until(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runHistoryWaitForEventImplementors = []string{"RunHistoryWaitForEvent"}

func (ec *executionContext) _RunHistoryWaitForEvent(ctx context.Context, sel ast.SelectionSet, obj *history_reader.RunHistoryWaitForEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runHistoryWaitForEventImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunHistoryWaitForEvent")
		case "eventName":

			out.Values[i] = ec._RunHistoryWaitForEvent_eventName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "expression":

			out.Values[i] = ec._RunHistoryWaitForEvent_expression(ctx, field, obj)

		case "timeout":

			out.Values[i] = ec._RunHistoryWaitForEvent_timeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runHistoryWaitResultImplementors = []string{"RunHistoryWaitResult"}

func (ec *executionContext) _RunHistoryWaitResult(ctx context.Context, sel ast.SelectionSet, obj *history_reader.RunHistoryWaitResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runHistoryWaitResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunHistoryWaitResult")
		case "eventID":

			out.Values[i] = ec._RunHistoryWaitResult_eventID(ctx, field, obj)

		case "timeout":

			out.Values[i] = ec._RunHistoryWaitResult_timeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runStepInfoImplementors = []string{"RunStepInfo", "StepInfo"}

func (ec *executionContext) _RunStepInfo(ctx context.Context, sel ast.SelectionSet, obj *models.RunStepInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runStepInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunStepInfo")
		case "type":

			out.Values[i] = ec._RunStepInfo_type(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runTraceSpanImplementors = []string{"RunTraceSpan"}

func (ec *executionContext) _RunTraceSpan(ctx context.Context, sel ast.SelectionSet, obj *models.RunTraceSpan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runTraceSpanImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunTraceSpan")
		case "appID":

			out.Values[i] = ec._RunTraceSpan_appID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "functionID":

			out.Values[i] = ec._RunTraceSpan_functionID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "runID":

			out.Values[i] = ec._RunTraceSpan_runID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "run":

			out.Values[i] = ec._RunTraceSpan_run(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spanID":

			out.Values[i] = ec._RunTraceSpan_spanID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "traceID":

			out.Values[i] = ec._RunTraceSpan_traceID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._RunTraceSpan_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "status":

			out.Values[i] = ec._RunTraceSpan_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "attempts":

			out.Values[i] = ec._RunTraceSpan_attempts(ctx, field, obj)

		case "duration":

			out.Values[i] = ec._RunTraceSpan_duration(ctx, field, obj)

		case "outputID":

			out.Values[i] = ec._RunTraceSpan_outputID(ctx, field, obj)

		case "queuedAt":

			out.Values[i] = ec._RunTraceSpan_queuedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startedAt":

			out.Values[i] = ec._RunTraceSpan_startedAt(ctx, field, obj)

		case "endedAt":

			out.Values[i] = ec._RunTraceSpan_endedAt(ctx, field, obj)

		case "childrenSpans":

			out.Values[i] = ec._RunTraceSpan_childrenSpans(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "stepOp":

			out.Values[i] = ec._RunTraceSpan_stepOp(ctx, field, obj)

		case "stepID":

			out.Values[i] = ec._RunTraceSpan_stepID(ctx, field, obj)

		case "stepInfo":

			out.Values[i] = ec._RunTraceSpan_stepInfo(ctx, field, obj)

		case "isRoot":

			out.Values[i] = ec._RunTraceSpan_isRoot(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "parentSpanID":

			out.Values[i] = ec._RunTraceSpan_parentSpanID(ctx, field, obj)

		case "parentSpan":

			out.Values[i] = ec._RunTraceSpan_parentSpan(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runTraceSpanOutputImplementors = []string{"RunTraceSpanOutput"}

func (ec *executionContext) _RunTraceSpanOutput(ctx context.Context, sel ast.SelectionSet, obj *models.RunTraceSpanOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runTraceSpanOutputImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunTraceSpanOutput")
		case "input":

			out.Values[i] = ec._RunTraceSpanOutput_input(ctx, field, obj)

		case "data":

			out.Values[i] = ec._RunTraceSpanOutput_data(ctx, field, obj)

		case "error":

			out.Values[i] = ec._RunTraceSpanOutput_error(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runTraceTriggerImplementors = []string{"RunTraceTrigger"}

func (ec *executionContext) _RunTraceTrigger(ctx context.Context, sel ast.SelectionSet, obj *models.RunTraceTrigger) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runTraceTriggerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunTraceTrigger")
		case "eventName":

			out.Values[i] = ec._RunTraceTrigger_eventName(ctx, field, obj)

		case "IDs":

			out.Values[i] = ec._RunTraceTrigger_IDs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "payloads":

			out.Values[i] = ec._RunTraceTrigger_payloads(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timestamp":

			out.Values[i] = ec._RunTraceTrigger_timestamp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isBatch":

			out.Values[i] = ec._RunTraceTrigger_isBatch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "batchID":

			out.Values[i] = ec._RunTraceTrigger_batchID(ctx, field, obj)

		case "cron":

			out.Values[i] = ec._RunTraceTrigger_cron(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var runsV2ConnectionImplementors = []string{"RunsV2Connection"}

func (ec *executionContext) _RunsV2Connection(ctx context.Context, sel ast.SelectionSet, obj *models.RunsV2Connection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runsV2ConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunsV2Connection")
		case "edges":

			out.Values[i] = ec._RunsV2Connection_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "pageInfo":

			out.Values[i] = ec._RunsV2Connection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "totalCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RunsV2Connection_totalCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sleepStepInfoImplementors = []string{"SleepStepInfo", "StepInfo"}

func (ec *executionContext) _SleepStepInfo(ctx context.Context, sel ast.SelectionSet, obj *models.SleepStepInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sleepStepInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SleepStepInfo")
		case "sleepUntil":

			out.Values[i] = ec._SleepStepInfo_sleepUntil(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stepErrorImplementors = []string{"StepError"}

func (ec *executionContext) _StepError(ctx context.Context, sel ast.SelectionSet, obj *models.StepError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stepErrorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StepError")
		case "message":

			out.Values[i] = ec._StepError_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._StepError_name(ctx, field, obj)

		case "stack":

			out.Values[i] = ec._StepError_stack(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stepEventImplementors = []string{"StepEvent", "FunctionRunEvent"}

func (ec *executionContext) _StepEvent(ctx context.Context, sel ast.SelectionSet, obj *models.StepEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stepEventImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StepEvent")
		case "workspace":

			out.Values[i] = ec._StepEvent_workspace(ctx, field, obj)

		case "functionRun":

			out.Values[i] = ec._StepEvent_functionRun(ctx, field, obj)

		case "stepID":

			out.Values[i] = ec._StepEvent_stepID(ctx, field, obj)

		case "name":

			out.Values[i] = ec._StepEvent_name(ctx, field, obj)

		case "type":

			out.Values[i] = ec._StepEvent_type(ctx, field, obj)

		case "output":

			out.Values[i] = ec._StepEvent_output(ctx, field, obj)

		case "createdAt":

			out.Values[i] = ec._StepEvent_createdAt(ctx, field, obj)

		case "waitingFor":

			out.Values[i] = ec._StepEvent_waitingFor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stepEventWaitImplementors = []string{"StepEventWait"}

func (ec *executionContext) _StepEventWait(ctx context.Context, sel ast.SelectionSet, obj *models.StepEventWait) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stepEventWaitImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StepEventWait")
		case "eventName":

			out.Values[i] = ec._StepEventWait_eventName(ctx, field, obj)

		case "expression":

			out.Values[i] = ec._StepEventWait_expression(ctx, field, obj)

		case "expiryTime":

			out.Values[i] = ec._StepEventWait_expiryTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var streamItemImplementors = []string{"StreamItem"}

func (ec *executionContext) _StreamItem(ctx context.Context, sel ast.SelectionSet, obj *models.StreamItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, streamItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StreamItem")
		case "id":

			out.Values[i] = ec._StreamItem_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "trigger":

			out.Values[i] = ec._StreamItem_trigger(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._StreamItem_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._StreamItem_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "runs":

			out.Values[i] = ec._StreamItem_runs(ctx, field, obj)

		case "inBatch":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StreamItem_inBatch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var waitForEventStepInfoImplementors = []string{"WaitForEventStepInfo", "StepInfo"}

func (ec *executionContext) _WaitForEventStepInfo(ctx context.Context, sel ast.SelectionSet, obj *models.WaitForEventStepInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waitForEventStepInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaitForEventStepInfo")
		case "eventName":

			out.Values[i] = ec._WaitForEventStepInfo_eventName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "expression":

			out.Values[i] = ec._WaitForEventStepInfo_expression(ctx, field, obj)

		case "timeout":

			out.Values[i] = ec._WaitForEventStepInfo_timeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "foundEventID":

			out.Values[i] = ec._WaitForEventStepInfo_foundEventID(ctx, field, obj)

		case "timedOut":

			out.Values[i] = ec._WaitForEventStepInfo_timedOut(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workspaceImplementors = []string{"Workspace"}

func (ec *executionContext) _Workspace(ctx context.Context, sel ast.SelectionSet, obj *models.Workspace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workspaceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Workspace")
		case "id":

			out.Values[i] = ec._Workspace_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNApp2githubcominngestinngestpkgcqrsApp(ctx context.Context, sel ast.SelectionSet, v cqrs.App) graphql.Marshaler {
	return ec._App(ctx, sel, &v)
}

func (ec *executionContext) marshalNApp2githubcominngestinngestpkgcqrsApp(ctx context.Context, sel ast.SelectionSet, v []*cqrs.App) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApp2githubcominngestinngestpkgcqrsApp(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNApp2githubcominngestinngestpkgcqrsApp(ctx context.Context, sel ast.SelectionSet, v *cqrs.App) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._App(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBytes2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBytes2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBytes2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBytes2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNBytes2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNBytes2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNCreateAppInput2githubcominngestinngestpkgcoreapigraphmodelsCreateAppInput(ctx context.Context, v interface{}) (models.CreateAppInput, error) {
	res, err := ec.unmarshalInputCreateAppInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEvent2githubcominngestinngestpkgcoreapigraphmodelsEvent(ctx context.Context, sel ast.SelectionSet, v []*models.Event) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2githubcominngestinngestpkgcoreapigraphmodelsEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEvent2githubcominngestinngestpkgcoreapigraphmodelsEvent(ctx context.Context, sel ast.SelectionSet, v *models.Event) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventQuery2githubcominngestinngestpkgcoreapigraphmodelsEventQuery(ctx context.Context, v interface{}) (models.EventQuery, error) {
	res, err := ec.unmarshalInputEventQuery(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEventsQuery2githubcominngestinngestpkgcoreapigraphmodelsEventsQuery(ctx context.Context, v interface{}) (models.EventsQuery, error) {
	res, err := ec.unmarshalInputEventsQuery(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx context.Context, sel ast.SelectionSet, v models.Function) graphql.Marshaler {
	return ec._Function(ctx, sel, &v)
}

func (ec *executionContext) marshalNFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx context.Context, sel ast.SelectionSet, v []*models.Function) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx context.Context, sel ast.SelectionSet, v *models.Function) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Function(ctx, sel, v)
}

func (ec *executionContext) marshalNFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx context.Context, sel ast.SelectionSet, v models.FunctionRun) graphql.Marshaler {
	return ec._FunctionRun(ctx, sel, &v)
}

func (ec *executionContext) marshalNFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx context.Context, sel ast.SelectionSet, v *models.FunctionRun) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FunctionRun(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFunctionRunQuery2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunQuery(ctx context.Context, v interface{}) (models.FunctionRunQuery, error) {
	res, err := ec.unmarshalInputFunctionRunQuery(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx context.Context, v interface{}) (models.FunctionRunStatus, error) {
	var res models.FunctionRunStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx context.Context, sel ast.SelectionSet, v models.FunctionRunStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFunctionRunV22githubcominngestinngestpkgcoreapigraphmodelsFunctionRunV2(ctx context.Context, sel ast.SelectionSet, v *models.FunctionRunV2) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FunctionRunV2(ctx, sel, v)
}

func (ec *executionContext) marshalNFunctionRunV2Edge2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunV2Edge(ctx context.Context, sel ast.SelectionSet, v []*models.FunctionRunV2Edge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFunctionRunV2Edge2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunV2Edge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFunctionRunV2Edge2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunV2Edge(ctx context.Context, sel ast.SelectionSet, v *models.FunctionRunV2Edge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FunctionRunV2Edge(ctx, sel, v)
}

func (ec *executionContext) marshalNFunctionTrigger2githubcominngestinngestpkgcoreapigraphmodelsFunctionTrigger(ctx context.Context, sel ast.SelectionSet, v *models.FunctionTrigger) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FunctionTrigger(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFunctionTriggerTypes2githubcominngestinngestpkgcoreapigraphmodelsFunctionTriggerTypes(ctx context.Context, v interface{}) (models.FunctionTriggerTypes, error) {
	var res models.FunctionTriggerTypes
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFunctionTriggerTypes2githubcominngestinngestpkgcoreapigraphmodelsFunctionTriggerTypes(ctx context.Context, sel ast.SelectionSet, v models.FunctionTriggerTypes) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNHistoryType2githubcominngestinngestpkgenumsHistoryType(ctx context.Context, v interface{}) (enums.HistoryType, error) {
	var res enums.HistoryType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHistoryType2githubcominngestinngestpkgenumsHistoryType(ctx context.Context, sel ast.SelectionSet, v enums.HistoryType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNPageInfo2githubcominngestinngestpkgcoreapigraphmodelsPageInfo(ctx context.Context, sel ast.SelectionSet, v *models.PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNRunHistoryItem2githubcominngestinngestpkghistory_readerRunHistory(ctx context.Context, sel ast.SelectionSet, v []*history_reader.RunHistory) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRunHistoryItem2githubcominngestinngestpkghistory_readerRunHistory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRunHistoryItem2githubcominngestinngestpkghistory_readerRunHistory(ctx context.Context, sel ast.SelectionSet, v *history_reader.RunHistory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RunHistoryItem(ctx, sel, v)
}

func (ec *executionContext) marshalNRunTraceSpan2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpan(ctx context.Context, sel ast.SelectionSet, v []*models.RunTraceSpan) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRunTraceSpan2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRunTraceSpan2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpan(ctx context.Context, sel ast.SelectionSet, v *models.RunTraceSpan) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RunTraceSpan(ctx, sel, v)
}

func (ec *executionContext) marshalNRunTraceSpanOutput2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpanOutput(ctx context.Context, sel ast.SelectionSet, v models.RunTraceSpanOutput) graphql.Marshaler {
	return ec._RunTraceSpanOutput(ctx, sel, &v)
}

func (ec *executionContext) marshalNRunTraceSpanOutput2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpanOutput(ctx context.Context, sel ast.SelectionSet, v *models.RunTraceSpanOutput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RunTraceSpanOutput(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRunTraceSpanStatus2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpanStatus(ctx context.Context, v interface{}) (models.RunTraceSpanStatus, error) {
	var res models.RunTraceSpanStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRunTraceSpanStatus2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpanStatus(ctx context.Context, sel ast.SelectionSet, v models.RunTraceSpanStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRunTraceTrigger2githubcominngestinngestpkgcoreapigraphmodelsRunTraceTrigger(ctx context.Context, sel ast.SelectionSet, v models.RunTraceTrigger) graphql.Marshaler {
	return ec._RunTraceTrigger(ctx, sel, &v)
}

func (ec *executionContext) marshalNRunTraceTrigger2githubcominngestinngestpkgcoreapigraphmodelsRunTraceTrigger(ctx context.Context, sel ast.SelectionSet, v *models.RunTraceTrigger) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RunTraceTrigger(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRunsFilterV22githubcominngestinngestpkgcoreapigraphmodelsRunsFilterV2(ctx context.Context, v interface{}) (models.RunsFilterV2, error) {
	res, err := ec.unmarshalInputRunsFilterV2(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRunsOrderByDirection2githubcominngestinngestpkgcoreapigraphmodelsRunsOrderByDirection(ctx context.Context, v interface{}) (models.RunsOrderByDirection, error) {
	var res models.RunsOrderByDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRunsOrderByDirection2githubcominngestinngestpkgcoreapigraphmodelsRunsOrderByDirection(ctx context.Context, sel ast.SelectionSet, v models.RunsOrderByDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRunsV2Connection2githubcominngestinngestpkgcoreapigraphmodelsRunsV2Connection(ctx context.Context, sel ast.SelectionSet, v models.RunsV2Connection) graphql.Marshaler {
	return ec._RunsV2Connection(ctx, sel, &v)
}

func (ec *executionContext) marshalNRunsV2Connection2githubcominngestinngestpkgcoreapigraphmodelsRunsV2Connection(ctx context.Context, sel ast.SelectionSet, v *models.RunsV2Connection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RunsV2Connection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRunsV2OrderBy2githubcominngestinngestpkgcoreapigraphmodelsRunsV2OrderBy(ctx context.Context, v interface{}) ([]*models.RunsV2OrderBy, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.RunsV2OrderBy, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRunsV2OrderBy2githubcominngestinngestpkgcoreapigraphmodelsRunsV2OrderBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNRunsV2OrderBy2githubcominngestinngestpkgcoreapigraphmodelsRunsV2OrderBy(ctx context.Context, v interface{}) (*models.RunsV2OrderBy, error) {
	res, err := ec.unmarshalInputRunsV2OrderBy(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRunsV2OrderByField2githubcominngestinngestpkgcoreapigraphmodelsRunsV2OrderByField(ctx context.Context, v interface{}) (models.RunsV2OrderByField, error) {
	var res models.RunsV2OrderByField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRunsV2OrderByField2githubcominngestinngestpkgcoreapigraphmodelsRunsV2OrderByField(ctx context.Context, sel ast.SelectionSet, v models.RunsV2OrderByField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNStreamItem2githubcominngestinngestpkgcoreapigraphmodelsStreamItem(ctx context.Context, sel ast.SelectionSet, v []*models.StreamItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStreamItem2githubcominngestinngestpkgcoreapigraphmodelsStreamItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStreamItem2githubcominngestinngestpkgcoreapigraphmodelsStreamItem(ctx context.Context, sel ast.SelectionSet, v *models.StreamItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StreamItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStreamQuery2githubcominngestinngestpkgcoreapigraphmodelsStreamQuery(ctx context.Context, v interface{}) (models.StreamQuery, error) {
	res, err := ec.unmarshalInputStreamQuery(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNStreamType2githubcominngestinngestpkgcoreapigraphmodelsStreamType(ctx context.Context, v interface{}) (models.StreamType, error) {
	var res models.StreamType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStreamType2githubcominngestinngestpkgcoreapigraphmodelsStreamType(ctx context.Context, sel ast.SelectionSet, v models.StreamType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNULID2githubcomoklogulidv2ULID(ctx context.Context, v interface{}) (ulid.ULID, error) {
	res, err := types.UnmarshalULID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNULID2githubcomoklogulidv2ULID(ctx context.Context, sel ast.SelectionSet, v ulid.ULID) graphql.Marshaler {
	res := types.MarshalULID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNULID2githubcomoklogulidv2ULID(ctx context.Context, v interface{}) ([]ulid.ULID, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]ulid.ULID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNULID2githubcomoklogulidv2ULID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNULID2githubcomoklogulidv2ULID(ctx context.Context, sel ast.SelectionSet, v []ulid.ULID) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNULID2githubcomoklogulidv2ULID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUUID2githubcomgoogleuuidUUID(ctx context.Context, v interface{}) (uuid.UUID, error) {
	res, err := types.UnmarshalUUID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUUID2githubcomgoogleuuidUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	res := types.MarshalUUID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUint2uint(ctx context.Context, v interface{}) (uint, error) {
	res, err := graphql.UnmarshalUint(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	res := graphql.MarshalUint(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateAppInput2githubcominngestinngestpkgcoreapigraphmodelsUpdateAppInput(ctx context.Context, v interface{}) (models.UpdateAppInput, error) {
	res, err := ec.unmarshalInputUpdateAppInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOBytes2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBytes2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOEvent2githubcominngestinngestpkgcoreapigraphmodelsEvent(ctx context.Context, sel ast.SelectionSet, v []*models.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2githubcominngestinngestpkgcoreapigraphmodelsEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOEvent2githubcominngestinngestpkgcoreapigraphmodelsEvent(ctx context.Context, sel ast.SelectionSet, v *models.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventStatus2githubcominngestinngestpkgcoreapigraphmodelsEventStatus(ctx context.Context, v interface{}) (*models.EventStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.EventStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventStatus2githubcominngestinngestpkgcoreapigraphmodelsEventStatus(ctx context.Context, sel ast.SelectionSet, v *models.EventStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx context.Context, sel ast.SelectionSet, v []*models.Function) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOFunction2githubcominngestinngestpkgcoreapigraphmodelsFunction(ctx context.Context, sel ast.SelectionSet, v *models.Function) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Function(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFunctionEventType2githubcominngestinngestpkgcoreapigraphmodelsFunctionEventType(ctx context.Context, v interface{}) (*models.FunctionEventType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.FunctionEventType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFunctionEventType2githubcominngestinngestpkgcoreapigraphmodelsFunctionEventType(ctx context.Context, sel ast.SelectionSet, v *models.FunctionEventType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx context.Context, sel ast.SelectionSet, v []*models.FunctionRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx context.Context, sel ast.SelectionSet, v []*models.FunctionRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOFunctionRun2githubcominngestinngestpkgcoreapigraphmodelsFunctionRun(ctx context.Context, sel ast.SelectionSet, v *models.FunctionRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FunctionRun(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx context.Context, v interface{}) ([]models.FunctionRunStatus, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.FunctionRunStatus, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx context.Context, sel ast.SelectionSet, v []models.FunctionRunStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx context.Context, v interface{}) (*models.FunctionRunStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.FunctionRunStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFunctionRunStatus2githubcominngestinngestpkgcoreapigraphmodelsFunctionRunStatus(ctx context.Context, sel ast.SelectionSet, v *models.FunctionRunStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFunctionRunV22githubcominngestinngestpkgcoreapigraphmodelsFunctionRunV2(ctx context.Context, sel ast.SelectionSet, v *models.FunctionRunV2) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FunctionRunV2(ctx, sel, v)
}

func (ec *executionContext) marshalOFunctionTrigger2githubcominngestinngestpkgcoreapigraphmodelsFunctionTrigger(ctx context.Context, sel ast.SelectionSet, v []*models.FunctionTrigger) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFunctionTrigger2githubcominngestinngestpkgcoreapigraphmodelsFunctionTrigger(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHistoryStepType2githubcominngestinngestpkgenumsHistoryStepType(ctx context.Context, v interface{}) (*enums.HistoryStepType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(enums.HistoryStepType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHistoryStepType2githubcominngestinngestpkgenumsHistoryStepType(ctx context.Context, sel ast.SelectionSet, v *enums.HistoryStepType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalORerunFromStepInput2githubcominngestinngestpkgcoreapigraphmodelsRerunFromStepInput(ctx context.Context, v interface{}) (*models.RerunFromStepInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRerunFromStepInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORunHistoryCancel2githubcominngestinngestpkghistory_readerRunHistoryCancel(ctx context.Context, sel ast.SelectionSet, v *history_reader.RunHistoryCancel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RunHistoryCancel(ctx, sel, v)
}

func (ec *executionContext) marshalORunHistoryInvokeFunction2githubcominngestinngestpkghistory_readerRunHistoryInvokeFunction(ctx context.Context, sel ast.SelectionSet, v *history_reader.RunHistoryInvokeFunction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RunHistoryInvokeFunction(ctx, sel, v)
}

func (ec *executionContext) marshalORunHistoryInvokeFunctionResult2githubcominngestinngestpkghistory_readerRunHistoryInvokeFunctionResult(ctx context.Context, sel ast.SelectionSet, v *history_reader.RunHistoryInvokeFunctionResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RunHistoryInvokeFunctionResult(ctx, sel, v)
}

func (ec *executionContext) marshalORunHistoryResult2githubcominngestinngestpkghistory_readerRunHistoryResult(ctx context.Context, sel ast.SelectionSet, v *history_reader.RunHistoryResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RunHistoryResult(ctx, sel, v)
}

func (ec *executionContext) marshalORunHistorySleep2githubcominngestinngestpkghistory_readerRunHistorySleep(ctx context.Context, sel ast.SelectionSet, v *history_reader.RunHistorySleep) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RunHistorySleep(ctx, sel, v)
}

func (ec *executionContext) marshalORunHistoryWaitForEvent2githubcominngestinngestpkghistory_readerRunHistoryWaitForEvent(ctx context.Context, sel ast.SelectionSet, v *history_reader.RunHistoryWaitForEvent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RunHistoryWaitForEvent(ctx, sel, v)
}

func (ec *executionContext) marshalORunHistoryWaitResult2githubcominngestinngestpkghistory_readerRunHistoryWaitResult(ctx context.Context, sel ast.SelectionSet, v *history_reader.RunHistoryWaitResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RunHistoryWaitResult(ctx, sel, v)
}

func (ec *executionContext) marshalORunTraceSpan2githubcominngestinngestpkgcoreapigraphmodelsRunTraceSpan(ctx context.Context, sel ast.SelectionSet, v *models.RunTraceSpan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RunTraceSpan(ctx, sel, v)
}

func (ec *executionContext) unmarshalORunsV2OrderByField2githubcominngestinngestpkgcoreapigraphmodelsRunsV2OrderByField(ctx context.Context, v interface{}) (*models.RunsV2OrderByField, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.RunsV2OrderByField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORunsV2OrderByField2githubcominngestinngestpkgcoreapigraphmodelsRunsV2OrderByField(ctx context.Context, sel ast.SelectionSet, v *models.RunsV2OrderByField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOStepError2githubcominngestinngestpkgcoreapigraphmodelsStepError(ctx context.Context, sel ast.SelectionSet, v *models.StepError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StepError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStepEventType2githubcominngestinngestpkgcoreapigraphmodelsStepEventType(ctx context.Context, v interface{}) (*models.StepEventType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.StepEventType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStepEventType2githubcominngestinngestpkgcoreapigraphmodelsStepEventType(ctx context.Context, sel ast.SelectionSet, v *models.StepEventType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOStepEventWait2githubcominngestinngestpkgcoreapigraphmodelsStepEventWait(ctx context.Context, sel ast.SelectionSet, v *models.StepEventWait) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StepEventWait(ctx, sel, v)
}

func (ec *executionContext) marshalOStepInfo2githubcominngestinngestpkgcoreapigraphmodelsStepInfo(ctx context.Context, sel ast.SelectionSet, v models.StepInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StepInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStepOp2githubcominngestinngestpkgcoreapigraphmodelsStepOp(ctx context.Context, v interface{}) (*models.StepOp, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.StepOp)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStepOp2githubcominngestinngestpkgcoreapigraphmodelsStepOp(ctx context.Context, sel ast.SelectionSet, v *models.StepOp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalOULID2githubcomoklogulidv2ULID(ctx context.Context, v interface{}) (*ulid.ULID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := types.UnmarshalULID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOULID2githubcomoklogulidv2ULID(ctx context.Context, sel ast.SelectionSet, v *ulid.ULID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := types.MarshalULID(*v)
	return res
}

func (ec *executionContext) unmarshalOUUID2githubcomgoogleuuidUUID(ctx context.Context, v interface{}) ([]uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]uuid.UUID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUUID2githubcomgoogleuuidUUID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUUID2githubcomgoogleuuidUUID(ctx context.Context, sel ast.SelectionSet, v []uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUUID2githubcomgoogleuuidUUID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUUID2githubcomgoogleuuidUUID(ctx context.Context, v interface{}) (*uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := types.UnmarshalUUID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUUID2githubcomgoogleuuidUUID(ctx context.Context, sel ast.SelectionSet, v *uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := types.MarshalUUID(*v)
	return res
}

func (ec *executionContext) marshalOWorkspace2githubcominngestinngestpkgcoreapigraphmodelsWorkspace(ctx context.Context, sel ast.SelectionSet, v *models.Workspace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Workspace(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************

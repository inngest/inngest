// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/inngest/inngest/pkg/cqrs"
	"github.com/inngest/inngest/pkg/history_reader"
	ulid "github.com/oklog/ulid/v2"
)

type FunctionRunEvent interface {
	IsFunctionRunEvent()
}

type StepInfo interface {
	IsStepInfo()
}

type ActionVersionQuery struct {
	Dsn          string `json:"dsn"`
	VersionMajor *int   `json:"versionMajor,omitempty"`
	VersionMinor *int   `json:"versionMinor,omitempty"`
}

type AppsFilterV1 struct {
	Method *AppMethod `json:"method,omitempty"`
}

type CancellationConfiguration struct {
	Event     string  `json:"event"`
	Timeout   *string `json:"timeout,omitempty"`
	Condition *string `json:"condition,omitempty"`
}

type ConcurrencyConfiguration struct {
	Scope ConcurrencyScope               `json:"scope"`
	Limit *ConcurrencyLimitConfiguration `json:"limit"`
	Key   *string                        `json:"key,omitempty"`
}

type ConcurrencyLimitConfiguration struct {
	Value       int   `json:"value"`
	IsPlanLimit *bool `json:"isPlanLimit,omitempty"`
}

type ConnectV1WorkerConnection struct {
	ID               ulid.ULID                 `json:"id"`
	GatewayID        ulid.ULID                 `json:"gatewayId"`
	InstanceID       string                    `json:"instanceId"`
	WorkerIP         string                    `json:"workerIp"`
	AppName          *string                   `json:"appName,omitempty"`
	AppID            *uuid.UUID                `json:"appID,omitempty"`
	App              *cqrs.App                 `json:"app,omitempty"`
	ConnectedAt      time.Time                 `json:"connectedAt"`
	LastHeartbeatAt  *time.Time                `json:"lastHeartbeatAt,omitempty"`
	DisconnectedAt   *time.Time                `json:"disconnectedAt,omitempty"`
	DisconnectReason *string                   `json:"disconnectReason,omitempty"`
	Status           ConnectV1ConnectionStatus `json:"status"`
	GroupHash        string                    `json:"groupHash"`
	SdkLang          string                    `json:"sdkLang"`
	SdkVersion       string                    `json:"sdkVersion"`
	SdkPlatform      string                    `json:"sdkPlatform"`
	SyncID           *uuid.UUID                `json:"syncId,omitempty"`
	BuildID          *string                   `json:"buildId,omitempty"`
	AppVersion       *string                   `json:"appVersion,omitempty"`
	FunctionCount    int                       `json:"functionCount"`
	CPUCores         int                       `json:"cpuCores"`
	MemBytes         int                       `json:"memBytes"`
	Os               string                    `json:"os"`
}

type ConnectV1WorkerConnectionEdge struct {
	Node   *ConnectV1WorkerConnection `json:"node"`
	Cursor string                     `json:"cursor"`
}

type ConnectV1WorkerConnectionsFilter struct {
	From      *time.Time                              `json:"from,omitempty"`
	Until     *time.Time                              `json:"until,omitempty"`
	TimeField *ConnectV1WorkerConnectionsOrderByField `json:"timeField,omitempty"`
	Status    []ConnectV1ConnectionStatus             `json:"status,omitempty"`
	AppIDs    []uuid.UUID                             `json:"appIDs,omitempty"`
}

type ConnectV1WorkerConnectionsOrderBy struct {
	Field     ConnectV1WorkerConnectionsOrderByField     `json:"field"`
	Direction ConnectV1WorkerConnectionsOrderByDirection `json:"direction"`
}

type CreateAppInput struct {
	URL string `json:"url"`
}

type DebounceConfiguration struct {
	Period string  `json:"period"`
	Key    *string `json:"key,omitempty"`
}

type Event struct {
	ID           ulid.ULID      `json:"id"`
	ExternalID   *string        `json:"externalID,omitempty"`
	Workspace    *Workspace     `json:"workspace,omitempty"`
	Name         *string        `json:"name,omitempty"`
	CreatedAt    *time.Time     `json:"createdAt,omitempty"`
	Payload      *string        `json:"payload,omitempty"`
	Schema       *string        `json:"schema,omitempty"`
	Status       *EventStatus   `json:"status,omitempty"`
	PendingRuns  *int           `json:"pendingRuns,omitempty"`
	TotalRuns    *int           `json:"totalRuns,omitempty"`
	Raw          *string        `json:"raw,omitempty"`
	FunctionRuns []*FunctionRun `json:"functionRuns,omitempty"`
}

type EventQuery struct {
	WorkspaceID string `json:"workspaceId"`
	EventID     string `json:"eventId"`
}

type EventSource struct {
	ID         string  `json:"id"`
	Name       *string `json:"name,omitempty"`
	SourceKind string  `json:"sourceKind"`
}

type EventV2 struct {
	EnvID          uuid.UUID        `json:"envID"`
	ID             ulid.ULID        `json:"id"`
	IdempotencyKey *string          `json:"idempotencyKey,omitempty"`
	Name           string           `json:"name"`
	OccurredAt     time.Time        `json:"occurredAt"`
	Raw            string           `json:"raw"`
	ReceivedAt     time.Time        `json:"receivedAt"`
	Runs           []*FunctionRunV2 `json:"runs"`
	Source         *EventSource     `json:"source,omitempty"`
	Version        *string          `json:"version,omitempty"`
}

type EventsBatchConfiguration struct {
	// The maximum number of events a batch can have.
	MaxSize int `json:"maxSize"`
	// How long to wait before running the function with the batch.
	Timeout string  `json:"timeout"`
	Key     *string `json:"key,omitempty"`
}

type EventsConnection struct {
	Edges      []*EventsEdge `json:"edges"`
	PageInfo   *PageInfo     `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

type EventsEdge struct {
	Node   *EventV2 `json:"node"`
	Cursor string   `json:"cursor"`
}

type EventsFilter struct {
	EventNames            []string   `json:"eventNames,omitempty"`
	From                  time.Time  `json:"from"`
	IncludeInternalEvents bool       `json:"includeInternalEvents"`
	Query                 *string    `json:"query,omitempty"`
	Until                 *time.Time `json:"until,omitempty"`
}

type EventsQuery struct {
	WorkspaceID string  `json:"workspaceId"`
	LastEventID *string `json:"lastEventId,omitempty"`
}

type Function struct {
	ID             string                 `json:"id"`
	Name           string                 `json:"name"`
	Slug           string                 `json:"slug"`
	FailureHandler *Function              `json:"failureHandler,omitempty"`
	Config         string                 `json:"config"`
	Configuration  *FunctionConfiguration `json:"configuration"`
	Concurrency    int                    `json:"concurrency"`
	Triggers       []*FunctionTrigger     `json:"triggers,omitempty"`
	URL            string                 `json:"url"`
	AppID          string                 `json:"appID"`
	App            *cqrs.App              `json:"app"`
}

type FunctionConfiguration struct {
	Cancellations []*CancellationConfiguration `json:"cancellations"`
	Retries       *RetryConfiguration          `json:"retries"`
	Priority      *string                      `json:"priority,omitempty"`
	EventsBatch   *EventsBatchConfiguration    `json:"eventsBatch,omitempty"`
	Concurrency   []*ConcurrencyConfiguration  `json:"concurrency"`
	RateLimit     *RateLimitConfiguration      `json:"rateLimit,omitempty"`
	Debounce      *DebounceConfiguration       `json:"debounce,omitempty"`
	Throttle      *ThrottleConfiguration       `json:"throttle,omitempty"`
	Singleton     *SingletonConfiguration      `json:"singleton,omitempty"`
}

type FunctionEvent struct {
	Workspace   *Workspace         `json:"workspace,omitempty"`
	FunctionRun *FunctionRun       `json:"functionRun,omitempty"`
	Type        *FunctionEventType `json:"type,omitempty"`
	Output      *string            `json:"output,omitempty"`
	CreatedAt   *time.Time         `json:"createdAt,omitempty"`
}

func (FunctionEvent) IsFunctionRunEvent() {}

type FunctionQuery struct {
	WorkspaceID  string `json:"workspaceId"`
	FunctionSlug string `json:"functionSlug"`
}

type FunctionRun struct {
	ID                string                       `json:"id"`
	FunctionID        string                       `json:"functionID"`
	Function          *Function                    `json:"function,omitempty"`
	Workspace         *Workspace                   `json:"workspace,omitempty"`
	Event             *Event                       `json:"event,omitempty"`
	Events            []*Event                     `json:"events"`
	BatchID           *ulid.ULID                   `json:"batchID,omitempty"`
	BatchCreatedAt    *time.Time                   `json:"batchCreatedAt,omitempty"`
	Status            *FunctionRunStatus           `json:"status,omitempty"`
	WaitingFor        *StepEventWait               `json:"waitingFor,omitempty"`
	PendingSteps      *int                         `json:"pendingSteps,omitempty"`
	StartedAt         *time.Time                   `json:"startedAt,omitempty"`
	FinishedAt        *time.Time                   `json:"finishedAt,omitempty"`
	Output            *string                      `json:"output,omitempty"`
	History           []*history_reader.RunHistory `json:"history"`
	HistoryItemOutput *string                      `json:"historyItemOutput,omitempty"`
	EventID           string                       `json:"eventID"`
	Cron              *string                      `json:"cron,omitempty"`
}

type FunctionRunQuery struct {
	WorkspaceID   string `json:"workspaceId"`
	FunctionRunID string `json:"functionRunId"`
}

type FunctionRunV2 struct {
	ID             ulid.ULID         `json:"id"`
	AppID          uuid.UUID         `json:"appID"`
	App            *cqrs.App         `json:"app"`
	FunctionID     uuid.UUID         `json:"functionID"`
	Function       *Function         `json:"function"`
	TraceID        string            `json:"traceID"`
	QueuedAt       time.Time         `json:"queuedAt"`
	StartedAt      *time.Time        `json:"startedAt,omitempty"`
	EndedAt        *time.Time        `json:"endedAt,omitempty"`
	Status         FunctionRunStatus `json:"status"`
	SourceID       *string           `json:"sourceID,omitempty"`
	TriggerIDs     []ulid.ULID       `json:"triggerIDs"`
	EventName      *string           `json:"eventName,omitempty"`
	IsBatch        bool              `json:"isBatch"`
	BatchCreatedAt *time.Time        `json:"batchCreatedAt,omitempty"`
	CronSchedule   *string           `json:"cronSchedule,omitempty"`
	Output         *string           `json:"output,omitempty"`
	Trace          *RunTraceSpan     `json:"trace,omitempty"`
	HasAi          bool              `json:"hasAI"`
}

type FunctionRunV2Edge struct {
	Node   *FunctionRunV2 `json:"node"`
	Cursor string         `json:"cursor"`
}

type FunctionRunsQuery struct {
	WorkspaceID string `json:"workspaceId"`
}

type FunctionTrigger struct {
	Type      FunctionTriggerTypes `json:"type"`
	Value     string               `json:"value"`
	Condition *string              `json:"condition,omitempty"`
}

type InvokeStepInfo struct {
	TriggeringEventID ulid.ULID  `json:"triggeringEventID"`
	FunctionID        string     `json:"functionID"`
	Timeout           time.Time  `json:"timeout"`
	ReturnEventID     *ulid.ULID `json:"returnEventID,omitempty"`
	RunID             *ulid.ULID `json:"runID,omitempty"`
	TimedOut          *bool      `json:"timedOut,omitempty"`
}

func (InvokeStepInfo) IsStepInfo() {}

// The pagination information in a connection.
type PageInfo struct {
	// Indicates if there are any pages subsequent to the current page.
	HasNextPage bool `json:"hasNextPage"`
	// Indicates if there are any pages prior to the current page.
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backward, the cursor to query the previous page.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forward, the cursor to query the next page.
	EndCursor *string `json:"endCursor,omitempty"`
}

type RateLimitConfiguration struct {
	Limit  int     `json:"limit"`
	Period string  `json:"period"`
	Key    *string `json:"key,omitempty"`
}

type RerunFromStepInput struct {
	StepID string  `json:"stepID"`
	Input  *string `json:"input,omitempty"`
}

type RetryConfiguration struct {
	Value     int   `json:"value"`
	IsDefault *bool `json:"isDefault,omitempty"`
}

type RunStepInfo struct {
	Type *string `json:"type,omitempty"`
}

func (RunStepInfo) IsStepInfo() {}

type RunTraceSpan struct {
	AppID          uuid.UUID          `json:"appID"`
	FunctionID     uuid.UUID          `json:"functionID"`
	RunID          ulid.ULID          `json:"runID"`
	Run            *FunctionRun       `json:"run"`
	SpanID         string             `json:"spanID"`
	TraceID        string             `json:"traceID"`
	Name           string             `json:"name"`
	Status         RunTraceSpanStatus `json:"status"`
	Attempts       *int               `json:"attempts,omitempty"`
	Duration       *int               `json:"duration,omitempty"`
	OutputID       *string            `json:"outputID,omitempty"`
	QueuedAt       time.Time          `json:"queuedAt"`
	StartedAt      *time.Time         `json:"startedAt,omitempty"`
	EndedAt        *time.Time         `json:"endedAt,omitempty"`
	ChildrenSpans  []*RunTraceSpan    `json:"childrenSpans"`
	StepOp         *StepOp            `json:"stepOp,omitempty"`
	StepID         *string            `json:"stepID,omitempty"`
	StepInfo       StepInfo           `json:"stepInfo,omitempty"`
	IsRoot         bool               `json:"isRoot"`
	ParentSpanID   *string            `json:"parentSpanID,omitempty"`
	ParentSpan     *RunTraceSpan      `json:"parentSpan,omitempty"`
	IsUserland     bool               `json:"isUserland"`
	UserlandSpan   *UserlandSpan      `json:"userlandSpan,omitempty"`
	DebugRunID     *string            `json:"debugRunID,omitempty"`
	DebugSessionID *string            `json:"debugSessionID,omitempty"`
}

type RunTraceSpanOutput struct {
	Input *string    `json:"input,omitempty"`
	Data  *string    `json:"data,omitempty"`
	Error *StepError `json:"error,omitempty"`
}

type RunTraceTrigger struct {
	EventName *string     `json:"eventName,omitempty"`
	IDs       []ulid.ULID `json:"IDs"`
	Payloads  []string    `json:"payloads"`
	Timestamp time.Time   `json:"timestamp"`
	IsBatch   bool        `json:"isBatch"`
	BatchID   *ulid.ULID  `json:"batchID,omitempty"`
	Cron      *string     `json:"cron,omitempty"`
}

type RunsFilterV2 struct {
	From        time.Time           `json:"from"`
	Until       *time.Time          `json:"until,omitempty"`
	TimeField   *RunsV2OrderByField `json:"timeField,omitempty"`
	Status      []FunctionRunStatus `json:"status,omitempty"`
	FunctionIDs []uuid.UUID         `json:"functionIDs,omitempty"`
	AppIDs      []uuid.UUID         `json:"appIDs,omitempty"`
	Query       *string             `json:"query,omitempty"`
}

type RunsV2OrderBy struct {
	Field     RunsV2OrderByField   `json:"field"`
	Direction RunsOrderByDirection `json:"direction"`
}

type SingletonConfiguration struct {
	Mode SingletonMode `json:"mode"`
	Key  *string       `json:"key,omitempty"`
}

type SleepStepInfo struct {
	SleepUntil time.Time `json:"sleepUntil"`
}

func (SleepStepInfo) IsStepInfo() {}

type StepError struct {
	Message string      `json:"message"`
	Name    *string     `json:"name,omitempty"`
	Stack   *string     `json:"stack,omitempty"`
	Cause   interface{} `json:"cause,omitempty"`
}

type StepEvent struct {
	Workspace   *Workspace     `json:"workspace,omitempty"`
	FunctionRun *FunctionRun   `json:"functionRun,omitempty"`
	StepID      *string        `json:"stepID,omitempty"`
	Name        *string        `json:"name,omitempty"`
	Type        *StepEventType `json:"type,omitempty"`
	Output      *string        `json:"output,omitempty"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	WaitingFor  *StepEventWait `json:"waitingFor,omitempty"`
}

func (StepEvent) IsFunctionRunEvent() {}

type StepEventWait struct {
	EventName  *string   `json:"eventName,omitempty"`
	Expression *string   `json:"expression,omitempty"`
	ExpiryTime time.Time `json:"expiryTime"`
}

type StreamItem struct {
	ID        string         `json:"id"`
	Trigger   string         `json:"trigger"`
	Type      StreamType     `json:"type"`
	CreatedAt time.Time      `json:"createdAt"`
	Runs      []*FunctionRun `json:"runs,omitempty"`
	InBatch   bool           `json:"inBatch"`
}

type StreamQuery struct {
	After                 *string `json:"after,omitempty"`
	Before                *string `json:"before,omitempty"`
	Limit                 int     `json:"limit"`
	IncludeInternalEvents *bool   `json:"includeInternalEvents,omitempty"`
}

type ThrottleConfiguration struct {
	Burst  int     `json:"burst"`
	Key    *string `json:"key,omitempty"`
	Limit  int     `json:"limit"`
	Period string  `json:"period"`
}

type UpdateAppInput struct {
	ID  string `json:"id"`
	URL string `json:"url"`
}

type UserlandSpan struct {
	SpanName      *string `json:"spanName,omitempty"`
	SpanKind      *string `json:"spanKind,omitempty"`
	ServiceName   *string `json:"serviceName,omitempty"`
	ResourceAttrs *string `json:"resourceAttrs,omitempty"`
	ScopeName     *string `json:"scopeName,omitempty"`
	ScopeVersion  *string `json:"scopeVersion,omitempty"`
	SpanAttrs     *string `json:"spanAttrs,omitempty"`
}

type WaitForEventStepInfo struct {
	EventName    string     `json:"eventName"`
	Expression   *string    `json:"expression,omitempty"`
	Timeout      time.Time  `json:"timeout"`
	FoundEventID *ulid.ULID `json:"foundEventID,omitempty"`
	TimedOut     *bool      `json:"timedOut,omitempty"`
}

func (WaitForEventStepInfo) IsStepInfo() {}

type WaitForSignalStepInfo struct {
	Signal   string    `json:"signal"`
	Timeout  time.Time `json:"timeout"`
	TimedOut *bool     `json:"timedOut,omitempty"`
}

func (WaitForSignalStepInfo) IsStepInfo() {}

type Workspace struct {
	ID string `json:"id"`
}

type AppMethod string

const (
	AppMethodServe   AppMethod = "SERVE"
	AppMethodConnect AppMethod = "CONNECT"
	AppMethodAPI     AppMethod = "API"
)

var AllAppMethod = []AppMethod{
	AppMethodServe,
	AppMethodConnect,
	AppMethodAPI,
}

func (e AppMethod) IsValid() bool {
	switch e {
	case AppMethodServe, AppMethodConnect, AppMethodAPI:
		return true
	}
	return false
}

func (e AppMethod) String() string {
	return string(e)
}

func (e *AppMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppMethod", str)
	}
	return nil
}

func (e AppMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConcurrencyScope string

const (
	ConcurrencyScopeAccount     ConcurrencyScope = "ACCOUNT"
	ConcurrencyScopeEnvironment ConcurrencyScope = "ENVIRONMENT"
	ConcurrencyScopeFunction    ConcurrencyScope = "FUNCTION"
)

var AllConcurrencyScope = []ConcurrencyScope{
	ConcurrencyScopeAccount,
	ConcurrencyScopeEnvironment,
	ConcurrencyScopeFunction,
}

func (e ConcurrencyScope) IsValid() bool {
	switch e {
	case ConcurrencyScopeAccount, ConcurrencyScopeEnvironment, ConcurrencyScopeFunction:
		return true
	}
	return false
}

func (e ConcurrencyScope) String() string {
	return string(e)
}

func (e *ConcurrencyScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConcurrencyScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConcurrencyScope", str)
	}
	return nil
}

func (e ConcurrencyScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectV1ConnectionStatus string

const (
	ConnectV1ConnectionStatusConnected     ConnectV1ConnectionStatus = "CONNECTED"
	ConnectV1ConnectionStatusReady         ConnectV1ConnectionStatus = "READY"
	ConnectV1ConnectionStatusDraining      ConnectV1ConnectionStatus = "DRAINING"
	ConnectV1ConnectionStatusDisconnecting ConnectV1ConnectionStatus = "DISCONNECTING"
	ConnectV1ConnectionStatusDisconnected  ConnectV1ConnectionStatus = "DISCONNECTED"
)

var AllConnectV1ConnectionStatus = []ConnectV1ConnectionStatus{
	ConnectV1ConnectionStatusConnected,
	ConnectV1ConnectionStatusReady,
	ConnectV1ConnectionStatusDraining,
	ConnectV1ConnectionStatusDisconnecting,
	ConnectV1ConnectionStatusDisconnected,
}

func (e ConnectV1ConnectionStatus) IsValid() bool {
	switch e {
	case ConnectV1ConnectionStatusConnected, ConnectV1ConnectionStatusReady, ConnectV1ConnectionStatusDraining, ConnectV1ConnectionStatusDisconnecting, ConnectV1ConnectionStatusDisconnected:
		return true
	}
	return false
}

func (e ConnectV1ConnectionStatus) String() string {
	return string(e)
}

func (e *ConnectV1ConnectionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectV1ConnectionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectV1ConnectionStatus", str)
	}
	return nil
}

func (e ConnectV1ConnectionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectV1WorkerConnectionsOrderByDirection string

const (
	ConnectV1WorkerConnectionsOrderByDirectionAsc  ConnectV1WorkerConnectionsOrderByDirection = "ASC"
	ConnectV1WorkerConnectionsOrderByDirectionDesc ConnectV1WorkerConnectionsOrderByDirection = "DESC"
)

var AllConnectV1WorkerConnectionsOrderByDirection = []ConnectV1WorkerConnectionsOrderByDirection{
	ConnectV1WorkerConnectionsOrderByDirectionAsc,
	ConnectV1WorkerConnectionsOrderByDirectionDesc,
}

func (e ConnectV1WorkerConnectionsOrderByDirection) IsValid() bool {
	switch e {
	case ConnectV1WorkerConnectionsOrderByDirectionAsc, ConnectV1WorkerConnectionsOrderByDirectionDesc:
		return true
	}
	return false
}

func (e ConnectV1WorkerConnectionsOrderByDirection) String() string {
	return string(e)
}

func (e *ConnectV1WorkerConnectionsOrderByDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectV1WorkerConnectionsOrderByDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectV1WorkerConnectionsOrderByDirection", str)
	}
	return nil
}

func (e ConnectV1WorkerConnectionsOrderByDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectV1WorkerConnectionsOrderByField string

const (
	ConnectV1WorkerConnectionsOrderByFieldConnectedAt     ConnectV1WorkerConnectionsOrderByField = "CONNECTED_AT"
	ConnectV1WorkerConnectionsOrderByFieldLastHeartbeatAt ConnectV1WorkerConnectionsOrderByField = "LAST_HEARTBEAT_AT"
	ConnectV1WorkerConnectionsOrderByFieldDisconnectedAt  ConnectV1WorkerConnectionsOrderByField = "DISCONNECTED_AT"
)

var AllConnectV1WorkerConnectionsOrderByField = []ConnectV1WorkerConnectionsOrderByField{
	ConnectV1WorkerConnectionsOrderByFieldConnectedAt,
	ConnectV1WorkerConnectionsOrderByFieldLastHeartbeatAt,
	ConnectV1WorkerConnectionsOrderByFieldDisconnectedAt,
}

func (e ConnectV1WorkerConnectionsOrderByField) IsValid() bool {
	switch e {
	case ConnectV1WorkerConnectionsOrderByFieldConnectedAt, ConnectV1WorkerConnectionsOrderByFieldLastHeartbeatAt, ConnectV1WorkerConnectionsOrderByFieldDisconnectedAt:
		return true
	}
	return false
}

func (e ConnectV1WorkerConnectionsOrderByField) String() string {
	return string(e)
}

func (e *ConnectV1WorkerConnectionsOrderByField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectV1WorkerConnectionsOrderByField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectV1WorkerConnectionsOrderByField", str)
	}
	return nil
}

func (e ConnectV1WorkerConnectionsOrderByField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventStatus string

const (
	EventStatusRunning         EventStatus = "RUNNING"
	EventStatusCompleted       EventStatus = "COMPLETED"
	EventStatusPaused          EventStatus = "PAUSED"
	EventStatusFailed          EventStatus = "FAILED"
	EventStatusPartiallyFailed EventStatus = "PARTIALLY_FAILED"
	EventStatusNoFunctions     EventStatus = "NO_FUNCTIONS"
)

var AllEventStatus = []EventStatus{
	EventStatusRunning,
	EventStatusCompleted,
	EventStatusPaused,
	EventStatusFailed,
	EventStatusPartiallyFailed,
	EventStatusNoFunctions,
}

func (e EventStatus) IsValid() bool {
	switch e {
	case EventStatusRunning, EventStatusCompleted, EventStatusPaused, EventStatusFailed, EventStatusPartiallyFailed, EventStatusNoFunctions:
		return true
	}
	return false
}

func (e EventStatus) String() string {
	return string(e)
}

func (e *EventStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventStatus", str)
	}
	return nil
}

func (e EventStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FunctionEventType string

const (
	FunctionEventTypeStarted   FunctionEventType = "STARTED"
	FunctionEventTypeCompleted FunctionEventType = "COMPLETED"
	FunctionEventTypeFailed    FunctionEventType = "FAILED"
	FunctionEventTypeCancelled FunctionEventType = "CANCELLED"
)

var AllFunctionEventType = []FunctionEventType{
	FunctionEventTypeStarted,
	FunctionEventTypeCompleted,
	FunctionEventTypeFailed,
	FunctionEventTypeCancelled,
}

func (e FunctionEventType) IsValid() bool {
	switch e {
	case FunctionEventTypeStarted, FunctionEventTypeCompleted, FunctionEventTypeFailed, FunctionEventTypeCancelled:
		return true
	}
	return false
}

func (e FunctionEventType) String() string {
	return string(e)
}

func (e *FunctionEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FunctionEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FunctionEventType", str)
	}
	return nil
}

func (e FunctionEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FunctionRunStatus string

const (
	FunctionRunStatusCompleted FunctionRunStatus = "COMPLETED"
	FunctionRunStatusFailed    FunctionRunStatus = "FAILED"
	FunctionRunStatusCancelled FunctionRunStatus = "CANCELLED"
	FunctionRunStatusRunning   FunctionRunStatus = "RUNNING"
	FunctionRunStatusQueued    FunctionRunStatus = "QUEUED"
)

var AllFunctionRunStatus = []FunctionRunStatus{
	FunctionRunStatusCompleted,
	FunctionRunStatusFailed,
	FunctionRunStatusCancelled,
	FunctionRunStatusRunning,
	FunctionRunStatusQueued,
}

func (e FunctionRunStatus) IsValid() bool {
	switch e {
	case FunctionRunStatusCompleted, FunctionRunStatusFailed, FunctionRunStatusCancelled, FunctionRunStatusRunning, FunctionRunStatusQueued:
		return true
	}
	return false
}

func (e FunctionRunStatus) String() string {
	return string(e)
}

func (e *FunctionRunStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FunctionRunStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FunctionRunStatus", str)
	}
	return nil
}

func (e FunctionRunStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FunctionStatus string

const (
	FunctionStatusRunning   FunctionStatus = "RUNNING"
	FunctionStatusCompleted FunctionStatus = "COMPLETED"
	FunctionStatusFailed    FunctionStatus = "FAILED"
	FunctionStatusCancelled FunctionStatus = "CANCELLED"
)

var AllFunctionStatus = []FunctionStatus{
	FunctionStatusRunning,
	FunctionStatusCompleted,
	FunctionStatusFailed,
	FunctionStatusCancelled,
}

func (e FunctionStatus) IsValid() bool {
	switch e {
	case FunctionStatusRunning, FunctionStatusCompleted, FunctionStatusFailed, FunctionStatusCancelled:
		return true
	}
	return false
}

func (e FunctionStatus) String() string {
	return string(e)
}

func (e *FunctionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FunctionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FunctionStatus", str)
	}
	return nil
}

func (e FunctionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FunctionTriggerTypes string

const (
	FunctionTriggerTypesEvent FunctionTriggerTypes = "EVENT"
	FunctionTriggerTypesCron  FunctionTriggerTypes = "CRON"
)

var AllFunctionTriggerTypes = []FunctionTriggerTypes{
	FunctionTriggerTypesEvent,
	FunctionTriggerTypesCron,
}

func (e FunctionTriggerTypes) IsValid() bool {
	switch e {
	case FunctionTriggerTypesEvent, FunctionTriggerTypesCron:
		return true
	}
	return false
}

func (e FunctionTriggerTypes) String() string {
	return string(e)
}

func (e *FunctionTriggerTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FunctionTriggerTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FunctionTriggerTypes", str)
	}
	return nil
}

func (e FunctionTriggerTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RunTraceSpanStatus string

const (
	RunTraceSpanStatusFailed    RunTraceSpanStatus = "FAILED"
	RunTraceSpanStatusQueued    RunTraceSpanStatus = "QUEUED"
	RunTraceSpanStatusRunning   RunTraceSpanStatus = "RUNNING"
	RunTraceSpanStatusCompleted RunTraceSpanStatus = "COMPLETED"
	RunTraceSpanStatusWaiting   RunTraceSpanStatus = "WAITING"
	RunTraceSpanStatusCancelled RunTraceSpanStatus = "CANCELLED"
)

var AllRunTraceSpanStatus = []RunTraceSpanStatus{
	RunTraceSpanStatusFailed,
	RunTraceSpanStatusQueued,
	RunTraceSpanStatusRunning,
	RunTraceSpanStatusCompleted,
	RunTraceSpanStatusWaiting,
	RunTraceSpanStatusCancelled,
}

func (e RunTraceSpanStatus) IsValid() bool {
	switch e {
	case RunTraceSpanStatusFailed, RunTraceSpanStatusQueued, RunTraceSpanStatusRunning, RunTraceSpanStatusCompleted, RunTraceSpanStatusWaiting, RunTraceSpanStatusCancelled:
		return true
	}
	return false
}

func (e RunTraceSpanStatus) String() string {
	return string(e)
}

func (e *RunTraceSpanStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RunTraceSpanStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RunTraceSpanStatus", str)
	}
	return nil
}

func (e RunTraceSpanStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RunsOrderByDirection string

const (
	RunsOrderByDirectionAsc  RunsOrderByDirection = "ASC"
	RunsOrderByDirectionDesc RunsOrderByDirection = "DESC"
)

var AllRunsOrderByDirection = []RunsOrderByDirection{
	RunsOrderByDirectionAsc,
	RunsOrderByDirectionDesc,
}

func (e RunsOrderByDirection) IsValid() bool {
	switch e {
	case RunsOrderByDirectionAsc, RunsOrderByDirectionDesc:
		return true
	}
	return false
}

func (e RunsOrderByDirection) String() string {
	return string(e)
}

func (e *RunsOrderByDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RunsOrderByDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RunsOrderByDirection", str)
	}
	return nil
}

func (e RunsOrderByDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RunsV2OrderByField string

const (
	RunsV2OrderByFieldQueuedAt  RunsV2OrderByField = "QUEUED_AT"
	RunsV2OrderByFieldStartedAt RunsV2OrderByField = "STARTED_AT"
	RunsV2OrderByFieldEndedAt   RunsV2OrderByField = "ENDED_AT"
)

var AllRunsV2OrderByField = []RunsV2OrderByField{
	RunsV2OrderByFieldQueuedAt,
	RunsV2OrderByFieldStartedAt,
	RunsV2OrderByFieldEndedAt,
}

func (e RunsV2OrderByField) IsValid() bool {
	switch e {
	case RunsV2OrderByFieldQueuedAt, RunsV2OrderByFieldStartedAt, RunsV2OrderByFieldEndedAt:
		return true
	}
	return false
}

func (e RunsV2OrderByField) String() string {
	return string(e)
}

func (e *RunsV2OrderByField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RunsV2OrderByField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RunsV2OrderByField", str)
	}
	return nil
}

func (e RunsV2OrderByField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SingletonMode string

const (
	SingletonModeSkip   SingletonMode = "SKIP"
	SingletonModeCancel SingletonMode = "CANCEL"
)

var AllSingletonMode = []SingletonMode{
	SingletonModeSkip,
	SingletonModeCancel,
}

func (e SingletonMode) IsValid() bool {
	switch e {
	case SingletonModeSkip, SingletonModeCancel:
		return true
	}
	return false
}

func (e SingletonMode) String() string {
	return string(e)
}

func (e *SingletonMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SingletonMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SingletonMode", str)
	}
	return nil
}

func (e SingletonMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StepEventType string

const (
	StepEventTypeScheduled StepEventType = "SCHEDULED"
	StepEventTypeStarted   StepEventType = "STARTED"
	StepEventTypeCompleted StepEventType = "COMPLETED"
	StepEventTypeErrored   StepEventType = "ERRORED"
	StepEventTypeFailed    StepEventType = "FAILED"
	StepEventTypeWaiting   StepEventType = "WAITING"
)

var AllStepEventType = []StepEventType{
	StepEventTypeScheduled,
	StepEventTypeStarted,
	StepEventTypeCompleted,
	StepEventTypeErrored,
	StepEventTypeFailed,
	StepEventTypeWaiting,
}

func (e StepEventType) IsValid() bool {
	switch e {
	case StepEventTypeScheduled, StepEventTypeStarted, StepEventTypeCompleted, StepEventTypeErrored, StepEventTypeFailed, StepEventTypeWaiting:
		return true
	}
	return false
}

func (e StepEventType) String() string {
	return string(e)
}

func (e *StepEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StepEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StepEventType", str)
	}
	return nil
}

func (e StepEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StepOp string

const (
	StepOpInvoke        StepOp = "INVOKE"
	StepOpRun           StepOp = "RUN"
	StepOpSleep         StepOp = "SLEEP"
	StepOpWaitForEvent  StepOp = "WAIT_FOR_EVENT"
	StepOpAiGateway     StepOp = "AI_GATEWAY"
	StepOpWaitForSignal StepOp = "WAIT_FOR_SIGNAL"
)

var AllStepOp = []StepOp{
	StepOpInvoke,
	StepOpRun,
	StepOpSleep,
	StepOpWaitForEvent,
	StepOpAiGateway,
	StepOpWaitForSignal,
}

func (e StepOp) IsValid() bool {
	switch e {
	case StepOpInvoke, StepOpRun, StepOpSleep, StepOpWaitForEvent, StepOpAiGateway, StepOpWaitForSignal:
		return true
	}
	return false
}

func (e StepOp) String() string {
	return string(e)
}

func (e *StepOp) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StepOp(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StepOp", str)
	}
	return nil
}

func (e StepOp) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StreamType string

const (
	StreamTypeEvent StreamType = "EVENT"
	StreamTypeCron  StreamType = "CRON"
)

var AllStreamType = []StreamType{
	StreamTypeEvent,
	StreamTypeCron,
}

func (e StreamType) IsValid() bool {
	switch e {
	case StreamTypeEvent, StreamTypeCron:
		return true
	}
	return false
}

func (e StreamType) String() string {
	return string(e)
}

func (e *StreamType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamType", str)
	}
	return nil
}

func (e StreamType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

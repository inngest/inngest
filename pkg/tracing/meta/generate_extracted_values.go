//go:build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
)

func main() {
	// Parse the attributes.go file
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "attributes.go", nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	// Find the Attrs struct type
	var attrsStruct *ast.StructType
	ast.Inspect(file, func(n ast.Node) bool {
		if genDecl, ok := n.(*ast.GenDecl); ok && genDecl.Tok == token.VAR {
			for _, spec := range genDecl.Specs {
				if valueSpec, ok := spec.(*ast.ValueSpec); ok {
					for _, name := range valueSpec.Names {
						if name.Name == "Attrs" {
							// Look for composite literal with struct type
							if len(valueSpec.Values) > 0 {
								if compLit, ok := valueSpec.Values[0].(*ast.CompositeLit); ok {
									if structType, ok := compLit.Type.(*ast.StructType); ok {
										attrsStruct = structType
										return false
									}
								}
							}
						}
					}
				}
			}
		}
		return true
	})

	if attrsStruct == nil {
		panic("Could not find Attrs struct")
	}

	// Generate the ExtractedValues struct
	output := `// Code generated by generate_extracted_values.go; DO NOT EDIT.

package meta

import (
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/inngest/inngest/pkg/enums"
	"github.com/oklog/ulid/v2"
)

// ExtractedValues mirrors the Attrs struct but with actual pointer types
// instead of attr wrappers. This allows for type-safe access to deserialized values.
type ExtractedValues struct {
`

	// Extract field information
	for _, field := range attrsStruct.Fields.List {
		for _, name := range field.Names {
			fieldName := name.Name

			// Extract the type from Attr[T] to get T
			typeName := extractTypeFromAttr(field.Type)
			if typeName != "" {
				comment := ""
				if field.Comment != nil {
					comment = " " + strings.TrimSpace(field.Comment.Text())
				}
				output += fmt.Sprintf("\t%s %s%s\n", fieldName, typeName, comment)
			}
		}
	}

	output += "}\n"

	// Write the generated file
	err = os.WriteFile("extracted_values_gen.go", []byte(output), 0644)
	if err != nil {
		panic(err)
	}

	fmt.Println("Generated extracted_values_gen.go")
}

func extractTypeFromAttr(expr ast.Expr) string {
	// Handle Attr[T] where T is the type we want
	if indexExpr, ok := expr.(*ast.IndexExpr); ok {
		if ident, ok := indexExpr.X.(*ast.Ident); ok && ident.Name == "attr" {
			return exprToString(indexExpr.Index)
		}
	}
	return ""
}

func exprToString(expr ast.Expr) string {
	switch e := expr.(type) {
	case *ast.Ident:
		return e.Name
	case *ast.StarExpr:
		return "*" + exprToString(e.X)
	case *ast.SelectorExpr:
		return exprToString(e.X) + "." + e.Sel.Name
	case *ast.ArrayType:
		return "[]" + exprToString(e.Elt)
	case *ast.MapType:
		return "map[" + exprToString(e.Key) + "]" + exprToString(e.Value)
	case *ast.IndexExpr:
		return exprToString(e.X) + "[" + exprToString(e.Index) + "]"
	default:
		return fmt.Sprintf("%T", expr)
	}
}

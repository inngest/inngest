package tracing

import (
	"context"
	"encoding/json"

	"github.com/inngest/inngest/pkg/enums"
	"github.com/inngest/inngest/pkg/execution"
	"github.com/inngest/inngest/pkg/execution/queue"
	"github.com/inngest/inngest/pkg/execution/state"
	statev2 "github.com/inngest/inngest/pkg/execution/state/v2"
	"github.com/inngest/inngest/pkg/inngest"
	"github.com/inngest/inngest/pkg/tracing/meta"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/trace"
)

func WithFunctionAttrs(f *inngest.Function) trace.SpanStartEventOption {
	url, err := f.URI()
	if err != nil {
		return nil
	}

	return trace.WithAttributes(
		attribute.String(meta.AttributeRequestURL, url.String()),
	)
}

func WithResumeAttrs(p *state.Pause, r *execution.ResumeRequest) trace.SpanStartEventOption {
	attrs := []attribute.KeyValue{}

	if r != nil {
		if r.With != nil {
			if marshalledData, err := json.Marshal(r.With); err == nil {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepOutput, string(marshalledData)),
				)
			}
		}
	}

	if p != nil {
		if p.IsInvoke() {
			// TODO
		} else if p.IsWaitForEvent() {
			// TODO
		} else if p.IsSignal() {
			// TODO
		}
	}

	return trace.WithAttributes(attrs...)
}

// ApplyResponseToSpan applies details from the given `DriverResponse` to the
// given span. This is used for adding additional details to the span after the
// exectution has completed.
func WithDriverResponseAttrs(resp *state.DriverResponse) trace.SpanStartEventOption {
	attrs := []attribute.KeyValue{}

	if resp.IsDiscoveryResponse() {
		// We ignore discovery responses and rely on other spans to show steps
		// generated by handling opcodes later on.
		attrs = append(attrs, attribute.Bool(meta.AttributeDropSpan, true))
		// return trace.WithAttributes(attrs...)
	}

	headerByt, _ := json.Marshal(resp.Header)
	attrs = append(attrs,
		attribute.String(meta.AttributeResponseHeaders, string(headerByt)),
		attribute.Int(meta.AttributeResponseStatusCode, resp.StatusCode),
		attribute.Int(meta.AttributeResponseOutputSize, resp.OutputSize),
	)

	// If we have a single op to process, also add any generator data to the
	// span
	if op := resp.TraceVisibleStepExecution(); op != nil {
		attrs = append(attrs, withGeneratorAttrs(op)...)
	}

	return trace.WithAttributes(attrs...)
}

func WithGeneratorAttrs(op *state.GeneratorOpcode) trace.SpanStartEventOption {
	return trace.WithAttributes(withGeneratorAttrs(op)...)
}

func withGeneratorAttrs(op *state.GeneratorOpcode) []attribute.KeyValue {
	// Generic attributes for all steps
	attrs := []attribute.KeyValue{
		attribute.String(meta.AttributeStepID, op.ID),
		attribute.String(meta.AttributeStepOp, op.Op.String()),
		attribute.String(meta.AttributeStepName, op.UserDefinedName()),
	}

	// Try get stack line
	if stack, err := op.StackLine(); err == nil && stack != nil && *stack != "" {
		attrs = append(attrs,
			attribute.String(meta.AttributeCodeLocation, *stack),
		)
	}

	switch op.Op {
	case enums.OpcodeAIGateway:
		{
			// TODO
		}

	case enums.OpcodeGateway:
		{
			// TODO
		}

	case enums.OpcodeInvokeFunction:
		{
			if opts, err := op.InvokeFunctionOpts(); err == nil {
				attrs = append(attrs,
					// attribute.Int64(AttributeStepInvokeExpiry, opts.),
					attribute.String(meta.AttributeStepInvokeFunctionID, opts.FunctionID),
					attribute.String(meta.AttributeStepInvokeTriggerEventID, opts.Payload.ID),
				)

				if expiry, err := opts.Expires(); err == nil {
					attrs = append(attrs,
						attribute.Int64(meta.AttributeStepInvokeExpiry, expiry.UnixMilli()),
					)
				}
			}
		}

	case enums.OpcodeSleep:
		{
			if dur, err := op.SleepDuration(); err == nil {
				attrs = append(attrs,
					attribute.Int64(meta.AttributeStepSleepDuration, int64(dur)),
				)
			}
		}

	case enums.OpcodeStep, enums.OpcodeStepRun, enums.OpcodeStepError:
		{
			// Output (success or error)
			if output, err := op.Output(); err == nil {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepOutput, output),
				)
			}

			// Run type (sub-types of step.run)
			if typ := op.RunType(); typ != "" {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepRunType, typ),
				)
			}
		}

	case enums.OpcodeStepPlanned:
		{
			// TODO
		}

	case enums.OpcodeWaitForEvent:
		{
			if opts, err := op.WaitForEventOpts(); err == nil {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepWaitForEventName, opts.Event),
				)

				if expiry, err := opts.Expires(); err == nil {
					attrs = append(attrs,
						attribute.Int64(meta.AttributeStepWaitForEventExpiry, expiry.UnixMilli()),
					)
				}

				if opts.If != nil && *opts.If != "" {
					attrs = append(attrs,
						attribute.String(meta.AttributeStepWaitForEventIf, *opts.If),
					)
				}
			}
		}
	}

	return attrs
}

func SpanRefFromQueueItem(i *queue.Item) *meta.SpanReference {
	if i == nil || i.Metadata == nil {
		return nil
	}

	if carrier, ok := i.Metadata[meta.PropagationKey]; ok {
		var out meta.SpanReference
		if err := json.Unmarshal([]byte(carrier.(string)), &out); err == nil {
			return &out
		}
	}

	return nil
}

func SpanRefFromPause(p *state.Pause) *meta.SpanReference {
	if p == nil || p.Metadata == nil {
		return nil
	}

	if carrier, ok := p.Metadata[meta.PropagationKey]; ok {
		var out meta.SpanReference
		if err := json.Unmarshal([]byte(carrier.(string)), &out); err == nil {
			return &out
		}
	}

	return nil
}

// TODO Everywhere this is used, we're creating a step span directly under the
// run. When supporting userland spans anywhere, this method must be deprecated
// and all calls should instead use something that fetches which span (run or
// _userland_) this step should be under.
//
// A single exception is maybe the very first execution, but also with that we
// shoud have the run span inside the queue item's metadata.
func RunSpanRefFromMetadata(md *statev2.Metadata) *meta.SpanReference {
	if md == nil {
		return nil
	}

	return md.Config.NewFunctionTrace()
}

func spanContextFromMetadata(m *meta.SpanReference) trace.SpanContext {
	if m == nil {
		return trace.SpanContext{}
	}

	carrier := propagation.MapCarrier{
		"traceparent": m.TraceParent,
		"tracestate":  m.TraceState,
	}

	ctx := propagation.TraceContext{}.Extract(context.Background(), carrier)
	sc := trace.SpanContextFromContext(ctx)

	return sc
}

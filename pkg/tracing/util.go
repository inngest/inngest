package tracing

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/inngest/inngest/pkg/enums"
	"github.com/inngest/inngest/pkg/execution"
	"github.com/inngest/inngest/pkg/execution/queue"
	"github.com/inngest/inngest/pkg/execution/state"
	statev2 "github.com/inngest/inngest/pkg/execution/state/v2"
	"github.com/inngest/inngest/pkg/inngest"
	"github.com/inngest/inngest/pkg/tracing/meta"
	"github.com/inngest/inngest/pkg/util"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/trace"
)

func WithFunctionAttrs(f *inngest.Function) trace.SpanStartEventOption {
	url, err := f.URI()
	if err != nil {
		return trace.WithAttributes(
			attribute.String(meta.InternalError, fmt.Errorf("failed to get function URI: %w", err).Error()),
		)
	}

	return trace.WithAttributes(
		attribute.String(meta.AttributeRequestURL, url.String()),
	)
}

func WithResumeAttrs(p *state.Pause, r *execution.ResumeRequest) trace.SpanStartEventOption {
	attrs := []attribute.KeyValue{}
	es := util.NewErrSet()
	status := enums.StepStatusCompleted

	if p != nil {
		attrs = append(attrs,
			attribute.String(meta.AttributeRunID, p.Identifier.RunID.String()),
		)
	}

	if r != nil {
		attrs = append(attrs,
			attribute.Bool(meta.AttributeStepWaitExpired, r.IsTimeout),
		)

		if r.With != nil {
			if marshalledData, err := json.Marshal(r.With); err == nil {
				// TODO For waitForEvent, this is not the entire event, as
				// it's not coming back keyed. We can account for this here.
				attrs = append(attrs,
					attribute.String(meta.AttributeStepOutput, string(marshalledData)),
				)
			} else {
				es.Add(fmt.Errorf("failed to marshal resume data: %w", err))
			}
		}

		if r.HasError() {
			status = enums.StepStatusErrored
		}

		if p != nil {
			if p.IsInvoke() {
				if r.EventID != nil {
					attrs = append(attrs,
						attribute.String(meta.AttributeStepInvokeFinishEventID, r.EventID.String()),
					)
				}

				if r.RunID != nil {
					attrs = append(attrs,
						attribute.String(meta.AttributeStepInvokeRunID, r.RunID.String()),
					)
				}

			} else if p.IsWaitForEvent() {
				if r.EventID != nil {
					attrs = append(attrs,
						attribute.String(meta.AttributeStepWaitForEventMatchedID, r.EventID.String()),
					)
				}

			}
		}
	}

	attrs = append(attrs,
		attribute.String(meta.AttributeDynamicStatus, status.String()),
	)

	if es.HasErrors() {
		attrs = append(attrs,
			attribute.String(meta.InternalError, es.Err().Error()),
		)
	}

	return trace.WithAttributes(attrs...)
}

// ApplyResponseToSpan applies details from the given `DriverResponse` to the
// given span. This is used for adding additional details to the span after the
// exectution has completed.
func WithDriverResponseAttrs(
	resp *state.DriverResponse,

	// This is the span reference for the span that output is saved against. If
	// this is present, we should reference this span when setting output
	// instead of persisting it again here.
	outputSpanRef *meta.SpanReference,
) trace.SpanStartEventOption {
	attrs := []attribute.KeyValue{}
	es := util.NewErrSet()

	if resp.IsDiscoveryResponse() {
		// We ignore discovery responses and rely on other spans to show steps
		// generated by handling opcodes later on.
		//
		// Note that we also do not return early here; even though we're
		// intending to drop this span when viewing, it's still useful for it
		// to collect as much data as it can.
		attrs = append(attrs, attribute.Bool(meta.AttributeDropSpan, true))
	}

	fnOutput, err := resp.GetFunctionOutput()
	if err != nil {
		es.Add(fmt.Errorf("failed to get function output: %w", err))
	} else if fnOutput != nil {
		if outputSpanRef != nil {
			if outputSpanRef.DynamicSpanID == "" {
				es.Add(fmt.Errorf("output span reference is missing dynamic span ID"))
			} else {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepOutputRef, outputSpanRef.DynamicSpanID),
				)
			}
		} else {
			attrs = append(attrs,
				attribute.String(meta.AttributeStepOutput, *fnOutput),
			)
		}
	}

	headerByt, _ := json.Marshal(resp.Header)
	attrs = append(attrs,
		attribute.String(meta.AttributeResponseHeaders, string(headerByt)),
		attribute.Int(meta.AttributeResponseStatusCode, resp.StatusCode),
		attribute.Int(meta.AttributeResponseOutputSize, resp.OutputSize),
	)

	// If we have a single op to process, also add any generator data to the
	// span
	if op := resp.TraceVisibleStepExecution(); op != nil {
		attrs = append(attrs, withGeneratorAttrs(op)...)
	}

	if es.HasErrors() {
		attrs = append(attrs,
			attribute.String(meta.InternalError, es.Err().Error()),
		)
	}

	return trace.WithAttributes(attrs...)
}

func WithGeneratorAttrs(op *state.GeneratorOpcode) trace.SpanStartEventOption {
	return trace.WithAttributes(withGeneratorAttrs(op)...)
}

func withGeneratorAttrs(op *state.GeneratorOpcode) []attribute.KeyValue {
	// Generic attributes for all steps
	attrs := []attribute.KeyValue{
		attribute.String(meta.AttributeStepID, op.ID),
		attribute.String(meta.AttributeStepOp, op.Op.String()),
		attribute.String(meta.AttributeStepName, op.UserDefinedName()),
	}
	es := util.NewErrSet()

	// Try get stack line
	if stack, err := op.StackLine(); err == nil && stack != nil && *stack != "" {
		attrs = append(attrs,
			attribute.String(meta.AttributeCodeLocation, *stack),
		)
	}

	switch op.Op {
	case enums.OpcodeAIGateway:
		{
			// TODO
		}

	case enums.OpcodeGateway:
		{
			// TODO
		}

	case enums.OpcodeInvokeFunction:
		{
			if opts, err := op.InvokeFunctionOpts(); err == nil {
				attrs = append(attrs,
					// attribute.Int64(AttributeStepInvokeExpiry, opts.),
					attribute.String(meta.AttributeStepInvokeFunctionID, opts.FunctionID),
					attribute.String(meta.AttributeStepInvokeTriggerEventID, opts.Payload.ID),
				)

				if expiry, err := opts.Expires(); err == nil {
					attrs = append(attrs,
						attribute.Int64(meta.AttributeStepWaitExpiry, expiry.UnixMilli()),
					)
				}
			} else {
				es.Add(fmt.Errorf("failed to get invoke function opts: %w", err))
			}
		}

	case enums.OpcodeSleep:
		{
			if dur, err := op.SleepDuration(); err == nil {
				attrs = append(attrs,
					attribute.Int64(meta.AttributeStepSleepDuration, dur.Milliseconds()),
				)
			} else {
				es.Add(fmt.Errorf("failed to get sleep duration: %w", err))
			}
		}

	case enums.OpcodeStep, enums.OpcodeStepRun, enums.OpcodeStepError:
		{
			// Output (success or error)
			if output, err := op.Output(); err == nil {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepOutput, output),
				)
			} else {
				es.Add(fmt.Errorf("failed to get step output: %w", err))
			}

			// Run type (sub-types of step.run)
			if typ := op.RunType(); typ != "" {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepRunType, typ),
				)
			}

			// Set status if we've encountered an error
			if op.Error != nil {
				attrs = append(attrs,
					attribute.String(meta.AttributeDynamicStatus, enums.StepStatusErrored.String()))
			}
		}

	case enums.OpcodeStepPlanned:
		{
			// Nothing yet (there are defaults above)
		}

	case enums.OpcodeWaitForEvent:
		{
			if opts, err := op.WaitForEventOpts(); err == nil {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepWaitForEventName, opts.Event),
				)

				if expiry, err := opts.Expires(); err == nil {
					attrs = append(attrs,
						attribute.Int64(meta.AttributeStepWaitExpiry, expiry.UnixMilli()),
					)
				} else {
					es.Add(fmt.Errorf("failed to get wait for event expiry: %w", err))

				}

				if opts.If != nil && *opts.If != "" {
					attrs = append(attrs,
						attribute.String(meta.AttributeStepWaitForEventIf, *opts.If),
					)
				}
			} else {
				es.Add(fmt.Errorf("failed to get wait for event opts: %w", err))
			}
		}
	case enums.OpcodeWaitForSignal:
		{
			if opts, err := op.SignalOpts(); err == nil {
				attrs = append(attrs,
					attribute.String(meta.AttributeStepSignalName, opts.Signal),
				)

				if expiry, err := opts.Expires(); err == nil {
					attrs = append(attrs,
						attribute.Int64(meta.AttributeStepWaitExpiry, expiry.UnixMilli()),
					)
				} else {
					es.Add(fmt.Errorf("failed to get wait for signal expiry: %w", err))
				}
			} else {
				es.Add(fmt.Errorf("failed to get wait for signal opts: %w", err))
			}
		}
	}

	if es.HasErrors() {
		attrs = append(attrs,
			attribute.String(meta.InternalError, es.Err().Error()),
		)
	}

	return attrs
}

func WithGatewayResponseAttrs(resp *http.Response, userErr *state.UserError) trace.SpanStartEventOption {
	attrs := []attribute.KeyValue{}
	es := util.NewErrSet()

	if resp != nil {
		attrs = append(attrs,
			attribute.Int(meta.AttributeStepGatewayResponseStatusCode, resp.StatusCode),
			attribute.Int(meta.AttributeStepGatewayResponseOutputSizeBytes, int(resp.ContentLength)),
		)
	}

	if userErr != nil {
		attrs = append(attrs,
			attribute.String(meta.AttributeDynamicStatus, enums.StepStatusErrored.String()),
		)

		if userErrByt, err := json.Marshal(userErr); err == nil {
			attrs = append(attrs,
				attribute.String(meta.AttributeStepOutput, string(userErrByt)),
			)
		} else {
			es.Add(fmt.Errorf("failed to marshal user error: %w", err))
		}
	} else {
		attrs = append(attrs,
			attribute.String(meta.AttributeDynamicStatus, enums.StepStatusCompleted.String()),
		)
	}

	if es.HasErrors() {
		attrs = append(attrs,

			attribute.String(meta.InternalError, es.Err().Error()),
		)
	}

	return trace.WithAttributes(attrs...)
}

func SpanRefFromQueueItem(i *queue.Item) *meta.SpanReference {
	if i == nil || i.Metadata == nil {
		return nil
	}

	if carrier, ok := i.Metadata[meta.PropagationKey]; ok {
		var out meta.SpanReference
		if err := json.Unmarshal([]byte(carrier.(string)), &out); err == nil {
			return &out
		}
	}

	return nil
}

func SpanRefFromPause(p *state.Pause) *meta.SpanReference {
	if p == nil || p.Metadata == nil {
		return nil
	}

	if carrier, ok := p.Metadata[meta.PropagationKey]; ok {
		var out meta.SpanReference
		if err := json.Unmarshal([]byte(carrier.(string)), &out); err == nil {
			return &out
		}
	}

	return nil
}

// TODO Everywhere this is used, we're creating a step span directly under the
// run. When supporting userland spans anywhere, this method must be deprecated
// and all calls should instead use something that fetches which span (run or
// _userland_) this step should be under.
//
// A single exception is maybe the very first execution, but also with that we
// shoud have the run span inside the queue item's metadata.
func RunSpanRefFromMetadata(md *statev2.Metadata) *meta.SpanReference {
	if md == nil {
		return nil
	}

	return md.Config.NewFunctionTrace()
}

func spanContextFromMetadata(m *meta.SpanReference) trace.SpanContext {
	if m == nil {
		return trace.SpanContext{}
	}

	carrier := propagation.MapCarrier{
		"traceparent": m.TraceParent,
		"tracestate":  m.TraceState,
	}

	ctx := propagation.TraceContext{}.Extract(context.Background(), carrier)
	sc := trace.SpanContextFromContext(ctx)

	return sc
}

package tracing

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"
	"time"

	"github.com/inngest/inngest/pkg/enums"
	"github.com/inngest/inngest/pkg/execution"
	"github.com/inngest/inngest/pkg/execution/exechttp"
	"github.com/inngest/inngest/pkg/execution/queue"
	"github.com/inngest/inngest/pkg/execution/state"
	statev2 "github.com/inngest/inngest/pkg/execution/state/v2"
	"github.com/inngest/inngest/pkg/inngest"
	"github.com/inngest/inngest/pkg/tracing/meta"
	"github.com/inngest/inngest/pkg/util/aigateway"
	"github.com/oklog/ulid/v2"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/trace"
)

func FunctionAttrs(f *inngest.Function) *meta.SerializableAttrs {
	rawAttrs := meta.NewAttrSet()

	urlString := f.URI().String()
	meta.AddAttr(rawAttrs, meta.Attrs.RequestURL, &urlString)

	return rawAttrs
}

func ResumeAttrs(p *state.Pause, r *execution.ResumeRequest) *meta.SerializableAttrs {
	rawAttrs := meta.NewAttrSet()
	status := enums.StepStatusCompleted

	if p != nil {
		meta.AddAttr(rawAttrs, meta.Attrs.RunID, &p.Identifier.RunID)
	}

	if r != nil {
		meta.AddAttr(rawAttrs, meta.Attrs.StepWaitExpired, &r.IsTimeout)

		if r.With != nil {
			if marshalledData, err := json.Marshal(r.With); err == nil {
				// TODO For waitForEvent, this is not the entire event, as
				// it's not coming back keyed. We can account for this here.
				marshalledDataString := string(marshalledData)
				meta.AddAttr(rawAttrs, meta.Attrs.StepOutput, &marshalledDataString)
			} else {
				rawAttrs.AddErr(fmt.Errorf("failed to marshal resume data: %w", err))
			}
		}

		if r.HasError() {
			status = enums.StepStatusErrored
		}

		if p != nil {
			if p.IsInvoke() {
				meta.AddAttr(rawAttrs, meta.Attrs.StepInvokeFinishEventID, r.EventID)
				meta.AddAttr(rawAttrs, meta.Attrs.StepInvokeRunID, r.RunID)
			} else if p.IsWaitForEvent() {
				meta.AddAttr(rawAttrs, meta.Attrs.StepWaitForEventMatchedID, r.EventID)
			}
		}
	}

	meta.AddAttr(rawAttrs, meta.Attrs.DynamicStatus, &status)

	return rawAttrs
}

// ApplyResponseToSpan applies details from the given `DriverResponse` to the
// given span. This is used for adding additional details to the span after the
// exectution has completed.
func DriverResponseAttrs(
	resp *state.DriverResponse,

	// This is the span reference for the span that output is saved against. If
	// this is present, we should reference this span when setting output
	// instead of persisting it again here.
	outputSpanRef *meta.SpanReference,
) *meta.SerializableAttrs {
	rawAttrs := meta.NewAttrSet()

	if resp.IsDiscoveryResponse() && !resp.IsGatewayRequest() {
		// We ignore discovery responses and rely on other spans to show steps
		// generated by handling opcodes later on.
		//
		// An exception to this is gateway requests. These are processed
		// during the handling of a response from the SDK, so these must also
		// not be dropped so we can display that process to the user and
		// include the handling of the response in the span they see.
		//
		// Note that we also do not return early here; even though we're
		// intending to drop this span when viewing, it's still useful for it
		// to collect as much data as it can.
		dropSpan := true
		meta.AddAttr(rawAttrs, meta.Attrs.DropSpan, &dropSpan)
	}

	fnOutput, err := resp.GetFunctionOutput()
	if err != nil {
		rawAttrs.AddErr(fmt.Errorf("failed to get function output: %w", err))
	} else if fnOutput != nil {
		isFunctionOutput := true
		meta.AddAttr(rawAttrs, meta.Attrs.IsFunctionOutput, &isFunctionOutput)

		if outputSpanRef != nil {
			if outputSpanRef.DynamicSpanID == "" {
				rawAttrs.AddErr(fmt.Errorf("output span reference is missing dynamic span ID"))
			} else {
				meta.AddAttr(rawAttrs, meta.Attrs.StepOutputRef, &outputSpanRef.DynamicSpanID)
			}
		} else {
			meta.AddAttr(rawAttrs, meta.Attrs.StepOutput, fnOutput)
		}
	}

	size := resp.OutputSize
	if size == 0 && fnOutput != nil {
		size = len(*fnOutput)
	}

	meta.AddAttr(rawAttrs, meta.Attrs.ResponseHeaders, &resp.Header)
	meta.AddAttr(rawAttrs, meta.Attrs.ResponseStatusCode, &resp.StatusCode)
	meta.AddAttr(rawAttrs, meta.Attrs.ResponseOutputSize, &size)

	// If we have a single op to process, also add any generator data to the
	// span and overwrite any clashes
	if op := resp.TraceVisibleStepExecution(); op != nil {
		rawAttrs = rawAttrs.Merge(GeneratorAttrs(op))
	}

	return rawAttrs
}

func GeneratorAttrs(op *state.GeneratorOpcode) *meta.SerializableAttrs {
	return generatorAttrs(op)
}

func generatorAttrs(op *state.GeneratorOpcode) *meta.SerializableAttrs {
	// Generic attributes for all steps
	stepName := op.UserDefinedName()
	rawAttrs := meta.NewAttrSet(
		meta.Attr(meta.Attrs.StepID, &op.ID),
		meta.Attr(meta.Attrs.StepOp, &op.Op),
		meta.Attr(meta.Attrs.StepName, &stepName),
	)

	// Try get stack line
	if stack, err := op.StackLine(); err == nil && stack != nil && *stack != "" {
		meta.AddAttr(rawAttrs, meta.Attrs.StepCodeLocation, stack)
	}

	// Always try to capture input
	if input, err := op.Input(); err == nil {
		meta.AddAttrIfUnset(rawAttrs, meta.Attrs.StepInput, &input)
	} else {
		rawAttrs.AddErr(fmt.Errorf("failed to get step input: %w", err))
	}

	if op.Userland != nil {
		meta.AddAttr(rawAttrs, meta.Attrs.StepUserlandID, &op.Userland.ID)
		meta.AddAttr(rawAttrs, meta.Attrs.StepUserlandIndex, &op.Userland.Index)
	}

	switch op.Op {
	case enums.OpcodeAIGateway:
		{
			if req, err := op.AIGatewayOpts(); err == nil {
				if parsed, err := aigateway.ParseInput(req); err == nil {
					meta.AddAttr(rawAttrs, meta.Attrs.AIRequestMetadata, &parsed)
				} else {
					rawAttrs.AddErr(fmt.Errorf("failed to parse AI gateway input: %w", err))
				}
			}
		}

	case enums.OpcodeGateway:
		{
			// TODO
		}

	case enums.OpcodeInvokeFunction:
		{
			if opts, err := op.InvokeFunctionOpts(); err == nil {
				meta.AddAttr(rawAttrs, meta.Attrs.StepInvokeFunctionID, &opts.FunctionID)

				if id, err := ulid.Parse(opts.Payload.ID); err == nil {
					meta.AddAttr(rawAttrs, meta.Attrs.StepInvokeTriggerEventID, &id)
				} else {
					rawAttrs.AddErr(fmt.Errorf("failed to parse invoke trigger event ID: %w", err))
				}

				if expiry, err := opts.Expires(); err == nil {
					meta.AddAttr(rawAttrs, meta.Attrs.StepWaitExpiry, &expiry)
				}
			} else {
				rawAttrs.AddErr(fmt.Errorf("failed to get invoke function opts: %w", err))
			}
		}

	case enums.OpcodeSleep:
		{
			if dur, err := op.SleepDuration(); err == nil {
				meta.AddAttr(rawAttrs, meta.Attrs.StepSleepDuration, &dur)
			} else {
				rawAttrs.AddErr(fmt.Errorf("failed to get sleep duration: %w", err))
			}
		}

	case enums.OpcodeStep, enums.OpcodeStepRun, enums.OpcodeStepError, enums.OpcodeStepFailed:
		{
			// Output (success or error)
			if output, err := op.Output(); err == nil {
				meta.AddAttr(rawAttrs, meta.Attrs.StepOutput, &output)
			} else {
				rawAttrs.AddErr(fmt.Errorf("failed to get step output: %w", err))
			}

			// Run type (sub-types of step.run)
			if typ := op.RunType(); typ != "" {
				meta.AddAttr(rawAttrs, meta.Attrs.StepRunType, &typ)
			}

			// Set status if we've encountered an error
			if op.Error != nil {
				status := enums.StepStatusErrored
				meta.AddAttr(rawAttrs, meta.Attrs.DynamicStatus, &status)
			}
		}

	case enums.OpcodeStepPlanned:
		{
			// Nothing yet (there are defaults above)
		}

	case enums.OpcodeWaitForEvent:
		{
			if opts, err := op.WaitForEventOpts(); err == nil {
				meta.AddAttr(rawAttrs, meta.Attrs.StepWaitForEventName, &opts.Event)

				if expiry, err := opts.Expires(); err == nil {
					meta.AddAttr(rawAttrs, meta.Attrs.StepWaitExpiry, &expiry)
				} else {
					rawAttrs.AddErr(fmt.Errorf("failed to get wait for event expiry: %w", err))
				}

				if opts.If != nil && *opts.If != "" {
					meta.AddAttr(rawAttrs, meta.Attrs.StepWaitForEventIf, opts.If)
				}
			} else {
				rawAttrs.AddErr(fmt.Errorf("failed to get wait for event opts: %w", err))
			}
		}
	case enums.OpcodeWaitForSignal:
		{
			if opts, err := op.SignalOpts(); err == nil {
				meta.AddAttr(rawAttrs, meta.Attrs.StepSignalName, &opts.Signal)

				if expiry, err := opts.Expires(); err == nil {
					meta.AddAttr(rawAttrs, meta.Attrs.StepWaitExpiry, &expiry)
				} else {
					rawAttrs.AddErr(fmt.Errorf("failed to get wait for signal expiry: %w", err))
				}
			} else {
				rawAttrs.AddErr(fmt.Errorf("failed to get wait for signal opts: %w", err))
			}
		}
	}

	return rawAttrs
}

func GatewayResponseAttrs(resp *exechttp.Response, userErr *state.UserError, op state.GeneratorOpcode, rawAiResponseBody []byte) *meta.SerializableAttrs {
	now := time.Now()

	rawAttrs := meta.NewAttrSet(
		meta.Attr(meta.Attrs.EndedAt, &now),
	)

	if resp != nil {
		meta.AddAttr(rawAttrs, meta.Attrs.StepGatewayResponseStatusCode, &resp.StatusCode)

		contentLengthStr := resp.Header.Get("Content-Length")
		if contentLengthStr != "" {
			if parsed, err := strconv.ParseInt(contentLengthStr, 10, 64); err == nil {
				parsedInt := int(parsed)
				meta.AddAttr(rawAttrs, meta.Attrs.StepGatewayResponseOutputSizeBytes, &parsedInt)
			} else {
				rawAttrs.AddErr(fmt.Errorf("failed to parse gateway response content length: %w", err))
			}
		}
	}

	if userErr != nil {
		status := enums.StepStatusErrored
		meta.AddAttr(rawAttrs, meta.Attrs.DynamicStatus, &status)

		if userErrByt, err := json.Marshal(userErr); err == nil {
			output := string(userErrByt)
			meta.AddAttr(rawAttrs, meta.Attrs.StepOutput, &output)
		} else {
			rawAttrs.AddErr(fmt.Errorf("failed to marshal user error: %w", err))
		}
	} else {
		status := enums.StepStatusCompleted
		meta.AddAttr(rawAttrs, meta.Attrs.DynamicStatus, &status)

		// Always try capture output
		output, err := op.Output()
		if err == nil {
			meta.AddAttr(rawAttrs, meta.Attrs.StepOutput, &output)
		} else {
			rawAttrs.AddErr(fmt.Errorf("failed to get step output in gateway response attrs: %w", err))
		}
	}

	if op.Op == enums.OpcodeAIGateway && rawAiResponseBody != nil {
		if req, err := op.AIGatewayOpts(); err == nil {
			if parsed, err := aigateway.ParseOutput(req.Format, rawAiResponseBody); err == nil {
				meta.AddAttr(rawAttrs, meta.Attrs.AIResponseMetadata, &parsed)
			} else {
				rawAttrs.AddErr(fmt.Errorf("failed to parse AI gateway output: %w", err))
			}
		} else {
			rawAttrs.AddErr(fmt.Errorf("failed to get AI gateway opts: %w", err))
		}
	}

	return rawAttrs
}

func SpanRefFromQueueItem(i *queue.Item) *meta.SpanReference {
	if i == nil || i.Metadata == nil {
		return nil
	}

	if carrier, ok := i.Metadata[meta.PropagationKey]; ok {
		var out meta.SpanReference
		if err := json.Unmarshal([]byte(carrier.(string)), &out); err == nil {
			return &out
		}
	}

	return nil
}

func SpanRefFromPause(p *state.Pause) *meta.SpanReference {
	if p == nil || p.Metadata == nil {
		return nil
	}

	if carrier, ok := p.Metadata[meta.PropagationKey]; ok {
		var out meta.SpanReference
		if err := json.Unmarshal([]byte(carrier.(string)), &out); err == nil {
			return &out
		}
	}

	return nil
}

// TODO Everywhere this is used, we're creating a step span directly under the
// run. When supporting userland spans anywhere, this method must be deprecated
// and all calls should instead use something that fetches which span (run or
// _userland_) this step should be under.
//
// A single exception is maybe the very first execution, but also with that we
// shoud have the run span inside the queue item's metadata.
func RunSpanRefFromMetadata(md *statev2.Metadata) *meta.SpanReference {
	if md == nil {
		return nil
	}

	return md.Config.NewFunctionTrace()
}

func spanContextFromMetadata(m *meta.SpanReference) trace.SpanContext {
	if m == nil {
		return trace.SpanContext{}
	}

	carrier := propagation.MapCarrier{
		"traceparent": m.TraceParent,
		"tracestate":  m.TraceState,
	}

	ctx := propagation.TraceContext{}.Extract(context.Background(), carrier)
	sc := trace.SpanContextFromContext(ctx)

	return sc
}

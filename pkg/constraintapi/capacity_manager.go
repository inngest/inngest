package constraintapi

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/inngest/inngest/pkg/util/errs"
	"github.com/oklog/ulid/v2"
)

type CapacityManager interface {
	Check(ctx context.Context, req *CapacityCheckRequest) (*CapacityCheckResponse, errs.UserError, errs.InternalError)
	Acquire(ctx context.Context, req *CapacityAcquireRequest) (*CapacityAcquireResponse, errs.InternalError)
	ExtendLease(ctx context.Context, req *CapacityExtendLeaseRequest) (*CapacityExtendLeaseResponse, errs.InternalError)
	Release(ctx context.Context, req *CapacityReleaseRequest) (*CapacityReleaseResponse, errs.InternalError)
}

type CapacityCheckRequest struct {
	AccountID uuid.UUID

	// EnvID is used for identifying the function.
	EnvID uuid.UUID

	// FunctionID is used for identifying the function.
	FunctionID uuid.UUID

	// Configuration represents the latest known constraint configuration (a subset of the function config).
	//
	// The server _may_ reject calls if it has recently seen a newer configuration. This is expected for a short
	// period after updating the configuration (as executors independently refresh the in-memory cache), but old
	// configurations should not be used for an extended time.
	Configuration ConstraintConfig

	// Constraints describes the constraints that should be checked for a request.
	//
	// This should include _all_ constraints that need to be checked to perform an operation.
	//
	// For example:
	// - To process a queue item, we need to check account, function, and optionally custom concurrency. If throttle is set,
	//   the request should also include throttle capacity.
	//
	// This design assumes that the other side _knows_ the current constraint.
	Constraints []ConstraintItem
}

type CapacityCheckResponse struct {
	// AvailableCapacity for given constraints and configuration
	AvailableCapacity int

	// LimitingConstraints contains constraints that
	// ended up reducing the number of leases from the expected Amount.
	LimitingConstraints []ConstraintItem

	// Detailed constraint usage for requested constraints
	Usage []ConstraintUsage
}

type CapacityAcquireRequest struct {
	// IdempotencyKey prevents performing the same lease request multiple times.
	IdempotencyKey string

	AccountID uuid.UUID

	// EnvID is used for identifying the function.
	EnvID uuid.UUID

	// FunctionID is used for identifying the function.
	FunctionID uuid.UUID

	// Configuration represents the latest known constraint configuration (a subset of the function config).
	//
	// The server _may_ reject calls if it has recently seen a newer configuration. This is expected for a short
	// period after updating the configuration (as executors independently refresh the in-memory cache), but old
	// configurations should not be used for an extended time.
	Configuration ConstraintConfig

	// Constraints describes the constraints that should be checked for a request.
	//
	// This should include _all_ constraints that need to be checked to perform an operation.
	//
	// For example:
	// - To process a queue item, we need to check account, function, and optionally custom concurrency. If throttle is set,
	//   the request should also include throttle capacity.
	//
	// This design assumes that the other side _knows_ the current constraint.
	Constraints []ConstraintItem

	// Amount specifies upper bound of requested capacity
	//
	// The Constraint API will check the provided constraints and calculate the
	// allowed capacity. This determines the number of created leases.
	Amount int

	// LeaseIdempotencyKeys represent individual idempotency keys to be used in case multiple leases are generated by the Acquire
	// request.
	//
	// This is useful to check the validity of individual leases using another Acquire call, as well as guaranteeing idempotency
	// in case the original lease expired by the time the respective item starts processing.
	LeaseIdempotencyKeys []string

	// ResourceKind specifies the resource kind associated with the lease.
	//
	// For run scheduling, this will be an event.
	// For queue constraints, this will be one or more queue items.
	ResourceKind LeaseResourceKind

	// CurrentTime specifies the current time on the calling side. If this drifts too far from the manager, the request will be
	// rejected. For generating the lease expiry, we will use the current time on the manager side.
	//
	// This is a cheap check to prevent clock skew. We instrument the skew and will set a reasonable threshold over time.
	CurrentTime time.Time

	// Duration specifies the lease duration. This may be capped by the manager.
	Duration time.Duration

	// MaximumLifetime specifies the maximum lifetime for a lease.
	// If the caller attempts to extend a lease past this duration, the request will be rejected.
	MaximumLifetime time.Duration

	// BlockingThreshold optionally allows the server to hold the request up to the specific Duration
	// in case capacity is likely to be available within the duration.
	//
	// Setting this may reduce roundtrip-time.
	BlockingThreshold time.Duration

	// Source includes information on the calling service and processing mode for instrumentation purposes and to enforce fairness/avoid starvation.
	Source LeaseSource
}

// CapacityLease represents the tuple of LeaseID <-> IdempotencyKey which identifies the leased resource (event, queue item, etc.).
type CapacityLease struct {
	// LeaseID is set to the time of lease expiry and will change when extended.
	LeaseID ulid.ULID

	// IdempotencyKey represents the resource associated with the lease, e.g. a queue item or event.
	IdempotencyKey string
}

type CapacityAcquireResponse struct {
	// Leases may contain anywhere between 0 and <Amount> IDs.
	//
	// Each lease will be identified by its idempotency key (set in LeaseIdempotencyKeys).
	//
	// Depending on the available constraint capacity, there may be
	// fewer leases than requested.
	Leases []CapacityLease

	// LimitingConstraints contains constraints that
	// ended up reducing the number of leases from the expected Amount.
	LimitingConstraints []ConstraintItem

	RetryAfter time.Time
}

type CapacityExtendLeaseRequest struct {
	IdempotencyKey string

	AccountID uuid.UUID
	LeaseID   ulid.ULID

	Duration time.Duration
}

type CapacityExtendLeaseResponse struct {
	LeaseID *ulid.ULID
}

type CapacityReleaseRequest struct {
	IdempotencyKey string

	AccountID uuid.UUID
	LeaseID   ulid.ULID
}

type CapacityReleaseResponse struct{}

type RunProcessingMode int

const (
	// RunProcessingModeBackground is used for regular (async) run scheduling and execution.
	RunProcessingModeBackground RunProcessingMode = iota
	// RunProcessingModeSync is used for requests sent by the Checkpointing API/Project Zero.
	RunProcessingModeSync
)

// LeaseResourceKind specifies the resource associated with the capacity lease.
//
// For run scheduling, this is usually an event.
// For queue constraints, this is one or more queue items.
type LeaseResourceKind int

const (
	LeaseResourceUnknown LeaseResourceKind = iota
	LeaseResourceEvent
	LeaseResourceQueueItem
)

type LeaseLocation int

const (
	LeaseLocationUnknown LeaseLocation = iota

	// LeaseLocationScheduleRun is hit before scheduling a run
	LeaseLocationScheduleRun

	// LeaseLocationPartitionLease is hit before leasing a partition
	LeaseLocationPartitionLease

	// LeaseLocationItemLease is hit before leasing a queue item
	LeaseLocationItemLease

	LeaseLocationCheckpoint
)

type LeaseService int

const (
	ServiceUnknown LeaseService = iota
	ServiceNewRuns
	ServiceExecutor
	ServiceAPI
)

type LeaseSource struct {
	// Service refers to the origin service (new-runs, api, executor)
	Service LeaseService

	// Location refers to the lifecycle step requiring constraint checks
	Location LeaseLocation

	RunProcessingMode RunProcessingMode
}

type UseConstraintAPIFn func(ctx context.Context, accountID uuid.UUID) (enable bool, fallback bool)

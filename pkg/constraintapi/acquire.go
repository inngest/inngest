package constraintapi

import (
	"context"
	"crypto/rand"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/inngest/inngest/pkg/logger"
	"github.com/inngest/inngest/pkg/util"
	"github.com/inngest/inngest/pkg/util/errs"
	"github.com/oklog/ulid/v2"
)

// redisRequestState represents the data structure stored for every request
// This is used by subsequent calls to Extend, Release to properly handle the lease lifecycle
//
// NOTE: This does not represent one individual lease but is used by
// all leases generated in the Acquire call.
type redisRequestState struct {
	OperationIdempotencyKey string    `json:"k,omitempty"`
	EnvID                   uuid.UUID `json:"e,omitempty"`
	FunctionID              uuid.UUID `json:"f,omitempty"`

	// SortedConstraints represents the list of constraints
	// included in the request sorted to execute in the expected
	// order. Configuration limits are now embedded directly in each constraint.
	SortedConstraints []SerializedConstraintItem `json:"s"`

	// ConfigVersion represents the function version used for this request
	ConfigVersion int `json:"cv,omitempty"`

	// RequestedAmount represents the Amount field in the Acquire request
	RequestedAmount int `json:"r,omitempty"`

	// GrantedAmount is populated in Lua during Acquire and represents the actual capacity granted to the request (how many leases were generated)
	GrantedAmount int `json:"g,omitempty"`

	// ActiveAmount represents the total number of active leases (where Release was not yet called)
	ActiveAmount int `json:"a,omitempty"`

	// MaximumLifetime is optional and represenst the maximum lifetime for leases generated by this request.
	// This is enforced during ExtendLease.
	MaximumLifetimeMillis int64 `json:"l,omitempty"`

	// LeaseIdempotencyKeys stores the idempotency used to generate leases
	LeaseIdempotencyKeys []string `json:"lik,omitempty"`

	// LeaseRunIDs stores the run IDs associated with lease IDs
	LeaseRunIDs map[string]ulid.ULID `json:"lri,omitempty"`
}

func buildRequestState(req *CapacityAcquireRequest, keyPrefix string) (*redisRequestState, []ConstraintItem) {
	state := &redisRequestState{
		OperationIdempotencyKey: req.IdempotencyKey,
		EnvID:                   req.EnvID,
		FunctionID:              req.FunctionID,
		RequestedAmount:         req.Amount,
		MaximumLifetimeMillis:   req.MaximumLifetime.Milliseconds(),
		ConfigVersion:           req.Configuration.FunctionVersion,

		LeaseRunIDs:          req.LeaseRunIDs,
		LeaseIdempotencyKeys: req.LeaseIdempotencyKeys,

		// These keys are set during Acquire and Release respectively
		GrantedAmount: 0,
		ActiveAmount:  0,
	}

	// Sort and serialize constraints with embedded configuration limits
	constraints := req.Constraints
	sortConstraints(constraints)

	serialized := make([]SerializedConstraintItem, len(constraints))
	for i := range constraints {
		serialized[i] = constraints[i].ToSerializedConstraintItem(
			req.Configuration,
			req.AccountID,
			req.EnvID,
			req.FunctionID,
			keyPrefix,
		)
	}

	state.SortedConstraints = serialized

	return state, constraints
}

type acquireScriptResponse struct {
	Status        int `json:"s"`
	Requested     int `json:"r"`
	Granted       int `json:"g"`
	GrantedLeases []struct {
		LeaseID             ulid.ULID `json:"lid"`
		LeaseIdempotencyKey string    `json:"lik"`
	} `json:"l"`
	LimitingConstraints flexibleIntArray    `json:"lc"`
	FairnessReduction   int                 `json:"fr"`
	RetryAt             int                 `json:"ra"`
	Debug               flexibleStringArray `json:"d"`
}


func (r *redisCapacityManager) Acquire(ctx context.Context, req *CapacityAcquireRequest) (*CapacityAcquireResponse, errs.InternalError) {
	l := logger.StdlibLogger(ctx)

	// Validate request
	if err := req.Valid(); err != nil {
		return nil, errs.Wrap(0, false, "invalid request: %w", err)
	}

	l = l.With(
		"account_id", req.AccountID,
		"env_id", req.EnvID,
		"fn_id", req.FunctionID,
	)

	now := r.clock.Now()

	// TODO: Add metric for this
	// NOTE: This will include request latency (marshaling, network delays),
	// and it might not work for retries, as those retain the same CurrentTime value.
	// TODO: Ensure retries have the updated CurrentTime
	requestLatency := now.Sub(req.CurrentTime)
	if requestLatency > MaximumAllowedRequestDelay {
		// TODO : Set proper error code
		return nil, errs.Wrap(0, false, "exceeded maximum allowed request delay")
	}

	// Retrieve client and key prefix for current constraints
	// NOTE: We will no longer need this once we move to a dedicated store for constraint state
	keyPrefix, client, err := r.clientAndPrefix(req.Migration)
	if err != nil {
		return nil, errs.Wrap(0, false, "failed to get client: %w", err)
	}

	// TODO: Should we get the current time again/cancel if too much time passed up until here?
	leaseExpiry := now.Add(req.Duration)

	// Generate lease IDs
	initialLeaseIDs := make([]ulid.ULID, len(req.LeaseIdempotencyKeys))
	for i := range req.LeaseIdempotencyKeys {
		leaseID, err := ulid.New(ulid.Timestamp(leaseExpiry), rand.Reader)
		if err != nil {
			return nil, errs.Wrap(0, true, "failed to generate lease IDs: %w", err)
		}
		initialLeaseIDs[i] = leaseID
	}

	requestState, sortedConstraints := buildRequestState(req, keyPrefix)

	// Deterministically compute this based on numScavengerShards and accountID
	scavengerShard := r.scavengerShard(ctx, req.AccountID)

	// Build Lua request

	keys := []string{
		r.keyRequestState(keyPrefix, req.AccountID, req.IdempotencyKey),
		r.keyOperationIdempotency(keyPrefix, req.AccountID, "acq", req.IdempotencyKey),
		r.keyConstraintCheckIdempotency(keyPrefix, req.AccountID, req.IdempotencyKey),
		r.keyScavengerShard(keyPrefix, scavengerShard),
		r.keyAccountLeases(keyPrefix, req.AccountID),
	}

	enableDebugLogsVal := "0"
	if enableDebugLogs || r.enableDebugLogs {
		enableDebugLogsVal = "1"
	}

	args, err := strSlice([]any{
		// This will be marshaled
		requestState,
		req.AccountID,
		now.UnixMilli(), // current time in milliseconds for throttle
		now.UnixNano(),  // current time in nanoseconds for rate limiting

		leaseExpiry.UnixMilli(),
		keyPrefix,
		initialLeaseIDs,

		util.XXHash(req.IdempotencyKey), // hashed operation idempotency key
		int(OperationIdempotencyTTL.Seconds()),
		int(ConstraintCheckIdempotencyTTL.Seconds()),

		enableDebugLogsVal,
	})
	if err != nil {
		return nil, errs.Wrap(0, false, "invalid args: %w", err)
	}

	rawRes, err := scripts["acquire"].Exec(ctx, client, keys, args).AsBytes()
	if err != nil {
		return nil, errs.Wrap(0, false, "acquire script failed: %w", err)
	}

	parsedResponse := acquireScriptResponse{}
	err = json.Unmarshal(rawRes, &parsedResponse)
	if err != nil {
		return nil, errs.Wrap(0, false, "invalid response structure: %w", err)
	}

	leases := make([]CapacityLease, len(parsedResponse.GrantedLeases))
	for i, v := range parsedResponse.GrantedLeases {
		leases[i] = CapacityLease{
			LeaseID:        v.LeaseID,
			IdempotencyKey: v.LeaseIdempotencyKey,
		}
	}

	var limitingConstraints []ConstraintItem
	if len(parsedResponse.LimitingConstraints) > 0 {
		limitingConstraints = make([]ConstraintItem, len(parsedResponse.LimitingConstraints))
		for i, limitingConstraintIndex := range []int(parsedResponse.LimitingConstraints) {
			limitingConstraints[i] = sortedConstraints[limitingConstraintIndex-1]
		}
	}

	switch parsedResponse.Status {
	case 1, 3:
		l.Trace(
			"successful acquire call",
			"status", parsedResponse.Status,
			"leases", leases,
		)

		// success or idempotency
		return &CapacityAcquireResponse{
			Leases:              leases,
			LimitingConstraints: limitingConstraints,
			FairnessReduction:   parsedResponse.FairnessReduction,
			internalDebugState:  parsedResponse,
		}, nil

	case 2:
		l.Trace("acquire call lacking capacity", "status", parsedResponse.Status)

		// lacking capacity
		return &CapacityAcquireResponse{
			Leases:              leases,
			LimitingConstraints: limitingConstraints,
			RetryAfter:          time.UnixMilli(int64(parsedResponse.RetryAt)),
			FairnessReduction:   parsedResponse.FairnessReduction,
			internalDebugState:  parsedResponse,
		}, nil

	default:
		return nil, errs.Wrap(0, false, "unexpected status code %v", parsedResponse.Status)
	}
}
